-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast RFC 4648-compliant Base16 encoding
--   
--   RFC 4648-compliant Base16 encodings and decodings. This library
--   provides performant encoding and decoding primitives, as well as
--   support for textual values.
@package base16
@version 0.3.2.1


-- | This module contains <a>ByteString</a>-valued combinators for
--   implementing the RFC 4648 specification of the Base16 encoding format.
--   This includes lenient decoding variants, as well as internal and
--   external validation for canonicity.
module Data.ByteString.Base16

-- | Encode a <a>ByteString</a> value as Base16 <a>Text</a> with padding.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase16 "Sun"
--   "53756e"
--   </pre>
encodeBase16 :: ByteString -> Text

-- | Encode a <a>ByteString</a> value as a Base16 <a>ByteString</a> value
--   with padding.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase16' "Sun"
--   "53756e"
--   </pre>
encodeBase16' :: ByteString -> ByteString

-- | Decode a Base16-encoded <a>ByteString</a> value.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "53756e"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "6x"
--   Left "invalid character at offset: 1"
--   </pre>
decodeBase16 :: ByteString -> Either Text ByteString

-- | Decode Base16 <a>Text</a>.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16' "53756e"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16' "6x"
--   Left "invalid character at offset: 1"
--   </pre>
decodeBase16' :: Text -> Either Text ByteString

-- | Decode a Base16-encoded <a>ByteString</a> value leniently, using a
--   strategy that never fails
--   
--   N.B.: this is not RFC 4648-compliant
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "53756e"
--   "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "6x6x"
--   "f"
--   </pre>
decodeBase16Lenient :: ByteString -> ByteString

-- | Tell whether a <a>ByteString</a> value is base16 encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f"
--   True
--   </pre>
isBase16 :: ByteString -> Bool

-- | Tell whether a <a>ByteString</a> value is a valid Base16 format.
--   
--   This will not tell you whether or not this is a correct Base16
--   representation, only that it conforms to the correct alphabet. To
--   check whether it is a true Base16 encoded <a>ByteString</a> value, use
--   <a>isBase16</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f+/6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f6"
--   True
--   </pre>
isValidBase16 :: ByteString -> Bool


-- | This module contains <a>ByteString</a>-valued combinators for
--   implementing the RFC 4648 specification of the Base16 encoding format.
--   This includes lenient decoding variants, as well as internal and
--   external validation for canonicity.
module Data.ByteString.Lazy.Base16

-- | Encode a lazy <a>ByteString</a> value as Base16 <a>Text</a> with
--   padding.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase16 "Sun"
--   "53756e"
--   </pre>
encodeBase16 :: ByteString -> Text

-- | Encode a lazy <a>ByteString</a> value as a Base16 <a>ByteString</a>
--   value with padding.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase16' "Sun"
--   "53756e"
--   </pre>
encodeBase16' :: ByteString -> ByteString

-- | Decode a padded Base16-encoded lazy <a>ByteString</a> value.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "53756e"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "6x"
--   Left "invalid character at offset: 1"
--   </pre>
decodeBase16 :: ByteString -> Either Text ByteString

-- | Decode Base16 <a>Text</a>.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16' "53756e"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16' "6x"
--   Left "invalid character at offset: 1"
--   </pre>
decodeBase16' :: Text -> Either Text ByteString

-- | Decode a Base16-encoded <a>ByteString</a> value leniently, using a
--   strategy that never fails
--   
--   N.B.: this is not RFC 4648-compliant. It may give you garbage if
--   you're not careful!
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "53756e"
--   "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "6x6x"
--   "f"
--   </pre>
decodeBase16Lenient :: ByteString -> ByteString

-- | Tell whether a lazy <a>ByteString</a> value is base16 encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f"
--   True
--   </pre>
isBase16 :: ByteString -> Bool

-- | Tell whether a lazy <a>ByteString</a> value is a valid Base16 format.
--   
--   This will not tell you whether or not this is a correct Base16
--   representation, only that it conforms to the correct alphabet. To
--   check whether it is a true Base16 encoded <a>ByteString</a> value, use
--   <a>isBase16</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f+/6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f6"
--   True
--   </pre>
isValidBase16 :: ByteString -> Bool


-- | This module contains <a>ShortByteString</a>-valued combinators for
--   implementing the RFC 4648 specification of the Base16 encoding format.
--   This includes lenient decoding variants, as well as internal and
--   external validation for canonicity.
module Data.ByteString.Short.Base16

-- | Encode a <a>ShortByteString</a> value as Base16 <a>ShortText</a> with
--   padding.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase16 "Sun"
--   "53756e"
--   </pre>
encodeBase16 :: ShortByteString -> ShortText

-- | Encode a <a>ShortByteString</a> value as a Base16
--   <a>ShortByteString</a> value with padding.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase16' "Sun"
--   "53756e"
--   </pre>
encodeBase16' :: ShortByteString -> ShortByteString

-- | Decode a Base16-encoded <a>ShortByteString</a> value.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "53756e"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "6x"
--   Left "invalid character at offset: 1"
--   </pre>
decodeBase16 :: ShortByteString -> Either Text ShortByteString

-- | Decode Base16 <a>Text</a>.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16' "53756e"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16' "6x"
--   Left "invalid character at offset: 1"
--   </pre>
decodeBase16' :: ShortText -> Either Text ShortByteString

-- | Decode a Base16-encoded <a>ShortByteString</a> value leniently, using
--   a strategy that never fails
--   
--   N.B.: this is not RFC 4648-compliant
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "53756e"
--   "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "6x6x"
--   "f"
--   </pre>
decodeBase16Lenient :: ShortByteString -> ShortByteString

-- | Tell whether a <a>ShortByteString</a> value is base16 encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f"
--   True
--   </pre>
isBase16 :: ShortByteString -> Bool

-- | Tell whether a <a>ShortByteString</a> value is a valid Base16 format.
--   
--   This will not tell you whether or not this is a correct Base16
--   representation, only that it conforms to the correct alphabet. To
--   check whether it is a true Base16 encoded <a>ShortByteString</a>
--   value, use <a>isBase16</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f+/6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f6"
--   True
--   </pre>
isValidBase16 :: ShortByteString -> Bool


-- | This module contains the error types raised in the decoding process.
module Data.Text.Encoding.Base16.Error

-- | This data type represents the type of decoding errors of various kinds
--   as they pertain to decoding <a>Text</a> values. Namely, to distinguish
--   between decoding errors from opaque unicode exceptions caught in the
--   unicode decoding process.
data Base16Error e

-- | The error associated with decoding failure as a result of the Base16
--   decoding process
DecodeError :: Text -> Base16Error e

-- | The error associated with the decoding failure as a result of the
--   conversion process
ConversionError :: e -> Base16Error e
instance GHC.Generics.Generic (Data.Text.Encoding.Base16.Error.Base16Error e)
instance GHC.Show.Show e => GHC.Show.Show (Data.Text.Encoding.Base16.Error.Base16Error e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Data.Text.Encoding.Base16.Error.Base16Error e)
instance GHC.Exception.Type.Exception e => GHC.Exception.Type.Exception (Data.Text.Encoding.Base16.Error.Base16Error e)
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData (Data.Text.Encoding.Base16.Error.Base16Error e)


-- | This module contains <a>Text</a>-valued combinators for implementing
--   the RFC 4648 specification of the Base16 encoding format. This
--   includes lenient decoding variants, as well as internal and external
--   validation for canonicity.
module Data.Text.Encoding.Base16

-- | Encode a <a>Text</a> value in Base16 with padding.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase16 "Sun"
--   "53756e"
--   </pre>
encodeBase16 :: Text -> Text

-- | Decode a Base16-encoded <a>Text</a> value.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "53756e"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "6x"
--   Left "invalid character at offset: 1"
--   </pre>
decodeBase16 :: Text -> Either Text Text

-- | Attempt to decode a <a>Text</a> value as Base16, converting from
--   <a>ByteString</a> to <a>Text</a> according to some encoding function.
--   In practice, This is something like <tt>decodeUtf8'</tt>, which may
--   produce an error.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Example</b>:</h3>
--   
--   <pre>
--   <a>decodeBase16With</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base16Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase16With :: (ByteString -> Either err Text) -> ByteString -> Either (Base16Error err) Text

-- | Decode a Base16-encoded <a>Text</a> value leniently, using a strategy
--   that never fails, catching unicode exceptions raised in the process of
--   converting to text values.
--   
--   N.B.: this is not RFC 4648-compliant.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "53756e"
--   "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "6x6x"
--   "f"
--   </pre>
decodeBase16Lenient :: Text -> Text

-- | Tell whether a <a>Text</a> value is Base16-encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f"
--   True
--   </pre>
isBase16 :: Text -> Bool

-- | Tell whether a <a>Text</a> value is a valid Base16 format.
--   
--   This will not tell you whether or not this is a correct Base16
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base16 encoded <a>Text</a> value, use
--   <a>isBase16</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f+/6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f6"
--   True
--   </pre>
isValidBase16 :: Text -> Bool


-- | This module contains <a>Text</a>-valued combinators for implementing
--   the RFC 4648 specification of the Base16 encoding format. This
--   includes lenient decoding variants, as well as internal and external
--   validation for canonicity.
module Data.Text.Lazy.Encoding.Base16

-- | Encode a lazy <a>Text</a> value in Base16 with padding.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase16 "Sun"
--   "53756e"
--   </pre>
encodeBase16 :: Text -> Text

-- | Decode a Base16-encoded lazy <a>Text</a> value.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "53756e"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "6x"
--   Left "invalid character at offset: 1"
--   </pre>
decodeBase16 :: Text -> Either Text Text

-- | Attempt to decode a lazy <a>Text</a> value as Base16, converting from
--   <a>ByteString</a> to <a>Text</a> according to some encoding function.
--   In practice, This is something like <tt>decodeUtf8'</tt>, which may
--   produce an error.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <pre>
--   <a>decodeBase16With</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base16Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase16With :: (ByteString -> Either err Text) -> ByteString -> Either (Base16Error err) Text

-- | Decode a Base16-encoded lazy <a>Text</a> value leniently, using a
--   strategy that never fails.
--   
--   <i>Warning</i>: in the conversion to unicode text, exceptions may be
--   thrown. Please use <tt>decodeBase16'</tt> if you are unsure if you are
--   working with base16-encoded values, or if you expect garbage.
--   
--   N.B.: this is not RFC 4648-compliant. It may give you garbage if
--   you're not careful!
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "53756e"
--   "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "6x6x"
--   "f"
--   </pre>
decodeBase16Lenient :: Text -> Text

-- | Tell whether a lazy <a>Text</a> value is Base16-encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f"
--   True
--   </pre>
isBase16 :: Text -> Bool

-- | Tell whether a lazy <a>Text</a> value is a valid Base16 format.
--   
--   This will not tell you whether or not this is a correct Base16
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base16 encoded <a>Text</a> value, use
--   <a>isBase16</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f+/6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f6"
--   True
--   </pre>
isValidBase16 :: Text -> Bool


-- | This module contains <a>ShortText</a>-valued combinators for
--   implementing the RFC 4648 specification of the Base16 encoding format.
--   This includes lenient decoding variants, as well as internal and
--   external validation for canonicity.
module Data.Text.Short.Encoding.Base16

-- | Encode a <a>ShortText</a> value in Base16 with padding.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase16 "Sun"
--   "53756e"
--   </pre>
encodeBase16 :: ShortText -> ShortText

-- | Decode a Base16-encoded <a>ShortText</a> value.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "53756e"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16 "6x"
--   Left "invalid character at offset: 1"
--   </pre>
decodeBase16 :: ShortText -> Either Text ShortText

-- | Attempt to decode a <a>ShortText</a> value as Base16, converting from
--   <tt>ByteString</tt> to <a>ShortText</a> according to some encoding
--   function. In practice, This is something like <tt>decodeUtf8'</tt>,
--   which may produce an error.
--   
--   See: <a>RFC-4648 section 8</a>
--   
--   <h3><b>Example</b>:</h3>
--   
--   <pre>
--   <a>decodeBase16With</a> (fmap <a>fromText</a> . <a>decodeUtf8'</a> . <a>fromShort</a>)
--     :: <a>ShortByteString</a> -&gt; <a>Either</a> (<a>Base16Error</a> <tt>UnicodeException</tt>) <a>ShortText</a>
--   </pre>
decodeBase16With :: (ShortByteString -> Either err ShortText) -> ShortByteString -> Either (Base16Error err) ShortText

-- | Decode a Base16-encoded <a>ShortText</a> value leniently, using a
--   strategy that never fails, catching unicode exceptions raised in the
--   process of converting to text values.
--   
--   N.B.: this is not RFC 4648-compliant.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "53756e"
--   "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase16Lenient "6x6x"
--   "f"
--   </pre>
decodeBase16Lenient :: ShortText -> ShortText

-- | Tell whether a <a>ShortText</a> value is Base16-encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase16 "666f"
--   True
--   </pre>
isBase16 :: ShortText -> Bool

-- | Tell whether a <a>ShortText</a> value is a valid Base16 format.
--   
--   This will not tell you whether or not this is a correct Base16
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base16 encoded <a>ShortText</a> value, use
--   <a>isBase16</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f+/6"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase16 "666f6"
--   True
--   </pre>
isValidBase16 :: ShortText -> Bool
