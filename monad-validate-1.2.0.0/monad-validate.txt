-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monad transformer for data validation.
--   
--   Provides the <a>ValidateT</a> monad transformer, designed for writing
--   data validations that provide high-quality error reporting without
--   much effort. <a>ValidateT</a> automatically exploits the data
--   dependencies of your program—as encoded implicitly in uses of
--   <a>fmap</a>, <a>&lt;*&gt;</a>, and <a>&gt;&gt;=</a>—to report as many
--   errors as possible upon failure instead of completely aborting at the
--   first one. See <a>Control.Monad.Validate</a> for more information.
@package monad-validate
@version 1.2.0.0

module Control.Monad.Validate.Class

-- | The class of validation monads, intended to be used to validate data
--   structures while collecting errors along the way. In a sense,
--   <a>MonadValidate</a> is like a combination of <a>MonadError</a> and
--   <a>MonadWriter</a>, but it isn’t entirely like either. The two
--   essential differences are:
--   
--   <ol>
--   <li>Unlike <a>throwError</a>, raising an error using <a>refute</a>
--   does not always abort the entire computation—it may only abort a local
--   part of it.</li>
--   <li>Unlike <a>tell</a>, raising an error using <a>dispute</a> still
--   causes the computation to globally fail, it just doesn’t affect local
--   execution.</li>
--   </ol>
--   
--   Instances must obey the following law:
--   
--   <pre>
--   <a>dispute</a> ≡ <a>void</a> <a>.</a> <a>tolerate</a> <a>.</a> <a>refute</a>
--   </pre>
--   
--   For a more thorough explanation, with examples, see the documentation
--   for <a>ValidateT</a>.
class (Monad m, Semigroup e) => MonadValidate e m | m -> e

-- | Raises a fatal validation error. Aborts the current branch of the
--   validation (i.e. does not return).
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> (<a>refute</a> ["boom"] <a>&gt;&gt;</a> <a>refute</a> ["bang"])
--   <a>Left</a> ["boom"]
--   </pre>
refute :: MonadValidate e m => e -> m a

-- | Raises a non-fatal validation error. The overall validation fails, and
--   the error is recorded, but validation continues in an attempt to try
--   and discover more errors.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> (<a>dispute</a> ["boom"] <a>&gt;&gt;</a> <a>dispute</a> ["bang"])
--   <a>Left</a> ["boom", "bang"]
--   </pre>
--   
--   If not explicitly implemented, the default implementation is
--   <tt><a>void</a> <a>.</a> <a>tolerate</a> <a>.</a> <a>refute</a></tt>
--   (which must behave equivalently by law), but it is sometimes possible
--   to provide a more efficient implementation.
dispute :: MonadValidate e m => e -> m ()

-- | <tt><a>tolerate</a> m</tt> behaves like <tt>m</tt>, except that any
--   fatal errors raised by <a>refute</a> are altered to non-fatal errors
--   that return <a>Nothing</a>. This allows <tt>m</tt>’s result to be used
--   for further validation if it succeeds without preventing further
--   validation from occurring upon failure.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> (<a>tolerate</a> (<a>refute</a> ["boom"]) <a>&gt;&gt;</a> <a>refute</a> ["bang"])
--   <a>Left</a> ["boom", "bang"]
--   </pre>
tolerate :: MonadValidate e m => m a -> m (Maybe a)

-- | Runs an <a>ExceptT</a> computation, and if it raised an error,
--   re-raises it using <a>refute</a>. This effectively converts a
--   computation that uses <a>ExceptT</a> (or <a>MonadError</a>) into one
--   that uses <a>MonadValidate</a>.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> <a>$</a> <a>exceptToValidate</a> (<a>pure</a> 42)
--   <a>Right</a> 42
--   &gt;&gt;&gt; <a>runValidate</a> <a>$</a> <a>exceptToValidate</a> (<a>throwError</a> ["boom"])
--   <a>Left</a> "boom"
--   </pre>
exceptToValidate :: forall e m a. MonadValidate e m => ExceptT e m a -> m a

-- | Like <a>exceptToValidate</a>, but additionally accepts a function,
--   which is applied to the error raised by <a>ExceptT</a> before passing
--   it to <a>refute</a>. This can be useful if the original error type is
--   not a <a>Semigroup</a>.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> <a>$</a> <a>exceptToValidateWith</a> (:[]) (<a>pure</a> 42)
--   <a>Right</a> 42
--   &gt;&gt;&gt; <a>runValidate</a> <a>$</a> <a>exceptToValidateWith</a> (:[]) (<a>throwError</a> "boom")
--   <a>Left</a> ["boom"]
--   </pre>
exceptToValidateWith :: forall e1 e2 m a. MonadValidate e2 m => (e1 -> e2) -> ExceptT e1 m a -> m a

-- | If you have a monad transformer that implements the
--   <a>MonadTransControl</a> class, this newtype wrapper can be used to
--   automatically derive instances of <a>MonadValidate</a> using the
--   <tt>DerivingVia</tt> GHC extension.
--   
--   Example:
--   
--   <pre>
--   {-# LANGUAGE DerivingVia #-}
--   
--   newtype CustomT c m a = CustomT { runCustomT :: ... }
--     deriving (<a>MonadValidate</a> e) via (<a>WrappedMonadTrans</a> (CustomT c) m)
--   </pre>
newtype WrappedMonadTrans (t :: (* -> *) -> * -> *) (m :: * -> *) (a :: *)
WrapMonadTrans :: t m a -> WrappedMonadTrans (t :: (* -> *) -> * -> *) (m :: * -> *) (a :: *)
[unwrapMonadTrans] :: WrappedMonadTrans (t :: (* -> *) -> * -> *) (m :: * -> *) (a :: *) -> t m a
instance Control.Monad.Trans.Control.MonadTransControl t => Control.Monad.Trans.Control.MonadTransControl (Control.Monad.Validate.Class.WrappedMonadTrans t)
instance Control.Monad.Trans.Class.MonadTrans t => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Validate.Class.WrappedMonadTrans t)
instance GHC.Base.Monad (t m) => GHC.Base.Monad (Control.Monad.Validate.Class.WrappedMonadTrans t m)
instance GHC.Base.Applicative (t m) => GHC.Base.Applicative (Control.Monad.Validate.Class.WrappedMonadTrans t m)
instance GHC.Base.Functor (t m) => GHC.Base.Functor (Control.Monad.Validate.Class.WrappedMonadTrans t m)
instance Control.Monad.Validate.Class.MonadValidate e m => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Validate.Class.MonadValidate e m => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.Except.ExceptT a m)
instance Control.Monad.Validate.Class.MonadValidate e m => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Validate.Class.MonadValidate e m => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.Reader.ReaderT r m)
instance (Control.Monad.Validate.Class.MonadValidate e m, GHC.Base.Monoid w) => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Validate.Class.MonadValidate e m, GHC.Base.Monoid w) => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Validate.Class.MonadValidate e m => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Validate.Class.MonadValidate e m => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.State.Strict.StateT s m)
instance (Control.Monad.Validate.Class.MonadValidate e m, GHC.Base.Monoid w) => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Control.Monad.Validate.Class.MonadValidate e m, GHC.Base.Monoid w) => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Control.Monad.Trans.Control.MonadTransControl t, GHC.Base.Monad (t m), Control.Monad.Validate.Class.MonadValidate e m) => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Validate.Class.WrappedMonadTrans t m)
instance (Control.Monad.Validate.Class.MonadValidate e m, GHC.Base.Monoid w) => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (Control.Monad.Validate.Class.MonadValidate e m, GHC.Base.Monoid w) => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Trans.RWS.CPS.RWST r w s m)


-- | <b>This is an internal module.</b> Backwards compatibility will not be
--   maintained. See <a>Control.Monad.Validate</a> for the public
--   interface.
module Control.Monad.Validate.Internal

-- | <a>ValidateT</a> is a monad transformer for writing validations. Like
--   <a>ExceptT</a>, <a>ValidateT</a> is primarily concerned with the
--   production of errors, but it differs from <a>ExceptT</a> in that
--   <a>ValidateT</a> is designed not to necessarily halt on the first
--   error. Instead, it provides a mechanism for collecting many warnings
--   or errors, ideally as many as possible, before failing. In that sense,
--   <a>ValidateT</a> is also somewhat like <a>WriterT</a>, but it is not
--   <i>just</i> a combination of <a>ExceptT</a> and <a>WriterT</a>.
--   Specifically, it differs in the following two respects:
--   
--   <ol>
--   <li><a>ValidateT</a> automatically collects errors from all branches
--   of an <a>Applicative</a> expression, making it possible to write code
--   in the same style that one would use with <a>ExceptT</a> and
--   automatically get additional information for free. (This is especially
--   true when used in combination with the <tt>ApplicativeDo</tt> language
--   extension.)</li>
--   <li><a>ValidateT</a> provides error signaling operators, <a>refute</a>
--   and <a>dispute</a>, which are similar to <a>throwError</a> and
--   <a>tell</a>, respectively. However, both operators combine raised
--   errors into a single value (using an arbitrary <a>Semigroup</a>), so
--   the relative ordering of validation errors is properly respected. (Of
--   course, if the order doesn’t matter to you, you can choose to
--   accumulate errors into an unordered container.)</li>
--   </ol>
--   
--   <h2>An introduction to <a>ValidateT</a></h2>
--   
--   The first of the above two points is by far the most interesting
--   feature of <a>ValidateT</a>. Let’s make it more concrete with an
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> (<a>refute</a> ["bang"] <a>*&gt;</a> <a>refute</a> ["boom"])
--   <a>Left</a> ["bang", "boom"]
--   </pre>
--   
--   At first blush, the above example may lead you to believe that
--   <a>refute</a> is like <a>tell</a> from <a>WriterT</a>, but it is
--   actually more like <a>throwError</a>. Consider its type:
--   
--   <pre>
--   <a>refute</a> :: <a>MonadValidate</a> e m =&gt; e -&gt; m a
--   </pre>
--   
--   Note that, like <a>throwError</a>, <a>refute</a> is polymorphic in its
--   return type, which is to say it never returns. Indeed, if we introduce
--   a dependency on a computation that fails using <a>refute</a> via
--   <a>&gt;&gt;=</a>, the downstream computation will not be run:
--   
--   <pre>
--   &gt;&gt;&gt; let getString = <a>refute</a> ["bang"] <a>*&gt;</a> <a>pure</a> "boom"
--           useString a = <a>refute</a> [a]
--       in <a>runValidate</a> (getString <a>&gt;&gt;=</a> useString)
--   <a>Left</a> ["bang"]
--   </pre>
--   
--   This works because although the <a>Monad</a> instance for
--   <a>ValidateT</a> fails as soon as the first <a>refute</a> is executed
--   (as it must due to the way the second argument of <a>&gt;&gt;=</a>
--   depends on the result of its first argument), the <a>Applicative</a>
--   instance runs all branches of <a>&lt;*&gt;</a> and combines the errors
--   produced by all of them. When <tt>ApplicativeDo</tt> is enabled, this
--   can lead to some “magical” looking error reporting where validation
--   automatically continues on each sub-piece of a piece of data until it
--   absolutely cannot proceed any further. As an example, this package’s
--   test suite includes the following function:
--   
--   <pre>
--   validateQueryRequest :: (<a>MonadReader</a> Env m, <a>MonadValidate</a> [Error] m) =&gt; Value -&gt; m QueryRequest
--   validateQueryRequest req = withObject "request" req <a>$</a> o -&gt; do
--     qrAuth           &lt;- withKey o "auth_token" parseAuthToken
--     ~(qrTable, info) &lt;- withKey o "table" parseTableName
--     qrQuery          &lt;- withKey o "query" parseQuery
--     <a>for_</a> info <a>$</a> tableInfo -&gt; pushPath "query" <a>$</a>
--       validateQuery qrTable tableInfo (atIsAdmin qrAuth) qrQuery
--     <a>pure</a> QueryRequest { qrAuth, qrTable, qrQuery }
--   </pre>
--   
--   The above <tt>do</tt> block parses and validates some JSON, and it’s
--   written as straight line code, but with <tt>ApplicativeDo</tt> enabled
--   (along with the <tt>-foptimal-applicative-do</tt> option, which makes
--   GHC try a little harder), it still produces errors for all parts of
--   the input document at once:
--   
--   <pre>
--   &gt;&gt;&gt; <a>flip</a> <a>runReader</a> env <a>.</a> <a>runValidateT</a> <a>$</a> validateQueryRequest [aesonQQ|
--         { "auth_token": 123
--         , "table": { "name": "users" }
--         , "query": { "add":
--           [ { "lit": "42" }
--           , { "select": "points" } ]}
--         }|]
--   <a>Left</a> [ Error ["auth_token"] (JSONBadValue "string" (Number 123))
--        , Error ["table"] (JSONMissingKey "schema")
--        , Error ["query", "add", "lit"] (JSONBadValue "number" (String "42")) ]
--   </pre>
--   
--   The penultimate statement in the <tt>do</tt> block—the one with the
--   call to <tt>validateQuery</tt>—depends on several of the bindings
--   bound earlier in the same <tt>do</tt> block, namely <tt>qrAuth</tt>,
--   <tt>info</tt>, and <tt>qrQuery</tt>. Because of that,
--   <tt>validateQuery</tt> will not be executed so long as any of its
--   dependencies fail. As soon as they all succeed, their results will be
--   passed to <tt>validateQuery</tt> as usual, and validation will
--   continue.
--   
--   <h2>The full details</h2>
--   
--   Although <a>ValidateT</a> (with <tt>ApplicativeDo</tt>) may seem
--   magical, of course, it is not. As alluded to above, <a>ValidateT</a>
--   simply provides a <a>&lt;*&gt;</a> implementation that collects errors
--   produced by both arguments rather than short-circuiting as soon as the
--   first error is raised.
--   
--   However, that explanation alone may raise some additional questions.
--   What about the monad laws? When <a>ValidateT</a> is used in a monad
--   transformer stack, what happens to side effects? And what are
--   <a>ValidateT</a>’s performance characteristics? The remainder of this
--   section discusses those topics.
--   
--   <h3><a>ValidateT</a> and the <a>Monad</a> laws</h3>
--   
--   <a>ValidateT</a>’s <a>Applicative</a> and <a>Monad</a> instances do
--   not conform to a strict interpretation of the <a>Monad</a> laws, which
--   dictate that <a>&lt;*&gt;</a> must be equivalent to <a>ap</a>. For
--   <a>ValidateT</a>, this is not true if we consider “equivalent” to mean
--   <a>==</a>. However, if we accept a slightly weaker notion of
--   equivalence, we can satisfy the laws. Specifically, we may use the
--   definition that some <a>Validate</a> action <tt>a</tt> is equivalent
--   to another action <tt>b</tt> iff
--   
--   <ul>
--   <li>if <tt><a>runValidate</a> a</tt> produces <tt><a>Right</a> x</tt>,
--   then <tt><a>runValidate</a> b</tt> must produce <tt><a>Right</a>
--   y</tt> where <tt>x <a>==</a> y</tt> (and <a>==</a> is the usual
--   Haskell <a>==</a>),</li>
--   <li>and if <tt><a>runValidate</a> a</tt> produces <tt><a>Left</a>
--   x</tt>, then <tt><a>runValidate</a> b</tt> must produce
--   <tt><a>Left</a> y</tt> (but <tt>x</tt> and <tt>y</tt> may be
--   unrelated).</li>
--   </ul>
--   
--   In other words, our definition of equivalence is like <a>==</a>,
--   except that we make no guarantees about the <i>contents</i> of an
--   error should one occur. However, we <i>do</i> guarantee that replacing
--   <a>&lt;*&gt;</a> with <a>ap</a> or vice versa will never change an
--   error to a success or a success to an error, nor will it change the
--   value of a successful result in any way. To put it another way,
--   <a>ValidateT</a> provides “best effort” error reporting: it will never
--   return fewer errors than an equivalent use of <a>ExceptT</a>, but it
--   might return more.
--   
--   <h3>Using <a>ValidateT</a> with other monad transformers</h3>
--   
--   <a>ValidateT</a> is a valid, lawful, generally well-behaved monad
--   transformer, and it is safe to use within a larger monad transformer
--   stack. Instances for the most common <tt>mtl</tt>-style typeclasses
--   are provided. <b>However</b>, be warned: many common monad
--   transformers do not have sufficiently order-independent
--   <a>Applicative</a> instances for <a>ValidateT</a>’s <a>Applicative</a>
--   instance to actually collect errors from multiple branches of a
--   computation.
--   
--   To understand why that might be, consider that <a>StateT</a> must
--   enforce a left-to-right evaluation order for <a>&lt;*&gt;</a> in order
--   to thread the state through the computation. If the <tt>a</tt> action
--   in an expression <tt>a <a>&lt;*&gt;</a> b</tt> fails, then it is
--   simply not possible to run <tt>b</tt> since <tt>b</tt> may still
--   depend on the state that would have been produced by <tt>a</tt>.
--   Similarly, <a>ExceptT</a> enforces a left-to-right evaluation because
--   it aborts a computation as soon as an error is thrown. Using
--   <a>ValidateT</a> with these kinds of monad transformers will cause it
--   to effectively degrade to <a>WriterT</a> over <a>ExceptT</a> since it
--   will not be able to gather any errors produced by <a>refute</a> beyond
--   the first one.
--   
--   However, even that isn’t the whole story, since the relative order of
--   monads in a monad transformer stack can affect things further. For
--   example, while the <a>StateT</a> monad transformer enforces
--   left-to-right evaluation order, it only does this for the monad
--   <i>underneath</i> it, so although <tt><a>StateT</a> s
--   (<a>ValidateT</a> e)</tt> will not be able to collect multiple errors,
--   <tt><a>ValidateT</a> e (<a>State</a> s)</tt> will. Note, however, that
--   those two types differ in other ways, too—running each to completion
--   results in different types:
--   
--   <pre>
--   <a>runState</a> (<a>runValidateT</a> m) s :: (<a>Either</a> e a, s)
--   <a>runValidate</a> (<a>runStateT</a> m s) :: <a>Either</a> e (a, s)
--   </pre>
--   
--   That kind of difference is generally true when using monad
--   transformers—the two combinations of <a>ExceptT</a> and <a>StateT</a>
--   have the same types as above, for example—but because <a>ValidateT</a>
--   needs to be on top of certain transformers for it to be useful,
--   combining <a>ValidateT</a> with certain transformers may be of little
--   practical use.
--   
--   One way to identify which monad transformers are uncooperative in the
--   aforementioned way is to look at the constraints included in the
--   context of the transformer’s <a>Applicative</a> instance. Transformers
--   like <a>StateT</a> have instances of the shape
--   
--   <pre>
--   instance <a>Monad</a> m =&gt; <a>Applicative</a> (<a>StateT</a> s m)
--   </pre>
--   
--   which notably require <a>Monad</a> instances just to implement
--   <a>Applicative</a>! However, this is not always sufficient for
--   distinguishing which functions or instances use <a>&lt;*&gt;</a> and
--   which use <a>&gt;&gt;=</a>, especially since many older libraries
--   (which predate <a>Applicative</a>) may include <a>Monad</a> contraints
--   even when they only use features of <a>Applicative</a>. The only way
--   to be certain is to examine the implementation (or conservatively
--   write code that is explicitly restricted to <a>Applicative</a>).
--   
--   (As it happens, <a>ValidateT</a>’s <a>Applicative</a> is actually one
--   such “uncooperative” instance itself: it has a <a>Monad</a> constraint
--   in its context. It is possible to write an implementation of
--   <a>ValidateT</a> without that constraint, but its <a>&lt;*&gt;</a>
--   would necessarily leak space in the same way <a>WriterT</a>’s
--   <a>&gt;&gt;=</a> leaks space. If you have a reason to want the less
--   efficient but more permissive variant, please let the author of this
--   library know, as she would probably find it interesting.)
--   
--   <h2>Performance characteristics of <a>ValidateT</a></h2>
--   
--   Although the interface to <a>ValidateT</a> is minimal, there are
--   surprisingly many different ways to implement it, each with its own
--   set of performance tradeoffs. Here is a quick summary of the choices
--   <a>ValidateT</a> makes:
--   
--   <ol>
--   <li><a>ValidateT</a> is <b>strict</b> in the set of errors it
--   accumulates, which is to say it reduces them to weak head normal form
--   (WHNF) via <a>seq</a> immediately upon any call to <a>refute</a> or
--   <a>dispute</a>.</li>
--   <li>Furthermore, all of <a>ValidateT</a>’s operations, including
--   <a>&lt;*&gt;</a>, operate in <b>constant space</b>. This means, for
--   example, that evaluating <tt><a>sequence_</a> xs</tt> will consume
--   constant space regardless of the size of <tt>xs</tt>, not counting any
--   space consumed purely due to the relevant <a>Foldable</a> instance’s
--   traversal of <tt>xs</tt>.</li>
--   <li>Finally, <a>ValidateT</a> accumulates errors in a
--   <b>left-associative</b> manner, which is to say that any uses of
--   <a>refute</a> or <a>dispute</a> combine the existing set of errors,
--   <tt>e</tt>, with the added set of errors, <tt>e'</tt>, via the
--   expression <tt>e <a>&lt;&gt;</a> e'</tt>.</li>
--   </ol>
--   
--   A good rule of thumb is that <a>ValidateT</a> has similar performance
--   characteristics to <tt><a>foldl'</a> (<a>&lt;&gt;</a>)</tt>, while
--   types like <tt>Validation</tt> from the <tt>either</tt> package tend
--   to have similar performance characteristics to <tt><a>foldr</a>
--   (<a>&lt;&gt;</a>)</tt>. That decision has both significant advantages
--   and significant disadvantages; the following subsections elaborate
--   further.
--   
--   <h3><a>&lt;*&gt;</a> takes constant space</h3>
--   
--   Great care has been taken in the implementation of <a>&lt;*&gt;</a> to
--   ensure it does not leak space. Notably, the same <i>cannot</i> be said
--   for many existing implementations of similar concepts. For example,
--   you will find that executing the expression
--   
--   <pre>
--   let m () = <a>pure</a> () <a>*&gt;</a> m () in m ()
--   </pre>
--   
--   may continuously allocate memory until it is exhausted for types such
--   as <tt>Validation</tt> (from the <tt>either</tt> package), but
--   <a>ValidateT</a> will execute it in constant space. This point may
--   seem silly, since the above definition of <tt>m ()</tt> will never do
--   anything useful, anyway, but the same point also applies to operations
--   like <a>sequence_</a>.
--   
--   In practice, this issue matters far less for types like
--   <tt>Validation</tt> than it does for <a>ValidateT</a>, as
--   <tt>Validation</tt> and its cousins don’t have a <a>Monad</a> instance
--   and do not generally experience the same usage patterns. (The
--   additional laziness they are capable of can sometimes even avoid the
--   space leak altogether.) However, it can be relevant more often for
--   <a>ValidateT</a>, so this implementation makes choices to avoid the
--   potential for the leak altogether.
--   
--   <h3>Errors are accumulated using strict, left-associated
--   <a>&lt;&gt;</a></h3>
--   
--   A major consequence of the decision to both strictly accumulate state
--   and maintain constant space is that <a>ValidateT</a>’s internal
--   applications of <a>&lt;&gt;</a> to combine errors are naturally strict
--   and left-associated, not lazy and right-associated like they are for
--   types like <tt>Validation</tt>. If the number of errors your
--   validation generates is small, this difference is irrelevant, but if
--   it is large, the difference in association can prove disastrous if the
--   <a>Semigroup</a> you choose to accumulate errors in is <tt>[a]</tt>!
--   
--   To make it painfully explicit why using <tt>[a]</tt> can come back to
--   bite you, consider that each time <a>ValidateT</a> executes
--   <tt><a>refute</a> e'</tt>, given some existing collection of errors
--   <tt>e</tt>, it (strictly) evalutes <tt>e <a>&lt;&gt;</a> e'</tt> to
--   obtain a new collection of errors. Now consider the implications of
--   that if <tt>e</tt> is a ten thousand element list: <a>&lt;&gt;</a>
--   will have to traverse <i>all</i> ten thousand elements and reallocate
--   a fresh cons cell for every single one in order to build the new list,
--   even if just one element is being appended to the end! Unfortunately,
--   the ubiquitous, built-in <tt>[a]</tt> type is clearly an exceptionally
--   poor choice for this pattern of accumulation.
--   
--   Fortunately, the solution is quite simple: use a different data
--   structure. If order doesn’t matter, use a <tt>Set</tt> or
--   <tt>HashSet</tt>. If it does, but either LIFO consumption of the data
--   is okay or you are okay with paying to reverse the data once after
--   collecting the errors, use <tt><a>Dual</a> [a]</tt> to accumulate
--   elements in an efficient manner. If neither is true, use a data
--   structure like <tt>Seq</tt> that provides an efficient implementation
--   of a functional queue. You can always convert back to a plain list at
--   the end once you’re done, if you have to.
newtype ValidateT e m a
ValidateT :: (forall s. StateT (MonoMaybe s e) (ExceptT e m) a) -> ValidateT e m a
[getValidateT] :: ValidateT e m a -> forall s. StateT (MonoMaybe s e) (ExceptT e m) a
validateT :: forall e m a. Functor m => (forall s. MonoMaybe s e -> m (Either e (MonoMaybe s e, a))) -> ValidateT e m a
unValidateT :: forall s e m a. Functor m => MonoMaybe s e -> ValidateT e m a -> m (Either e (MonoMaybe s e, a))

-- | An opaque type used to capture the current state of a <a>ValidateT</a>
--   computation, used as the <a>StT</a> instance for <a>ValidateT</a>. It
--   is opaque in an attempt to protect internal invariants about the
--   state, but it is unfortunately still theoretically possible for it to
--   be misused (but such misuses are exceedingly unlikely).
data ValidateTState e a
ValidateTState :: Either e (MonoMaybe s e, a) -> ValidateTState e a
[getValidateTState] :: ValidateTState e a -> Either e (MonoMaybe s e, a)
liftCatch :: Functor m => (forall b. m b -> (e -> m b) -> m b) -> ValidateT d m a -> (e -> ValidateT d m a) -> ValidateT d m a
liftMask :: Functor m => (forall c. ((forall a. m a -> m a) -> m c) -> m c) -> ((forall a. ValidateT e m a -> ValidateT e m a) -> ValidateT e m b) -> ValidateT e m b

-- | Runs a <a>ValidateT</a> computation, returning the errors raised by
--   <a>refute</a> or <a>dispute</a> if any, otherwise returning the
--   computation’s result.
runValidateT :: forall e m a. Functor m => ValidateT e m a -> m (Either e a)

-- | Runs a <a>ValidateT</a> computation, returning the errors on failure
--   or <a>mempty</a> on success. The computation’s result, if any, is
--   discarded.
--   
--   <pre>
--   &gt;&gt;&gt; <a>execValidate</a> (<a>refute</a> ["bang"])
--   ["bang"]
--   &gt;&gt;&gt; <a>execValidate</a> @[] (<a>pure</a> 42)
--   []
--   </pre>
execValidateT :: forall e m a. (Monoid e, Functor m) => ValidateT e m a -> m e

-- | Runs a <a>ValidateT</a> transformer by interpreting it in an
--   underlying transformer with a <a>MonadValidate</a> instance. That
--   might seem like a strange thing to do, but it can be useful in
--   combination with <a>mapErrors</a> to locally alter the error type in a
--   larger <a>ValidateT</a> computation. For example:
--   
--   <pre>
--   throwsIntegers :: <a>MonadValidate</a> [<a>Integer</a>] m =&gt; m ()
--   throwsIntegers = <a>dispute</a> [42]
--   
--   throwsBools :: <a>MonadValidate</a> [<a>Bool</a>] m =&gt; m ()
--   throwsBools = <a>dispute</a> [<a>False</a>]
--   
--   throwsBoth :: <a>MonadValidate</a> [<a>Either</a> <a>Integer</a> <a>Bool</a>] m =&gt; m ()
--   throwsBoth = do
--     <a>embedValidateT</a> <a>$</a> <a>mapErrors</a> (<a>map</a> <a>Left</a>) throwsIntegers
--     <a>embedValidateT</a> <a>$</a> <a>mapErrors</a> (<a>map</a> <a>Right</a>) throwsBools
--   
--   &gt;&gt;&gt; <a>runValidate</a> throwsBoth
--   <a>Left</a> [<a>Left</a> 42, <a>Right</a> False]
--   </pre>
embedValidateT :: forall e m a. MonadValidate e m => ValidateT e m a -> m a

-- | Applies a function to all validation errors produced by a
--   <a>ValidateT</a> computation.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> <a>$</a> <a>mapErrors</a> (<a>map</a> <a>show</a>) (<a>refute</a> [11, 42])
--   <a>Left</a> ["11", "42"]
--   </pre>
mapErrors :: forall e1 e2 m a. (Monad m, Semigroup e2) => (e1 -> e2) -> ValidateT e1 m a -> ValidateT e2 m a

-- | Runs a <a>ValidateT</a> computation, and if it raised any errors,
--   re-raises them using <a>throwError</a>. This effectively converts a
--   computation that uses <a>ValidateT</a> (or <a>MonadValidate</a>) into
--   one that uses <a>MonadError</a>.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runExcept</a> <a>$</a> <a>validateToError</a> (<a>pure</a> 42)
--   <a>Right</a> 42
--   &gt;&gt;&gt; <a>runExcept</a> <a>$</a> <a>validateToError</a> (<a>refute</a> ["boom"] *&gt; <a>refute</a> ["bang"])
--   <a>Left</a> ["boom", "bang"]
--   </pre>
validateToError :: forall e m a. MonadError e m => ValidateT e m a -> m a

-- | Like <a>validateToError</a>, but additionally accepts a function,
--   which is applied to the errors raised by <a>ValidateT</a> before
--   passing them to <a>throwError</a>. This can be useful to concatenate
--   multiple errors into one.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runExcept</a> <a>$</a> <a>validateToErrorWith</a> <a>mconcat</a> (<a>pure</a> 42)
--   <a>Right</a> 42
--   &gt;&gt;&gt; <a>runExcept</a> <a>$</a> <a>validateToErrorWith</a> <a>mconcat</a> (<a>refute</a> ["boom"] *&gt; <a>refute</a> ["bang"])
--   <a>Left</a> "boombang"
--   </pre>
validateToErrorWith :: forall e1 e2 m a. MonadError e2 m => (e1 -> e2) -> ValidateT e1 m a -> m a

-- | <a>ValidateT</a> specialized to the <a>Identity</a> base monad. See
--   <a>ValidateT</a> for usage information.
type Validate e = ValidateT e Identity

-- | See <a>runValidateT</a>.
runValidate :: forall e a. Validate e a -> Either e a

-- | See <a>execValidateT</a>.
execValidate :: forall e a. Monoid e => Validate e a -> e

-- | Monotonically increasing <a>Maybe</a> values. A function with the type
--   
--   <pre>
--   forall s. <a>MonoMaybe</a> s Foo -&gt; <a>MonoMaybe</a> s Bar
--   </pre>
--   
--   may return <a>MNothing</a> only when given <a>MNothing</a>, but it may
--   return <a>MJust</a> for any input. This is useful for keeping track of
--   the error state within <a>ValidateT</a>, since we want to statically
--   prevent the possibility of a <a>ValidateT</a> action being passed a
--   nonempty set of errors but returning no errors.
--   
--   The benefit of this additional type tracking shows up most prominently
--   in the implementation of <a>&lt;*&gt;</a>. Consider an expression
--   <tt>x <a>&lt;*&gt;</a> y</tt>, where <tt>x</tt> is an action that
--   fails, but <tt>y</tt> is an action that succeeds. We pass the errors
--   returned by <tt>x</tt> to <tt>y</tt>, then pattern-match on
--   <tt>y</tt>’s result. If <tt>y</tt> succeeds, we’ll end up with a tuple
--   of type <tt>(<a>MonoMaybe</a> '<a>SJust</a> e, a)</tt>. We can’t use
--   the second element of that tuple at all because we need to return a
--   value of type <tt>b</tt>, but the only way to get one is to apply a
--   function of type <tt>a -&gt; b</tt> returned by <tt>x</tt>… which we
--   don’t have, since <tt>x</tt> failed.
--   
--   Since we can’t produce a value of type <tt><a>Right</a> b</tt>, our
--   only option is to return a value of type <tt><a>Left</a> e</tt>. But
--   if the first element of the tuple had type <tt><a>Maybe</a> e</tt>,
--   we’d now be in a sticky situation! Its value could be <a>Nothing</a>,
--   but we need it to be <tt><a>Just</a> e</tt> since we only have a
--   <a>Semigroup</a> instance for <tt>e</tt>, not a <a>Monoid</a>
--   instance, so we can’t produce an <tt>e</tt> out of thin air. However,
--   by returning a <a>MonoMaybe</a>, we guarantee that the result will be
--   <tt><a>MJust</a> e</tt>, and we can proceed safely.
data MonoMaybe s a
[MNothing] :: MonoMaybe 'SMaybe a
[MJust] :: forall s a. !a -> MonoMaybe s a

-- | The kind of types used to track the current state of a
--   <a>MonoMaybe</a> value.
data MonoMaybeS
SMaybe :: MonoMaybeS
SJust :: MonoMaybeS

-- | Like <a>maybe</a> but for <a>MonoMaybe</a>.
monoMaybe :: (s ~ 'SMaybe => b) -> (a -> b) -> MonoMaybe s a -> b
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Validate.Internal.ValidateT e m)
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Validate.Internal.ValidateTState e a)
instance GHC.Base.Functor (Control.Monad.Validate.Internal.ValidateTState e)
instance GHC.Show.Show a => GHC.Show.Show (Control.Monad.Validate.Internal.MonoMaybe s a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Monad.Validate.Internal.MonoMaybe s a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Monad.Validate.Internal.MonoMaybe s a)
instance GHC.Base.Functor (Control.Monad.Validate.Internal.MonoMaybe s)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Validate.Internal.ValidateT e m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Validate.Internal.ValidateT e m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Validate.Internal.ValidateT e)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Validate.Internal.ValidateT e m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Control.Monad.Validate.Internal.ValidateT e m)
instance Control.Monad.Trans.Control.MonadTransControl (Control.Monad.Validate.Internal.ValidateT e)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Validate.Internal.ValidateT e m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Validate.Internal.ValidateT a m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Validate.Internal.ValidateT e m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Validate.Internal.ValidateT e m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Validate.Internal.ValidateT e m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Validate.Internal.ValidateT e m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Control.Monad.Validate.Internal.ValidateT e m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Control.Monad.Validate.Internal.ValidateT e m)
instance (GHC.Base.Monad m, GHC.Base.Semigroup e) => Control.Monad.Validate.Class.MonadValidate e (Control.Monad.Validate.Internal.ValidateT e m)


-- | This module defines the <a>ValidateT</a> monad transformer and
--   <a>MonadValidate</a> typeclass. As the names imply, they are intended
--   to be used to write data validators, but they are general enough that
--   you may find other uses for them, too. For an overview of this
--   library’s functionality, see the documentation for <a>ValidateT</a>.
module Control.Monad.Validate

-- | <a>ValidateT</a> is a monad transformer for writing validations. Like
--   <a>ExceptT</a>, <a>ValidateT</a> is primarily concerned with the
--   production of errors, but it differs from <a>ExceptT</a> in that
--   <a>ValidateT</a> is designed not to necessarily halt on the first
--   error. Instead, it provides a mechanism for collecting many warnings
--   or errors, ideally as many as possible, before failing. In that sense,
--   <a>ValidateT</a> is also somewhat like <a>WriterT</a>, but it is not
--   <i>just</i> a combination of <a>ExceptT</a> and <a>WriterT</a>.
--   Specifically, it differs in the following two respects:
--   
--   <ol>
--   <li><a>ValidateT</a> automatically collects errors from all branches
--   of an <a>Applicative</a> expression, making it possible to write code
--   in the same style that one would use with <a>ExceptT</a> and
--   automatically get additional information for free. (This is especially
--   true when used in combination with the <tt>ApplicativeDo</tt> language
--   extension.)</li>
--   <li><a>ValidateT</a> provides error signaling operators, <a>refute</a>
--   and <a>dispute</a>, which are similar to <a>throwError</a> and
--   <a>tell</a>, respectively. However, both operators combine raised
--   errors into a single value (using an arbitrary <a>Semigroup</a>), so
--   the relative ordering of validation errors is properly respected. (Of
--   course, if the order doesn’t matter to you, you can choose to
--   accumulate errors into an unordered container.)</li>
--   </ol>
--   
--   <h2>An introduction to <a>ValidateT</a></h2>
--   
--   The first of the above two points is by far the most interesting
--   feature of <a>ValidateT</a>. Let’s make it more concrete with an
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> (<a>refute</a> ["bang"] <a>*&gt;</a> <a>refute</a> ["boom"])
--   <a>Left</a> ["bang", "boom"]
--   </pre>
--   
--   At first blush, the above example may lead you to believe that
--   <a>refute</a> is like <a>tell</a> from <a>WriterT</a>, but it is
--   actually more like <a>throwError</a>. Consider its type:
--   
--   <pre>
--   <a>refute</a> :: <a>MonadValidate</a> e m =&gt; e -&gt; m a
--   </pre>
--   
--   Note that, like <a>throwError</a>, <a>refute</a> is polymorphic in its
--   return type, which is to say it never returns. Indeed, if we introduce
--   a dependency on a computation that fails using <a>refute</a> via
--   <a>&gt;&gt;=</a>, the downstream computation will not be run:
--   
--   <pre>
--   &gt;&gt;&gt; let getString = <a>refute</a> ["bang"] <a>*&gt;</a> <a>pure</a> "boom"
--           useString a = <a>refute</a> [a]
--       in <a>runValidate</a> (getString <a>&gt;&gt;=</a> useString)
--   <a>Left</a> ["bang"]
--   </pre>
--   
--   This works because although the <a>Monad</a> instance for
--   <a>ValidateT</a> fails as soon as the first <a>refute</a> is executed
--   (as it must due to the way the second argument of <a>&gt;&gt;=</a>
--   depends on the result of its first argument), the <a>Applicative</a>
--   instance runs all branches of <a>&lt;*&gt;</a> and combines the errors
--   produced by all of them. When <tt>ApplicativeDo</tt> is enabled, this
--   can lead to some “magical” looking error reporting where validation
--   automatically continues on each sub-piece of a piece of data until it
--   absolutely cannot proceed any further. As an example, this package’s
--   test suite includes the following function:
--   
--   <pre>
--   validateQueryRequest :: (<a>MonadReader</a> Env m, <a>MonadValidate</a> [Error] m) =&gt; Value -&gt; m QueryRequest
--   validateQueryRequest req = withObject "request" req <a>$</a> o -&gt; do
--     qrAuth           &lt;- withKey o "auth_token" parseAuthToken
--     ~(qrTable, info) &lt;- withKey o "table" parseTableName
--     qrQuery          &lt;- withKey o "query" parseQuery
--     <a>for_</a> info <a>$</a> tableInfo -&gt; pushPath "query" <a>$</a>
--       validateQuery qrTable tableInfo (atIsAdmin qrAuth) qrQuery
--     <a>pure</a> QueryRequest { qrAuth, qrTable, qrQuery }
--   </pre>
--   
--   The above <tt>do</tt> block parses and validates some JSON, and it’s
--   written as straight line code, but with <tt>ApplicativeDo</tt> enabled
--   (along with the <tt>-foptimal-applicative-do</tt> option, which makes
--   GHC try a little harder), it still produces errors for all parts of
--   the input document at once:
--   
--   <pre>
--   &gt;&gt;&gt; <a>flip</a> <a>runReader</a> env <a>.</a> <a>runValidateT</a> <a>$</a> validateQueryRequest [aesonQQ|
--         { "auth_token": 123
--         , "table": { "name": "users" }
--         , "query": { "add":
--           [ { "lit": "42" }
--           , { "select": "points" } ]}
--         }|]
--   <a>Left</a> [ Error ["auth_token"] (JSONBadValue "string" (Number 123))
--        , Error ["table"] (JSONMissingKey "schema")
--        , Error ["query", "add", "lit"] (JSONBadValue "number" (String "42")) ]
--   </pre>
--   
--   The penultimate statement in the <tt>do</tt> block—the one with the
--   call to <tt>validateQuery</tt>—depends on several of the bindings
--   bound earlier in the same <tt>do</tt> block, namely <tt>qrAuth</tt>,
--   <tt>info</tt>, and <tt>qrQuery</tt>. Because of that,
--   <tt>validateQuery</tt> will not be executed so long as any of its
--   dependencies fail. As soon as they all succeed, their results will be
--   passed to <tt>validateQuery</tt> as usual, and validation will
--   continue.
--   
--   <h2>The full details</h2>
--   
--   Although <a>ValidateT</a> (with <tt>ApplicativeDo</tt>) may seem
--   magical, of course, it is not. As alluded to above, <a>ValidateT</a>
--   simply provides a <a>&lt;*&gt;</a> implementation that collects errors
--   produced by both arguments rather than short-circuiting as soon as the
--   first error is raised.
--   
--   However, that explanation alone may raise some additional questions.
--   What about the monad laws? When <a>ValidateT</a> is used in a monad
--   transformer stack, what happens to side effects? And what are
--   <a>ValidateT</a>’s performance characteristics? The remainder of this
--   section discusses those topics.
--   
--   <h3><a>ValidateT</a> and the <a>Monad</a> laws</h3>
--   
--   <a>ValidateT</a>’s <a>Applicative</a> and <a>Monad</a> instances do
--   not conform to a strict interpretation of the <a>Monad</a> laws, which
--   dictate that <a>&lt;*&gt;</a> must be equivalent to <a>ap</a>. For
--   <a>ValidateT</a>, this is not true if we consider “equivalent” to mean
--   <a>==</a>. However, if we accept a slightly weaker notion of
--   equivalence, we can satisfy the laws. Specifically, we may use the
--   definition that some <a>Validate</a> action <tt>a</tt> is equivalent
--   to another action <tt>b</tt> iff
--   
--   <ul>
--   <li>if <tt><a>runValidate</a> a</tt> produces <tt><a>Right</a> x</tt>,
--   then <tt><a>runValidate</a> b</tt> must produce <tt><a>Right</a>
--   y</tt> where <tt>x <a>==</a> y</tt> (and <a>==</a> is the usual
--   Haskell <a>==</a>),</li>
--   <li>and if <tt><a>runValidate</a> a</tt> produces <tt><a>Left</a>
--   x</tt>, then <tt><a>runValidate</a> b</tt> must produce
--   <tt><a>Left</a> y</tt> (but <tt>x</tt> and <tt>y</tt> may be
--   unrelated).</li>
--   </ul>
--   
--   In other words, our definition of equivalence is like <a>==</a>,
--   except that we make no guarantees about the <i>contents</i> of an
--   error should one occur. However, we <i>do</i> guarantee that replacing
--   <a>&lt;*&gt;</a> with <a>ap</a> or vice versa will never change an
--   error to a success or a success to an error, nor will it change the
--   value of a successful result in any way. To put it another way,
--   <a>ValidateT</a> provides “best effort” error reporting: it will never
--   return fewer errors than an equivalent use of <a>ExceptT</a>, but it
--   might return more.
--   
--   <h3>Using <a>ValidateT</a> with other monad transformers</h3>
--   
--   <a>ValidateT</a> is a valid, lawful, generally well-behaved monad
--   transformer, and it is safe to use within a larger monad transformer
--   stack. Instances for the most common <tt>mtl</tt>-style typeclasses
--   are provided. <b>However</b>, be warned: many common monad
--   transformers do not have sufficiently order-independent
--   <a>Applicative</a> instances for <a>ValidateT</a>’s <a>Applicative</a>
--   instance to actually collect errors from multiple branches of a
--   computation.
--   
--   To understand why that might be, consider that <a>StateT</a> must
--   enforce a left-to-right evaluation order for <a>&lt;*&gt;</a> in order
--   to thread the state through the computation. If the <tt>a</tt> action
--   in an expression <tt>a <a>&lt;*&gt;</a> b</tt> fails, then it is
--   simply not possible to run <tt>b</tt> since <tt>b</tt> may still
--   depend on the state that would have been produced by <tt>a</tt>.
--   Similarly, <a>ExceptT</a> enforces a left-to-right evaluation because
--   it aborts a computation as soon as an error is thrown. Using
--   <a>ValidateT</a> with these kinds of monad transformers will cause it
--   to effectively degrade to <a>WriterT</a> over <a>ExceptT</a> since it
--   will not be able to gather any errors produced by <a>refute</a> beyond
--   the first one.
--   
--   However, even that isn’t the whole story, since the relative order of
--   monads in a monad transformer stack can affect things further. For
--   example, while the <a>StateT</a> monad transformer enforces
--   left-to-right evaluation order, it only does this for the monad
--   <i>underneath</i> it, so although <tt><a>StateT</a> s
--   (<a>ValidateT</a> e)</tt> will not be able to collect multiple errors,
--   <tt><a>ValidateT</a> e (<a>State</a> s)</tt> will. Note, however, that
--   those two types differ in other ways, too—running each to completion
--   results in different types:
--   
--   <pre>
--   <a>runState</a> (<a>runValidateT</a> m) s :: (<a>Either</a> e a, s)
--   <a>runValidate</a> (<a>runStateT</a> m s) :: <a>Either</a> e (a, s)
--   </pre>
--   
--   That kind of difference is generally true when using monad
--   transformers—the two combinations of <a>ExceptT</a> and <a>StateT</a>
--   have the same types as above, for example—but because <a>ValidateT</a>
--   needs to be on top of certain transformers for it to be useful,
--   combining <a>ValidateT</a> with certain transformers may be of little
--   practical use.
--   
--   One way to identify which monad transformers are uncooperative in the
--   aforementioned way is to look at the constraints included in the
--   context of the transformer’s <a>Applicative</a> instance. Transformers
--   like <a>StateT</a> have instances of the shape
--   
--   <pre>
--   instance <a>Monad</a> m =&gt; <a>Applicative</a> (<a>StateT</a> s m)
--   </pre>
--   
--   which notably require <a>Monad</a> instances just to implement
--   <a>Applicative</a>! However, this is not always sufficient for
--   distinguishing which functions or instances use <a>&lt;*&gt;</a> and
--   which use <a>&gt;&gt;=</a>, especially since many older libraries
--   (which predate <a>Applicative</a>) may include <a>Monad</a> contraints
--   even when they only use features of <a>Applicative</a>. The only way
--   to be certain is to examine the implementation (or conservatively
--   write code that is explicitly restricted to <a>Applicative</a>).
--   
--   (As it happens, <a>ValidateT</a>’s <a>Applicative</a> is actually one
--   such “uncooperative” instance itself: it has a <a>Monad</a> constraint
--   in its context. It is possible to write an implementation of
--   <a>ValidateT</a> without that constraint, but its <a>&lt;*&gt;</a>
--   would necessarily leak space in the same way <a>WriterT</a>’s
--   <a>&gt;&gt;=</a> leaks space. If you have a reason to want the less
--   efficient but more permissive variant, please let the author of this
--   library know, as she would probably find it interesting.)
--   
--   <h2>Performance characteristics of <a>ValidateT</a></h2>
--   
--   Although the interface to <a>ValidateT</a> is minimal, there are
--   surprisingly many different ways to implement it, each with its own
--   set of performance tradeoffs. Here is a quick summary of the choices
--   <a>ValidateT</a> makes:
--   
--   <ol>
--   <li><a>ValidateT</a> is <b>strict</b> in the set of errors it
--   accumulates, which is to say it reduces them to weak head normal form
--   (WHNF) via <a>seq</a> immediately upon any call to <a>refute</a> or
--   <a>dispute</a>.</li>
--   <li>Furthermore, all of <a>ValidateT</a>’s operations, including
--   <a>&lt;*&gt;</a>, operate in <b>constant space</b>. This means, for
--   example, that evaluating <tt><a>sequence_</a> xs</tt> will consume
--   constant space regardless of the size of <tt>xs</tt>, not counting any
--   space consumed purely due to the relevant <a>Foldable</a> instance’s
--   traversal of <tt>xs</tt>.</li>
--   <li>Finally, <a>ValidateT</a> accumulates errors in a
--   <b>left-associative</b> manner, which is to say that any uses of
--   <a>refute</a> or <a>dispute</a> combine the existing set of errors,
--   <tt>e</tt>, with the added set of errors, <tt>e'</tt>, via the
--   expression <tt>e <a>&lt;&gt;</a> e'</tt>.</li>
--   </ol>
--   
--   A good rule of thumb is that <a>ValidateT</a> has similar performance
--   characteristics to <tt><a>foldl'</a> (<a>&lt;&gt;</a>)</tt>, while
--   types like <tt>Validation</tt> from the <tt>either</tt> package tend
--   to have similar performance characteristics to <tt><a>foldr</a>
--   (<a>&lt;&gt;</a>)</tt>. That decision has both significant advantages
--   and significant disadvantages; the following subsections elaborate
--   further.
--   
--   <h3><a>&lt;*&gt;</a> takes constant space</h3>
--   
--   Great care has been taken in the implementation of <a>&lt;*&gt;</a> to
--   ensure it does not leak space. Notably, the same <i>cannot</i> be said
--   for many existing implementations of similar concepts. For example,
--   you will find that executing the expression
--   
--   <pre>
--   let m () = <a>pure</a> () <a>*&gt;</a> m () in m ()
--   </pre>
--   
--   may continuously allocate memory until it is exhausted for types such
--   as <tt>Validation</tt> (from the <tt>either</tt> package), but
--   <a>ValidateT</a> will execute it in constant space. This point may
--   seem silly, since the above definition of <tt>m ()</tt> will never do
--   anything useful, anyway, but the same point also applies to operations
--   like <a>sequence_</a>.
--   
--   In practice, this issue matters far less for types like
--   <tt>Validation</tt> than it does for <a>ValidateT</a>, as
--   <tt>Validation</tt> and its cousins don’t have a <a>Monad</a> instance
--   and do not generally experience the same usage patterns. (The
--   additional laziness they are capable of can sometimes even avoid the
--   space leak altogether.) However, it can be relevant more often for
--   <a>ValidateT</a>, so this implementation makes choices to avoid the
--   potential for the leak altogether.
--   
--   <h3>Errors are accumulated using strict, left-associated
--   <a>&lt;&gt;</a></h3>
--   
--   A major consequence of the decision to both strictly accumulate state
--   and maintain constant space is that <a>ValidateT</a>’s internal
--   applications of <a>&lt;&gt;</a> to combine errors are naturally strict
--   and left-associated, not lazy and right-associated like they are for
--   types like <tt>Validation</tt>. If the number of errors your
--   validation generates is small, this difference is irrelevant, but if
--   it is large, the difference in association can prove disastrous if the
--   <a>Semigroup</a> you choose to accumulate errors in is <tt>[a]</tt>!
--   
--   To make it painfully explicit why using <tt>[a]</tt> can come back to
--   bite you, consider that each time <a>ValidateT</a> executes
--   <tt><a>refute</a> e'</tt>, given some existing collection of errors
--   <tt>e</tt>, it (strictly) evalutes <tt>e <a>&lt;&gt;</a> e'</tt> to
--   obtain a new collection of errors. Now consider the implications of
--   that if <tt>e</tt> is a ten thousand element list: <a>&lt;&gt;</a>
--   will have to traverse <i>all</i> ten thousand elements and reallocate
--   a fresh cons cell for every single one in order to build the new list,
--   even if just one element is being appended to the end! Unfortunately,
--   the ubiquitous, built-in <tt>[a]</tt> type is clearly an exceptionally
--   poor choice for this pattern of accumulation.
--   
--   Fortunately, the solution is quite simple: use a different data
--   structure. If order doesn’t matter, use a <tt>Set</tt> or
--   <tt>HashSet</tt>. If it does, but either LIFO consumption of the data
--   is okay or you are okay with paying to reverse the data once after
--   collecting the errors, use <tt><a>Dual</a> [a]</tt> to accumulate
--   elements in an efficient manner. If neither is true, use a data
--   structure like <tt>Seq</tt> that provides an efficient implementation
--   of a functional queue. You can always convert back to a plain list at
--   the end once you’re done, if you have to.
data ValidateT e m a

-- | Runs a <a>ValidateT</a> computation, returning the errors raised by
--   <a>refute</a> or <a>dispute</a> if any, otherwise returning the
--   computation’s result.
runValidateT :: forall e m a. Functor m => ValidateT e m a -> m (Either e a)

-- | Runs a <a>ValidateT</a> computation, returning the errors on failure
--   or <a>mempty</a> on success. The computation’s result, if any, is
--   discarded.
--   
--   <pre>
--   &gt;&gt;&gt; <a>execValidate</a> (<a>refute</a> ["bang"])
--   ["bang"]
--   &gt;&gt;&gt; <a>execValidate</a> @[] (<a>pure</a> 42)
--   []
--   </pre>
execValidateT :: forall e m a. (Monoid e, Functor m) => ValidateT e m a -> m e

-- | Runs a <a>ValidateT</a> transformer by interpreting it in an
--   underlying transformer with a <a>MonadValidate</a> instance. That
--   might seem like a strange thing to do, but it can be useful in
--   combination with <a>mapErrors</a> to locally alter the error type in a
--   larger <a>ValidateT</a> computation. For example:
--   
--   <pre>
--   throwsIntegers :: <a>MonadValidate</a> [<a>Integer</a>] m =&gt; m ()
--   throwsIntegers = <a>dispute</a> [42]
--   
--   throwsBools :: <a>MonadValidate</a> [<a>Bool</a>] m =&gt; m ()
--   throwsBools = <a>dispute</a> [<a>False</a>]
--   
--   throwsBoth :: <a>MonadValidate</a> [<a>Either</a> <a>Integer</a> <a>Bool</a>] m =&gt; m ()
--   throwsBoth = do
--     <a>embedValidateT</a> <a>$</a> <a>mapErrors</a> (<a>map</a> <a>Left</a>) throwsIntegers
--     <a>embedValidateT</a> <a>$</a> <a>mapErrors</a> (<a>map</a> <a>Right</a>) throwsBools
--   
--   &gt;&gt;&gt; <a>runValidate</a> throwsBoth
--   <a>Left</a> [<a>Left</a> 42, <a>Right</a> False]
--   </pre>
embedValidateT :: forall e m a. MonadValidate e m => ValidateT e m a -> m a

-- | Applies a function to all validation errors produced by a
--   <a>ValidateT</a> computation.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> <a>$</a> <a>mapErrors</a> (<a>map</a> <a>show</a>) (<a>refute</a> [11, 42])
--   <a>Left</a> ["11", "42"]
--   </pre>
mapErrors :: forall e1 e2 m a. (Monad m, Semigroup e2) => (e1 -> e2) -> ValidateT e1 m a -> ValidateT e2 m a

-- | The class of validation monads, intended to be used to validate data
--   structures while collecting errors along the way. In a sense,
--   <a>MonadValidate</a> is like a combination of <a>MonadError</a> and
--   <a>MonadWriter</a>, but it isn’t entirely like either. The two
--   essential differences are:
--   
--   <ol>
--   <li>Unlike <a>throwError</a>, raising an error using <a>refute</a>
--   does not always abort the entire computation—it may only abort a local
--   part of it.</li>
--   <li>Unlike <a>tell</a>, raising an error using <a>dispute</a> still
--   causes the computation to globally fail, it just doesn’t affect local
--   execution.</li>
--   </ol>
--   
--   Instances must obey the following law:
--   
--   <pre>
--   <a>dispute</a> ≡ <a>void</a> <a>.</a> <a>tolerate</a> <a>.</a> <a>refute</a>
--   </pre>
--   
--   For a more thorough explanation, with examples, see the documentation
--   for <a>ValidateT</a>.
class (Monad m, Semigroup e) => MonadValidate e m | m -> e

-- | Raises a fatal validation error. Aborts the current branch of the
--   validation (i.e. does not return).
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> (<a>refute</a> ["boom"] <a>&gt;&gt;</a> <a>refute</a> ["bang"])
--   <a>Left</a> ["boom"]
--   </pre>
refute :: MonadValidate e m => e -> m a

-- | Raises a non-fatal validation error. The overall validation fails, and
--   the error is recorded, but validation continues in an attempt to try
--   and discover more errors.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> (<a>dispute</a> ["boom"] <a>&gt;&gt;</a> <a>dispute</a> ["bang"])
--   <a>Left</a> ["boom", "bang"]
--   </pre>
--   
--   If not explicitly implemented, the default implementation is
--   <tt><a>void</a> <a>.</a> <a>tolerate</a> <a>.</a> <a>refute</a></tt>
--   (which must behave equivalently by law), but it is sometimes possible
--   to provide a more efficient implementation.
dispute :: MonadValidate e m => e -> m ()

-- | <tt><a>tolerate</a> m</tt> behaves like <tt>m</tt>, except that any
--   fatal errors raised by <a>refute</a> are altered to non-fatal errors
--   that return <a>Nothing</a>. This allows <tt>m</tt>’s result to be used
--   for further validation if it succeeds without preventing further
--   validation from occurring upon failure.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> (<a>tolerate</a> (<a>refute</a> ["boom"]) <a>&gt;&gt;</a> <a>refute</a> ["bang"])
--   <a>Left</a> ["boom", "bang"]
--   </pre>
tolerate :: MonadValidate e m => m a -> m (Maybe a)

-- | Runs an <a>ExceptT</a> computation, and if it raised an error,
--   re-raises it using <a>refute</a>. This effectively converts a
--   computation that uses <a>ExceptT</a> (or <a>MonadError</a>) into one
--   that uses <a>MonadValidate</a>.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> <a>$</a> <a>exceptToValidate</a> (<a>pure</a> 42)
--   <a>Right</a> 42
--   &gt;&gt;&gt; <a>runValidate</a> <a>$</a> <a>exceptToValidate</a> (<a>throwError</a> ["boom"])
--   <a>Left</a> "boom"
--   </pre>
exceptToValidate :: forall e m a. MonadValidate e m => ExceptT e m a -> m a

-- | Like <a>exceptToValidate</a>, but additionally accepts a function,
--   which is applied to the error raised by <a>ExceptT</a> before passing
--   it to <a>refute</a>. This can be useful if the original error type is
--   not a <a>Semigroup</a>.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runValidate</a> <a>$</a> <a>exceptToValidateWith</a> (:[]) (<a>pure</a> 42)
--   <a>Right</a> 42
--   &gt;&gt;&gt; <a>runValidate</a> <a>$</a> <a>exceptToValidateWith</a> (:[]) (<a>throwError</a> "boom")
--   <a>Left</a> ["boom"]
--   </pre>
exceptToValidateWith :: forall e1 e2 m a. MonadValidate e2 m => (e1 -> e2) -> ExceptT e1 m a -> m a

-- | Runs a <a>ValidateT</a> computation, and if it raised any errors,
--   re-raises them using <a>throwError</a>. This effectively converts a
--   computation that uses <a>ValidateT</a> (or <a>MonadValidate</a>) into
--   one that uses <a>MonadError</a>.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runExcept</a> <a>$</a> <a>validateToError</a> (<a>pure</a> 42)
--   <a>Right</a> 42
--   &gt;&gt;&gt; <a>runExcept</a> <a>$</a> <a>validateToError</a> (<a>refute</a> ["boom"] *&gt; <a>refute</a> ["bang"])
--   <a>Left</a> ["boom", "bang"]
--   </pre>
validateToError :: forall e m a. MonadError e m => ValidateT e m a -> m a

-- | Like <a>validateToError</a>, but additionally accepts a function,
--   which is applied to the errors raised by <a>ValidateT</a> before
--   passing them to <a>throwError</a>. This can be useful to concatenate
--   multiple errors into one.
--   
--   <pre>
--   &gt;&gt;&gt; <a>runExcept</a> <a>$</a> <a>validateToErrorWith</a> <a>mconcat</a> (<a>pure</a> 42)
--   <a>Right</a> 42
--   &gt;&gt;&gt; <a>runExcept</a> <a>$</a> <a>validateToErrorWith</a> <a>mconcat</a> (<a>refute</a> ["boom"] *&gt; <a>refute</a> ["bang"])
--   <a>Left</a> "boombang"
--   </pre>
validateToErrorWith :: forall e1 e2 m a. MonadError e2 m => (e1 -> e2) -> ValidateT e1 m a -> m a

-- | <a>ValidateT</a> specialized to the <a>Identity</a> base monad. See
--   <a>ValidateT</a> for usage information.
type Validate e = ValidateT e Identity

-- | See <a>runValidateT</a>.
runValidate :: forall e a. Validate e a -> Either e a

-- | See <a>execValidateT</a>.
execValidate :: forall e a. Monoid e => Validate e a -> e
