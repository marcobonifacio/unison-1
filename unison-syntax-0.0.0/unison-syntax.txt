-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-syntax
@version 0.0.0

module Unison.Lexer.Pos
data Pos
Pos :: {-# UNPACK #-} !Line -> {-# UNPACK #-} !Column -> Pos
type Line = Int
type Column = Int
line :: Pos -> Line
column :: Pos -> Column
instance GHC.Classes.Ord Unison.Lexer.Pos.Pos
instance GHC.Classes.Eq Unison.Lexer.Pos.Pos
instance GHC.Show.Show Unison.Lexer.Pos.Pos
instance GHC.Base.Semigroup Unison.Lexer.Pos.Pos
instance GHC.Base.Monoid Unison.Lexer.Pos.Pos

module Unison.Parser.Ann
data Ann
Intrinsic :: Ann
External :: Ann
GeneratedFrom :: Ann -> Ann
Ann :: Pos -> Pos -> Ann
[$sel:start:Intrinsic] :: Ann -> Pos
[$sel:end:Intrinsic] :: Ann -> Pos
startingLine :: Ann -> Maybe Line

-- | Checks whether an annotation contains a given position i.e. pos ∈
--   [start, end)
--   
--   <pre>
--   &gt;&gt;&gt; Intrinsic `contains` L.Pos 1 1
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; External `contains` L.Pos 1 1
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 0 0) (L.Pos 0 10) `contains` L.Pos 0 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 0 0) (L.Pos 0 10) `contains` L.Pos 0 10
--   False
--   </pre>
contains :: Ann -> Pos -> Bool

-- | Checks whether an annotation contains another annotation.
--   
--   i.e. pos ∈ [start, end)
--   
--   <pre>
--   &gt;&gt;&gt; Intrinsic `encompasses` Ann (L.Pos 1 1) (L.Pos 2 1)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; External `encompasses` Ann (L.Pos 1 1) (L.Pos 2 1)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 0 0) (L.Pos 0 10) `encompasses` Ann (L.Pos 0 1) (L.Pos 0 5)
--   Just True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 1 0) (L.Pos 1 10) `encompasses` Ann (L.Pos 0 0) (L.Pos 2 0)
--   Just False
--   </pre>
encompasses :: Ann -> Ann -> Maybe Bool
instance GHC.Show.Show Unison.Parser.Ann.Ann
instance GHC.Classes.Ord Unison.Parser.Ann.Ann
instance GHC.Classes.Eq Unison.Parser.Ann.Ann
instance GHC.Base.Monoid Unison.Parser.Ann.Ann
instance GHC.Base.Semigroup Unison.Parser.Ann.Ann

module Unison.Syntax.Lexer.Token
data Token a
Token :: a -> !Pos -> !Pos -> Token a
[$sel:payload:Token] :: Token a -> a
[$sel:start:Token] :: Token a -> !Pos
[$sel:end:Token] :: Token a -> !Pos
tokenP :: (Ord e, TraversableStream s) => ParsecT e s m a -> ParsecT e s m (Token a)
posP :: (Ord e, TraversableStream s) => ParsecT e s m Pos
instance Data.Traversable.Traversable Unison.Syntax.Lexer.Token.Token
instance Data.Foldable.Foldable Unison.Syntax.Lexer.Token.Token
instance GHC.Base.Functor Unison.Syntax.Lexer.Token.Token
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Lexer.Token.Token a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Lexer.Token.Token a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Lexer.Token.Token a)
instance GHC.Base.Applicative Unison.Syntax.Lexer.Token.Token
instance Text.Megaparsec.Error.ShowErrorComponent (Unison.Syntax.Lexer.Token.Token Data.Text.Internal.Text)

module Unison.Syntax.ReservedWords
keywords :: Set Text
typeModifiers :: Set Text
typeOrAbility :: Set Text
reservedOperators :: Set Text
delimiters :: Set Char


-- | Utilities related to the parsing and printing of name segments using
--   the default syntax.
module Unison.Syntax.NameSegment

-- | Convert a name segment to escaped text, for display purposes.
--   
--   <pre>
--   toEscapedText (unsafeFromText ".~") = "`.~`"
--   </pre>
toEscapedText :: NameSegment -> Text
toEscapedTextBuilder :: NameSegment -> Builder

-- | Parse text as a name segment.
--   
--   <pre>
--   parseText "foo" = Right (NameSegment "foo")
--   parseText ".~" = Left ...
--   parseText "`.~`" = Right (NameSegment ".~")
--   </pre>
parseText :: Text -> Either Text NameSegment

-- | Parse text as a name segment.
unsafeParseText :: Text -> NameSegment
isSymboly :: NameSegment -> Bool
data ParseErr
ReservedOperator :: !Text -> ParseErr
ReservedWord :: !Text -> ParseErr
renderParseErr :: ParseErr -> Text
segmentP :: Monad m => ParsecT (Token ParseErr) [Char] m NameSegment

-- | A symboly name segment parser, which consists only of symboly
--   characters.
--   
--   A symboly name segment can optionally be escaped by surrounding it
--   with backticks, which expands the list of allowed symbols to include
--   these three: . ( )
--   
--   Throws the parsed name segment as an error if it's unescaped and
--   reserved, e.g. "=".
symbolyP :: ParsecT (Token Text) [Char] m NameSegment

-- | A wordy name segment parser, which consists only of wordy characters.
--   
--   Throws the parsed name segment as an error if it's an unescaped
--   keyword, e.g. "match".
wordyP :: ParsecT (Token Text) [Char] m NameSegment
segmentStartChar :: Char -> Bool
symbolyIdChar :: Char -> Bool
wordyIdStartChar :: Char -> Bool
wordyIdChar :: Char -> Bool
instance GHC.Classes.Ord Unison.Syntax.NameSegment.ParseErr
instance GHC.Classes.Eq Unison.Syntax.NameSegment.ParseErr


-- | Utilities related to the parsing and printing of names using the
--   default syntax.
module Unison.Syntax.Name

-- | Parse a name from a string literal.
parseText :: Text -> Maybe Name

-- | Parse a name from a string literal.
parseTextEither :: Text -> Either Text Name

-- | Unsafely parse a name from a string literal.
unsafeParseText :: HasCallStack => Text -> Name

-- | Convert a name to a string representation.
toText :: Name -> Text

-- | Unsafely parse a name from a var, by first rendering the var as a
--   string.
--   
--   See <tt>unsafeFromText</tt>.
unsafeParseVar :: Var v => v -> Name

-- | Parse a name from a var, by first rendering the var as a string.
parseVar :: Var v => v -> Maybe Name

-- | Convert a name to a string representation, then parse that as a var.
toVar :: Var v => Name -> v

-- | A name parser.
nameP :: Monad m => ParsecT (Token ParseErr) [Char] m Name

-- | A relative name parser.
relativeNameP :: forall m. Monad m => ParsecT (Token ParseErr) [Char] m Name
isSymboly :: Name -> Bool


-- | Utilities related to the parsing and printing of short hashes using
--   the default syntax.
module Unison.Syntax.ShortHash

-- | A short hash parser.
--   
--   Throws the parsed hash as an error if it's invalid.
shortHashP :: ParsecT (Token Text) [Char] m ShortHash


-- | Syntax-related combinators for HashQualified' (to/from string types).
module Unison.Syntax.HashQualified'
parseText :: Text -> Maybe (HashQualified Name)
unsafeParseText :: HasCallStack => Text -> HashQualified Name
toText :: HashQualified Name -> Text

-- | A hash-qualified parser.
hashQualifiedP :: Monad m => ParsecT (Token Text) [Char] m name -> ParsecT (Token Text) [Char] m (HashQualified name)
instance Unison.Name.Parse Data.Text.Internal.Text (Unison.HashQualified'.HashQualified Unison.Name.Internal.Name)

module Unison.Syntax.Lexer
data Token a
Token :: a -> !Pos -> !Pos -> Token a
[$sel:payload:Token] :: Token a -> a
[$sel:start:Token] :: Token a -> !Pos
[$sel:end:Token] :: Token a -> !Pos
type Line = Int
type Column = Int
data Err
InvalidWordyId :: String -> Err
ReservedWordyId :: String -> Err
InvalidSymbolyId :: String -> Err
ReservedSymbolyId :: String -> Err
InvalidShortHash :: String -> Err
InvalidBytesLiteral :: String -> Err
InvalidHexLiteral :: Err
InvalidOctalLiteral :: Err
Both :: Err -> Err -> Err
MissingFractional :: String -> Err
MissingExponent :: String -> Err
UnknownLexeme :: Err
TextLiteralMissingClosingQuote :: String -> Err
InvalidEscapeCharacter :: Char -> Err
LayoutError :: Err
CloseWithoutMatchingOpen :: String -> String -> Err
UnexpectedDelimiter :: String -> Err
UnexpectedTokens :: String -> Err
data Pos
Pos :: {-# UNPACK #-} !Line -> {-# UNPACK #-} !Column -> Pos
data Lexeme
Open :: String -> Lexeme
Semi :: IsVirtual -> Lexeme
Close :: Lexeme
Reserved :: String -> Lexeme
Textual :: String -> Lexeme
Character :: Char -> Lexeme
WordyId :: HashQualified Name -> Lexeme
SymbolyId :: HashQualified Name -> Lexeme
Blank :: String -> Lexeme
Numeric :: String -> Lexeme
Bytes :: Bytes -> Lexeme
Hash :: ShortHash -> Lexeme
Err :: Err -> Lexeme
lexer :: String -> String -> [Token Lexeme]
line :: Pos -> Line
column :: Pos -> Column
escapeChars :: [(Char, Char)]
debugFileLex :: String -> IO ()
debugLex' :: String -> String
debugLex'' :: [Token Lexeme] -> String
debugLex''' :: String -> String -> String
showEscapeChar :: Char -> Maybe Char
touches :: Token a -> Token b -> Bool
wordyIdChar :: Char -> Bool
wordyIdStartChar :: Char -> Bool
symbolyIdChar :: Char -> Bool
formatTrivialError :: Set String -> Set String -> [Char]
displayLexeme :: Lexeme -> String
instance GHC.Show.Show Unison.Syntax.Lexer.ParsingEnv
instance GHC.Show.Show Unison.Syntax.Lexer.Err
instance GHC.Classes.Ord Unison.Syntax.Lexer.Err
instance GHC.Classes.Eq Unison.Syntax.Lexer.Err
instance GHC.Classes.Ord Unison.Syntax.Lexer.Lexeme
instance GHC.Show.Show Unison.Syntax.Lexer.Lexeme
instance GHC.Classes.Eq Unison.Syntax.Lexer.Lexeme
instance Data.Traversable.Traversable Unison.Syntax.Lexer.T
instance Data.Foldable.Foldable Unison.Syntax.Lexer.T
instance GHC.Base.Functor Unison.Syntax.Lexer.T
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Lexer.T a)
instance Text.Megaparsec.Stream.VisualStream [Unison.Syntax.Lexer.Token.Token Unison.Syntax.Lexer.Lexeme]
instance Text.Megaparsec.Error.ShowErrorComponent (Unison.Syntax.Lexer.Token.Token Unison.Syntax.Lexer.Err)


-- | Syntax-related combinators for HashQualified (to/from string types).
module Unison.Syntax.HashQualified
parseText :: Text -> Maybe (HashQualified Name)
parseTextWith :: Parsec (Token Text) [Char] name -> Text -> Maybe (HashQualified name)
unsafeParseText :: Text -> HashQualified Name
toText :: HashQualified Name -> Text
unsafeFromVar :: Var v => v -> HashQualified Name
toVar :: Var v => HashQualified Name -> v

-- | A hash-qualified parser.
hashQualifiedP :: Monad m => ParsecT (Token Text) [Char] m name -> ParsecT (Token Text) [Char] m (HashQualified name)
instance Unison.Name.Parse Data.Text.Internal.Text (Unison.HashQualified.HashQualified Unison.Name.Internal.Name)

module Unison.Syntax.Var
namespaced :: Var v => NonEmpty v -> v

module Unison.UnisonFile.Error
data Error v a
UnknownType :: v -> a -> Error v a
DupDataAndAbility :: v -> a -> a -> Error v a
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.UnisonFile.Error.Error v a)
instance (GHC.Classes.Ord v, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.UnisonFile.Error.Error v a)
instance (GHC.Classes.Eq v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.UnisonFile.Error.Error v a)

module Unison.Syntax.Parser
class Annotated a
ann :: Annotated a => a -> Ann
type Err v = ParseError Input (Error v)
data Error v
SignatureNeedsAccompanyingBody :: Token v -> Error v
DisallowedAbsoluteName :: Token Name -> Error v
EmptyBlock :: Token String -> Error v
UnknownAbilityConstructor :: Token (HashQualified Name) -> Set ConstructorReference -> Error v
UnknownDataConstructor :: Token (HashQualified Name) -> Set ConstructorReference -> Error v
UnknownTerm :: Token (HashQualified Name) -> Set Referent -> Error v
UnknownType :: Token (HashQualified Name) -> Set Reference -> Error v
UnknownId :: Token (HashQualified Name) -> Set Referent -> Set Reference -> Error v
ExpectedBlockOpen :: String -> Token Lexeme -> Error v
EmptyMatch :: Token () -> Error v
EmptyWatch :: Ann -> Error v
UseInvalidPrefixSuffix :: Either (Token Name) (Token Name) -> Maybe [Token Name] -> Error v
UseEmpty :: Token String -> Error v
DidntExpectExpression :: Token Lexeme -> Maybe (Token Lexeme) -> Error v
TypeDeclarationErrors :: [Error v Ann] -> Error v
MissingTypeModifier :: Token String -> Token v -> Error v
ResolutionFailures :: [ResolutionFailure v Ann] -> Error v
DuplicateTypeNames :: [(v, [Ann])] -> Error v
DuplicateTermNames :: [(v, [Ann])] -> Error v
PatternArityMismatch :: Int -> Int -> Ann -> Error v
FloatPattern :: Ann -> Error v
data Input
type P v m = ParsecT (Error v) Input (ReaderT (ParsingEnv m) m)
data ParsingEnv (m :: Type -> Type)
ParsingEnv :: UniqueName -> (Name -> m (Maybe Text)) -> Names -> ParsingEnv (m :: Type -> Type)
[$sel:uniqueNames:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> UniqueName

-- | Return a GUID to reuse for a unique type of the given name, if any.
--   
--   This callback is called for every `unique type` declaration that does
--   not explicitly specify a GUID.
--   
--   The name (e.g. <tt>Foo</tt> in `unique type Foo`) is passed in, and if
--   the function returns a Just, that GUID is used; otherwise, a random
--   one is generated from <a>$sel:uniqueNames:ParsingEnv</a>.
[$sel:uniqueTypeGuid:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> Name -> m (Maybe Text)
[$sel:names:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> Names
data UniqueName
anyToken :: Ord v => P v m (Token Lexeme)
blank :: Ord v => P v m (Token String)
bytesToken :: Ord v => P v m (Token Bytes)
chainl1 :: Ord v => P v m a -> P v m (a -> a -> a) -> P v m a
chainr1 :: Ord v => P v m a -> P v m (a -> a -> a) -> P v m a
character :: Ord v => P v m (Token Char)
closeBlock :: Ord v => P v m (Token ())
failCommitted :: Ord v => Error v -> P v m x
failureIf :: Ord v => P v m (P v m b) -> P v m a -> P v m b
hqInfixId :: Ord v => P v m (Token (HashQualified Name))
hqPrefixId :: Ord v => P v m (Token (HashQualified Name))
importSymbolyId :: Ord v => P v m (Token Name)
importWordyId :: Ord v => P v m (Token Name)
label :: (Ord v, Show a) => String -> P v m a -> P v m a
matchToken :: Ord v => Lexeme -> P v m (Token Lexeme)
mkAnn :: (Annotated a, Annotated b) => a -> b -> Ann
numeric :: Ord v => P v m (Token String)
openBlock :: Ord v => P v m (Token String)
openBlockWith :: Ord v => String -> P v m (Token ())
peekAny :: Ord v => P v m (Token Lexeme)
positionalVar :: (Annotated a, Var v) => a -> v -> v
prefixDefinitionName :: Var v => P v m (Token v)
prefixTermName :: Var v => P v m (Token v)
queryToken :: Ord v => (Lexeme -> Maybe a) -> P v m (Token a)
reserved :: Ord v => String -> P v m (Token String)
root :: Ord v => P v m a -> P v m a
rootFile :: Ord v => P v m a -> P v m a
run' :: (Monad m, Ord v) => P v m a -> String -> String -> ParsingEnv m -> m (Either (Err v) a)
run :: (Monad m, Ord v) => P v m a -> String -> ParsingEnv m -> m (Either (Err v) a)
semi :: Ord v => P v m (Token ())
seq :: Ord v => (Ann -> [a] -> a) -> P v m a -> P v m a
sepBy :: Ord v => P v m a -> P v m b -> P v m [b]
sepBy1 :: Ord v => P v m a -> P v m b -> P v m [b]
string :: Ord v => P v m (Token Text)
symbolyDefinitionName :: Var v => P v m (Token v)
tok :: (Ann -> a -> b) -> Token a -> b
tokenToPair :: Token a -> (Ann, a)

-- | Parses a tuple of <tt>a</tt>s, or a single parenthesized <tt>a</tt>
--   
--   returns the result of combining elements with <tt>pair</tt>, alongside
--   the annotation containing the full parenthesized expression.
tupleOrParenthesized :: Ord v => P v m a -> (Ann -> a) -> (a -> a -> a) -> P v m (Ann, a)
uniqueBase32Namegen :: forall gen. DRG gen => gen -> UniqueName
uniqueName :: (Monad m, Var v) => Int -> P v m Text
wordyDefinitionName :: Var v => P v m (Token v)
wordyPatternName :: Var v => P v m (Token v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Syntax.Parser.Error v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Syntax.Parser.Error v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Syntax.Parser.Error v)
instance Text.Megaparsec.Stream.VisualStream Unison.Syntax.Parser.Input
instance Text.Megaparsec.Stream.Stream Unison.Syntax.Parser.Input
instance GHC.Show.Show Unison.Syntax.Parser.Input
instance GHC.Classes.Ord Unison.Syntax.Parser.Input
instance GHC.Classes.Eq Unison.Syntax.Parser.Input
instance Unison.Syntax.Parser.Annotated Unison.Parser.Ann.Ann
instance Unison.Syntax.Parser.Annotated (Unison.Syntax.Lexer.Token.Token a)
instance Unison.Syntax.Parser.Annotated a => Unison.Syntax.Parser.Annotated (U.Core.ABT.Term f v a)
instance Unison.Syntax.Parser.Annotated a => Unison.Syntax.Parser.Annotated (Unison.Pattern.Pattern a)
instance Unison.Syntax.Parser.Annotated a => Unison.Syntax.Parser.Annotated [a]
instance (Unison.Syntax.Parser.Annotated a, Unison.Syntax.Parser.Annotated b) => Unison.Syntax.Parser.Annotated (Unison.Term.MatchCase a b)
instance GHC.Base.Semigroup Unison.Syntax.Parser.UniqueName
instance GHC.Base.Monoid Unison.Syntax.Parser.UniqueName
