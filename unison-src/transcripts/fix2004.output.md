
Here's the scenario that can produce bad empty namespace LCAs:

```deletes
of v4
j1: ... - v1 - v2 - v3 - v4 - v4a - v5 - v6 - v7
                                              /
                                  <empty> - v5a

                               adds of unrelated
j2: ... - v1 - v2 - v3 - v4 - x0 - x1 - x2 - x3
                                            /
                                <empty> - z1


```

So `j1` and `j2` have common history up through `v4`, then `j1` deletes some definitions while `j2` adds some definitions via shallow merges. These shallow merges then result in the LCA being the empty namespace rather than `v4`.

First, we create some common history before a fork:

```ucm
scratch/main> alias.term builtin.Nat.+ a.delete1

  Done.

scratch/main> alias.term builtin.Nat.* a.delete2

  Done.

scratch/main> alias.term builtin.Nat.drop a.delete3

  Done.

scratch/main> alias.type builtin.Nat a.Delete4

  Done.

```
Now we fork `a2` off of `a`. `a` continues on, deleting the terms it added previously and then adding one unrelated term via a merge with little history. It's this short history merge which will become a bad LCA of the empty namespace.

```ucm
scratch/main> fork a a2

  Done.

scratch/main> delete.term.verbose a.delete1

  Name changes:
  
    Original            Changes
    1. a.delete1     ‚îê  2. a.delete1 (removed)
    3. a2.delete1    ‚îÇ  
    4. builtin.Nat.+ ‚îò  
  
  Tip: You can use `undo` or `reflog` to undo this change.

scratch/main> delete.term.verbose a.delete2

  Name changes:
  
    Original            Changes
    1. a.delete2     ‚îê  2. a.delete2 (removed)
    3. a2.delete2    ‚îÇ  
    4. builtin.Nat.* ‚îò  
  
  Tip: You can use `undo` or `reflog` to undo this change.

scratch/main> delete.term.verbose a.delete3

  Name changes:
  
    Original               Changes
    1. a.delete3        ‚îê  2. a.delete3 (removed)
    3. a2.delete3       ‚îÇ  
    4. builtin.Nat.drop ‚îò  
  
  Tip: You can use `undo` or `reflog` to undo this change.

scratch/main> delete.type.verbose a.Delete4

  Name changes:
  
    Original          Changes
    1. a.Delete4   ‚îê  2. a.Delete4 (removed)
    3. a2.Delete4  ‚îÇ  
    4. builtin.Nat ‚îò  
  
  Tip: You can use `undo` or `reflog` to undo this change.

scratch/main> alias.term .builtin.Float.+ newbranchA.dontDelete

  ‚ö†Ô∏è
  
  I don't know about that term.

```

```ucm
scratch/main> fork a a2scratch/main> delete.term.verbose a.delete1scratch/main> delete.term.verbose a.delete2scratch/main> delete.term.verbose a.delete3scratch/main> delete.type.verbose a.Delete4scratch/main> alias.term .builtin.Float.+ newbranchA.dontDeletescratch/main> merge.old newbranchA a.a> find
```


üõë

The transcript failed due to an error in the stanza above. The error is:


  ‚ö†Ô∏è
  
  I don't know about that term.

