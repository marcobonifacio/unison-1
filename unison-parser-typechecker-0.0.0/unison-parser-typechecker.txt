-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-parser-typechecker
@version 0.0.0

module U.Codebase.Branch.Diff

-- | A tree of local diffs. Each node of the tree contains the definition
--   diffs at that path.
newtype TreeDiff m
TreeDiff :: Cofree (Compose (Map NameSegment) m) DefinitionDiffs -> TreeDiff m
[$sel:unTreeDiff:TreeDiff] :: TreeDiff m -> Cofree (Compose (Map NameSegment) m) DefinitionDiffs
hoistTreeDiff :: Functor m => (forall x. m x -> n x) -> TreeDiff m -> TreeDiff n

-- | A summary of a <a>TreeDiff</a>, containing all names added and
--   removed. Note that there isn't a clear notion of a name "changing"
--   since conflicts might muddy the notion by having multiple copies of
--   both the from and to names, so we just talk about adds and removals
--   instead.
data NameChanges
NameChanges :: [(Name, Referent)] -> [(Name, Referent)] -> [(Name, Reference)] -> [(Name, Reference)] -> NameChanges
[$sel:termNameAdds:NameChanges] :: NameChanges -> [(Name, Referent)]
[$sel:termNameRemovals:NameChanges] :: NameChanges -> [(Name, Referent)]
[$sel:typeNameAdds:NameChanges] :: NameChanges -> [(Name, Reference)]
[$sel:typeNameRemovals:NameChanges] :: NameChanges -> [(Name, Reference)]

-- | Represents the changes to definitions at a given path, not including
--   child paths.
--   
--   Note: doesn't yet include any info on patch diffs. Feel free to add
--   it.
data DefinitionDiffs
DefinitionDiffs :: Map NameSegment (Diff Referent) -> Map NameSegment (Diff Reference) -> DefinitionDiffs
[$sel:termDiffs:DefinitionDiffs] :: DefinitionDiffs -> Map NameSegment (Diff Referent)
[$sel:typeDiffs:DefinitionDiffs] :: DefinitionDiffs -> Map NameSegment (Diff Reference)
data Diff a
Diff :: Set a -> Set a -> Diff a
[$sel:adds:Diff] :: Diff a -> Set a
[$sel:removals:Diff] :: Diff a -> Set a

-- | A name-based diff for namespaces <tt>N1</tt> and <tt>N2</tt> is (for
--   both terms and types) a relation between references, where `a R b` if:
--   
--   <ol>
--   <li><tt>a</tt> has name <tt>n</tt> in <tt>N1</tt>, and <tt>b</tt> has
--   the same name <tt>n</tt> in <tt>N2</tt></li>
--   <li><tt>a</tt> != <tt>b</tt></li>
--   </ol>
data NameBasedDiff
NameBasedDiff :: Relation Reference Reference -> Relation Reference Reference -> NameBasedDiff
[$sel:terms:NameBasedDiff] :: NameBasedDiff -> Relation Reference Reference
[$sel:types:NameBasedDiff] :: NameBasedDiff -> Relation Reference Reference

-- | Diff two Branches, returning a tree containing all of the changes
diffBranches :: Branch Transaction -> Branch Transaction -> Transaction (TreeDiff Transaction)

-- | Get a summary of all of the name adds and removals from a tree diff.
--   
--   The provided name will be prepended to all names in the output diff,
--   and can be useful if diffing branches at a specific sub-tree, but you
--   can pass <a>Nothing</a> if you're diffing from the root.
allNameChanges :: Monad m => Maybe Name -> TreeDiff m -> m NameChanges

-- | Get a <a>NameBasedDiff</a> from a <a>TreeDiff</a>.
nameBasedDiff :: Monad m => TreeDiff m -> m NameBasedDiff

-- | Stream a summary of all of the name adds and removals from a tree
--   diff. Callback is passed the diff from one namespace level at a time,
--   with the name representing that location. Accumulator is folded
--   strictly, use <tt>()</tt> if you don't need one.
streamNameChanges :: (Monad m, Monoid r) => Maybe Name -> TreeDiff m -> (Maybe Name -> NameChanges -> m r) -> m r
instance GHC.Classes.Ord a => GHC.Classes.Ord (U.Codebase.Branch.Diff.Diff a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (U.Codebase.Branch.Diff.Diff a)
instance GHC.Show.Show a => GHC.Show.Show (U.Codebase.Branch.Diff.Diff a)
instance GHC.Classes.Ord U.Codebase.Branch.Diff.DefinitionDiffs
instance GHC.Classes.Eq U.Codebase.Branch.Diff.DefinitionDiffs
instance GHC.Show.Show U.Codebase.Branch.Diff.DefinitionDiffs
instance Data.Functor.Classes.Ord1 m => GHC.Classes.Ord (U.Codebase.Branch.Diff.TreeDiff m)
instance Data.Functor.Classes.Eq1 m => GHC.Classes.Eq (U.Codebase.Branch.Diff.TreeDiff m)
instance Data.Functor.Classes.Show1 m => GHC.Show.Show (U.Codebase.Branch.Diff.TreeDiff m)
instance GHC.Classes.Eq U.Codebase.Branch.Diff.NameChanges
instance GHC.Show.Show U.Codebase.Branch.Diff.NameChanges
instance GHC.Show.Show U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Generics.Generic U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Base.Monoid U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Base.Semigroup U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Base.Semigroup U.Codebase.Branch.Diff.NameChanges
instance GHC.Base.Monoid U.Codebase.Branch.Diff.NameChanges
instance GHC.Base.Applicative m => GHC.Base.Semigroup (U.Codebase.Branch.Diff.TreeDiff m)
instance GHC.Base.Applicative m => GHC.Base.Monoid (U.Codebase.Branch.Diff.TreeDiff m)
instance GHC.Base.Semigroup U.Codebase.Branch.Diff.DefinitionDiffs
instance GHC.Base.Monoid U.Codebase.Branch.Diff.DefinitionDiffs

module Unison.Codebase.BuiltinAnnotation
class BuiltinAnnotation a
builtinAnnotation :: BuiltinAnnotation a => a
instance Unison.Codebase.BuiltinAnnotation.BuiltinAnnotation Unison.Parser.Ann.Ann
instance Unison.Codebase.BuiltinAnnotation.BuiltinAnnotation ()

module Unison.Codebase.Causal.Type
data Causal m e
UnsafeOne :: CausalHash -> HashFor e -> e -> Causal m e
[$sel:currentHash:UnsafeOne] :: Causal m e -> CausalHash
[$sel:valueHash:UnsafeOne] :: Causal m e -> HashFor e
[$sel:head:UnsafeOne] :: Causal m e -> e
UnsafeCons :: CausalHash -> HashFor e -> e -> (CausalHash, m (Causal m e)) -> Causal m e
[$sel:currentHash:UnsafeOne] :: Causal m e -> CausalHash
[$sel:valueHash:UnsafeOne] :: Causal m e -> HashFor e
[$sel:head:UnsafeOne] :: Causal m e -> e
[$sel:tail:UnsafeOne] :: Causal m e -> (CausalHash, m (Causal m e))
UnsafeMerge :: CausalHash -> HashFor e -> e -> Map CausalHash (m (Causal m e)) -> Causal m e
[$sel:currentHash:UnsafeOne] :: Causal m e -> CausalHash
[$sel:valueHash:UnsafeOne] :: Causal m e -> HashFor e
[$sel:head:UnsafeOne] :: Causal m e -> e
[$sel:tails:UnsafeOne] :: Causal m e -> Map CausalHash (m (Causal m e))
pattern One :: CausalHash -> HashFor e -> e -> Causal m e
pattern Cons :: CausalHash -> HashFor e -> e -> (CausalHash, m (Causal m e)) -> Causal m e
pattern Merge :: CausalHash -> HashFor e -> e -> Map CausalHash (m (Causal m e)) -> Causal m e
before :: Monad m => Causal m e -> Causal m e -> m Bool
predecessors :: Causal m e -> Seq (m (Causal m e))
lca :: Monad m => Causal m e -> Causal m e -> m (Maybe (Causal m e))
instance GHC.Show.Show e => GHC.Show.Show (Unison.Codebase.Causal.Type.Causal m e)
instance GHC.Classes.Eq (Unison.Codebase.Causal.Type.Causal m a)
instance GHC.Classes.Ord (Unison.Codebase.Causal.Type.Causal m a)

module Unison.Codebase.CodeLookup
data CodeLookup v m a
CodeLookup :: (Id -> m (Maybe (Term v a))) -> (Id -> m (Maybe (Decl v a))) -> CodeLookup v m a
[$sel:getTerm:CodeLookup] :: CodeLookup v m a -> Id -> m (Maybe (Term v a))
[$sel:getTypeDeclaration:CodeLookup] :: CodeLookup v m a -> Id -> m (Maybe (Decl v a))
transitiveDependencies :: (Monad m, Var v) => CodeLookup v m a -> Set Id -> Id -> m (Set Id)
instance Control.Monad.Morph.MFunctor (Unison.Codebase.CodeLookup.CodeLookup v)
instance (GHC.Classes.Ord v, GHC.Base.Functor m) => GHC.Base.Functor (Unison.Codebase.CodeLookup.CodeLookup v m)
instance GHC.Base.Monad m => GHC.Base.Semigroup (Unison.Codebase.CodeLookup.CodeLookup v m a)
instance GHC.Base.Monad m => GHC.Base.Monoid (Unison.Codebase.CodeLookup.CodeLookup v m a)

module Unison.Codebase.Init.CreateCodebaseError
data CreateCodebaseError
CreateCodebaseAlreadyExists :: CreateCodebaseError
type Pretty = Pretty ColorText
instance GHC.Show.Show Unison.Codebase.Init.CreateCodebaseError.CreateCodebaseError


-- | Open codebase error type.
module Unison.Codebase.Init.OpenCodebaseError

-- | An error that can occur when attempting to open a codebase.
data OpenCodebaseError

-- | The codebase doesn't exist.
OpenCodebaseDoesntExist :: OpenCodebaseError

-- | The codebase exists, but its schema version is unknown to this
--   application.
OpenCodebaseUnknownSchemaVersion :: SchemaVersion -> OpenCodebaseError
OpenCodebaseFileLockFailed :: OpenCodebaseError

-- | The codebase exists, but requires a migration before it can be used.
OpenCodebaseRequiresMigration :: SchemaVersion -> SchemaVersion -> OpenCodebaseError
instance GHC.Exception.Type.Exception Unison.Codebase.Init.OpenCodebaseError.OpenCodebaseError
instance GHC.Classes.Eq Unison.Codebase.Init.OpenCodebaseError.OpenCodebaseError
instance GHC.Show.Show Unison.Codebase.Init.OpenCodebaseError.OpenCodebaseError

module Unison.Codebase.Path
newtype Path
Path :: Seq NameSegment -> Path
[$sel:toSeq:Path] :: Path -> Seq NameSegment
newtype Path'
Path' :: Either Absolute Relative -> Path'
[$sel:unPath':Path'] :: Path' -> Either Absolute Relative
newtype Absolute
Absolute :: Path -> Absolute
[$sel:unabsolute:Absolute] :: Absolute -> Path
pattern AbsolutePath' :: Absolute -> Path'
newtype Relative
Relative :: Path -> Relative
[$sel:unrelative:Relative] :: Relative -> Path
pattern RelativePath' :: Relative -> Path'
class Resolve l r o
resolve :: Resolve l r o => l -> r -> o
pattern Empty :: Path
pattern (:<) :: Cons b b a a => a -> b -> b
infixr 5 :<
pattern (:>) :: Snoc a a b b => a -> b -> a
infixl 5 :>
singleton :: NameSegment -> Path
uncons :: Path -> Maybe (NameSegment, Path)
empty :: Path
isAbsolute :: Path' -> Bool
isRelative :: Path' -> Bool
absoluteEmpty :: Absolute
absoluteEmpty' :: Path'
relativeEmpty :: Relative
relativeEmpty' :: Path'
currentPath :: Path'

-- | This always prefixes, since the secend argument can never be Absolute.
prefix :: Path' -> Relative -> Path'
prefixAbs :: Absolute -> Relative -> Absolute
prefixRel :: Relative -> Relative -> Relative

-- | Returns <a>Nothing</a> if the second argument is absolute. A common
--   pattern is <tt>fromMaybe path $ maybePrefix prefix path</tt> to use
--   the unmodified path in that case.
maybePrefix :: Path' -> Path' -> Maybe Path'

-- | examples: unprefix .foo.bar .blah == .blah (absolute paths left alone)
--   unprefix .foo.bar id == id (relative paths starting w/ nonmatching
--   prefix left alone) unprefix .foo.bar foo.bar.baz == baz (relative
--   paths w/ common prefix get stripped)
unprefix :: Absolute -> Path' -> Path

-- | Returns <a>Nothing</a> if the second argument is absolute. A common
--   pattern is <tt>fromMaybe name $ maybePrefixName prefix name</tt> to
--   use the unmodified path in that case.
maybePrefixName :: Path' -> Name -> Maybe Name
prefixNameIfRel :: Path' -> Name -> Name

-- | Remove a path prefix from a name. Returns <a>Nothing</a> if there are
--   no remaining segments to construct the name from.
--   
--   <pre>
--   &gt;&gt;&gt; unprefixName (Absolute $ fromList ["base", "List"]) (Name.unsafeFromText "base.List.map")
--   Just (Name Relative (NameSegment {toText = "map"} :| []))
--   </pre>
unprefixName :: Absolute -> Name -> Maybe Name
type HQSplit = (Path, HQSegment)
type Split = (Path, NameSegment)
type Split' = (Path', NameSegment)
type HQSplit' = (Path', HQSegment)
ancestors :: Absolute -> Seq Absolute

-- | Finds the longest shared path prefix of two paths. Returns (shared
--   prefix, path to first location from shared prefix, path to second
--   location from shared prefix)
--   
--   <pre>
--   &gt;&gt;&gt; longestPathPrefix ("a" :&lt; "b" :&lt; "x" :&lt; Empty) ("a" :&lt; "b" :&lt; "c" :&lt; Empty)
--   (a.b,x,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; longestPathPrefix Empty ("a" :&lt; "b" :&lt; "c" :&lt; Empty)
--   (,,a.b.c)
--   </pre>
longestPathPrefix :: Path -> Path -> (Path, Path, Path)
isCurrentPath :: Path' -> Bool
isRoot :: Absolute -> Bool
isRoot' :: Path' -> Bool
absoluteToPath' :: Absolute -> Path'
fromList :: [NameSegment] -> Path
fromName :: Name -> Path
fromName' :: Name -> Path'
fromPath' :: Path' -> Path
unsafeParseText :: Text -> Path

-- | Construct a Path' from a text
--   
--   <pre>
--   &gt;&gt;&gt; fromText' "a.b.c"
--   a.b.c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromText' ".a.b.c"
--   .a.b.c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; show $ fromText' ""
--   ""
--   </pre>
unsafeParseText' :: Text -> Path'
toAbsoluteSplit :: Absolute -> (Path', a) -> (Absolute, a)
toSplit' :: Path' -> Maybe (Path', NameSegment)
toList :: Path -> [NameSegment]
toName :: Path -> Maybe Name

-- | Convert a Path' to a Name
toName' :: Path' -> Maybe Name
unsafeToName :: Path -> Name

-- | Convert a Path' to a Name
unsafeToName' :: Path' -> Name

-- | Note: This treats the path as relative.
toText :: Path -> Text
toText' :: Path' -> Text
unsplit :: Split -> Path
unsplit' :: Split' -> Path'
unsplitAbsolute :: (Absolute, NameSegment) -> Absolute
unsplitHQ :: HQSplit -> HashQualified Path
unsplitHQ' :: HQSplit' -> HashQualified Path'
nameFromSplit' :: Split' -> Name

-- | <pre>
--   &gt;&gt;&gt; splitFromName "a.b.c"
--   (a.b,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitFromName "foo"
--   (,foo)
--   </pre>
splitFromName :: Name -> Split
splitFromName' :: Name -> Split'
hqSplitFromName' :: Name -> HQSplit'
cons :: NameSegment -> Path -> Path
snoc :: Path -> NameSegment -> Path
unsnoc :: Path -> Maybe (Path, NameSegment)
class Convert a b
convert :: Convert a b => a -> b
instance GHC.Base.Monoid Unison.Codebase.Path.Path
instance GHC.Base.Semigroup Unison.Codebase.Path.Path
instance GHC.Classes.Ord Unison.Codebase.Path.Path
instance GHC.Classes.Eq Unison.Codebase.Path.Path
instance GHC.Classes.Ord Unison.Codebase.Path.Absolute
instance GHC.Classes.Eq Unison.Codebase.Path.Absolute
instance GHC.Classes.Ord Unison.Codebase.Path.Relative
instance GHC.Classes.Eq Unison.Codebase.Path.Relative
instance GHC.Classes.Ord Unison.Codebase.Path.Path'
instance GHC.Classes.Eq Unison.Codebase.Path.Path'
instance Control.Lens.Empty.AsEmpty Unison.Codebase.Path.Path
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.Codebase.Path.Path
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Relative Unison.Codebase.Path.Absolute
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Relative Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Split' Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Split' Unison.Codebase.Path.Split'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.HQSplit Unison.Codebase.Path.HQSplitAbsolute
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Path' Unison.Codebase.Path.Absolute
instance Unison.Name.Convert Unison.Codebase.Path.HQSplit' (Unison.HashQualified'.HashQualified Unison.Codebase.Path.Path')
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Split' Unison.Codebase.Path.Split' Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.HQSplit (Unison.HashQualified'.HashQualified Unison.Codebase.Path.Path)
instance Unison.Name.Convert Unison.Name.Internal.Name Unison.Codebase.Path.Split
instance GHC.Show.Show Unison.Codebase.Path.Path'
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.Absolute Unison.Codebase.Path.Path'
instance GHC.Show.Show Unison.Codebase.Path.Relative
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.Relative Data.Text.Internal.Text
instance Unison.Name.Convert Unison.Codebase.Path.Relative GHC.Base.String
instance GHC.Show.Show Unison.Codebase.Path.Absolute
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Absolute Unison.Codebase.Path.Absolute Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Absolute Unison.Codebase.Path.Absolute Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.Absolute Unison.Codebase.Path.Path
instance Unison.Name.Convert Unison.Codebase.Path.Absolute Data.Text.Internal.Text
instance Unison.Name.Convert Unison.Codebase.Path.Absolute GHC.Base.String
instance GHC.Exts.IsList Unison.Codebase.Path.Path
instance GHC.Show.Show Unison.Codebase.Path.Path
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Unison.Name.Convert [Unison.NameSegment.Internal.NameSegment] Unison.Codebase.Path.Path
instance Unison.Name.Convert Unison.Codebase.Path.Path [Unison.NameSegment.Internal.NameSegment]
instance Unison.Name.Convert (path, Unison.NameSegment.Internal.NameSegment) (path, Unison.HashQualified'.HQSegment)
instance Unison.Name.Convert path0 path1 => Unison.Name.Convert (path0, name) (path1, name)

module U.Codebase.Projects

-- | Find all dependency mounts within a branch and the path to those
--   mounts.
--   
--   For a typical project this will return something like: <tt>[(lib.base,
--   #abc), (lib.distributed, #def)]</tt>
--   
--   For the top-level name lookup of a user codebase it returns the
--   project roots, and will return something like:
--   <tt>[(public.nested.myproject.latest, #abc),
--   (public.other.namespace.otherproject.main, #def)]</tt>
inferDependencyMounts :: Branch Transaction -> Transaction [(Path, BranchHash)]

module Unison.Codebase.Path.Parse
parsePath :: String -> Either Text Path
parsePath' :: String -> Either Text Path'
parseSplit :: String -> Either Text Split
parseSplit' :: String -> Either Text Split'
parseHQSplit :: String -> Either Text HQSplit
parseHQSplit' :: String -> Either Text HQSplit'
parseShortHashOrHQSplit' :: String -> Either Text (Either ShortHash HQSplit')
pathP :: Parsec (Token Text) [Char] Path
pathP' :: Parsec (Token Text) [Char] Path'
splitP :: Parsec (Token Text) [Char] Split
splitP' :: Parsec (Token Text) [Char] Split'


-- | This module defines the <a>PushBehavior</a> type.
module Unison.Codebase.PushBehavior

-- | How a <tt>push</tt> behaves.
data PushBehavior
ForcePush :: PushBehavior

-- | The namespace being pushed to is required to be empty.
RequireEmpty :: PushBehavior

-- | The namespace being pushed to is required to be non-empty
RequireNonEmpty :: PushBehavior
instance GHC.Show.Show Unison.Codebase.PushBehavior.PushBehavior
instance GHC.Classes.Eq Unison.Codebase.PushBehavior.PushBehavior

module Unison.Codebase.Serialization
type Get a = forall m. (MonadGet m) => m a
type Put a = forall m. (MonadPut m) => a -> m ()
data Format a
Format :: Get a -> Put a -> Format a
[$sel:get:Format] :: Format a -> Get a
[$sel:put:Format] :: Format a -> Put a
getFromBytes :: Get a -> ByteString -> Maybe a
getFromFile :: MonadIO m => Get a -> FilePath -> m (Maybe a)
getFromFile' :: MonadIO m => Get a -> FilePath -> m (Either String a)
putBytes :: Put a -> a -> ByteString
putWithParentDirs :: MonadIO m => Put a -> FilePath -> a -> m ()

module Unison.Codebase.ShortCausalHash
toString :: ShortCausalHash -> String
toHash :: Coercible Hash h => ShortCausalHash -> Maybe h
fromHash :: Coercible h Hash => Int -> h -> ShortCausalHash

-- | This allows a full hash to be preserved as a <a>ShortCausalHash</a>.
--   
--   <a>ShortCausalHash</a> is used for input when we expect a user to
--   enter a hash on the command line, so they aren’t required to enter the
--   full hash. However, these inputs may also come from an internal
--   source, and in such cases, there is no reason to truncate the hash.
fromFullHash :: Coercible h Hash => h -> ShortCausalHash
fromText :: Text -> Maybe ShortCausalHash

-- | Causal Hash Prefix
newtype ShortCausalHash
ShortCausalHash :: Text -> ShortCausalHash
[$sel:toText:ShortCausalHash] :: ShortCausalHash -> Text
instance GHC.Generics.Generic Unison.Codebase.ShortCausalHash.ShortCausalHash
instance GHC.Classes.Ord Unison.Codebase.ShortCausalHash.ShortCausalHash
instance GHC.Classes.Eq Unison.Codebase.ShortCausalHash.ShortCausalHash
instance GHC.Show.Show Unison.Codebase.ShortCausalHash.ShortCausalHash

module Unison.Codebase.SqliteCodebase.Migrations.Helpers
abortMigration :: String -> Transaction a

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema11To12

-- | This migration just deletes all the old name lookups, it doesn't
--   recreate them. On share we'll rebuild only the required name lookups
--   from scratch.
migrateSchema11To12 :: Transaction ()

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.DbHelpers
dbBranchHash :: DbBranch -> Transaction BranchHash
dbPatchHash :: Patch -> Transaction PatchHash
syncCausalHash :: SyncCausalFormat -> Transaction CausalHash


-- | There are many invariants we expect to hold in our sqlite database and
--   on codebase objects which we can't maintain using database checks.
--   This module performs checks for some of these invariants, which can be
--   useful to run after performing potentially dangerous operations like
--   migrations.
module Unison.Codebase.IntegrityCheck

-- | Performs all available integrity checks.
integrityCheckFullCodebase :: Transaction IntegrityResult

-- | Performs a bevy of checks on branch objects and their relation to
--   causals.
integrityCheckAllBranches :: Transaction IntegrityResult

-- | Performs a bevy of checks on causals.
integrityCheckAllCausals :: Transaction IntegrityResult
prettyPrintIntegrityErrors :: Foldable f => f IntegrityError -> Pretty ColorText
data IntegrityResult
IntegrityErrorDetected :: NESet IntegrityError -> IntegrityResult
NoIntegrityErrors :: IntegrityResult
instance GHC.Classes.Ord Unison.Codebase.IntegrityCheck.BranchError
instance GHC.Classes.Eq Unison.Codebase.IntegrityCheck.BranchError
instance GHC.Show.Show Unison.Codebase.IntegrityCheck.BranchError
instance GHC.Classes.Ord Unison.Codebase.IntegrityCheck.IntegrityError
instance GHC.Classes.Eq Unison.Codebase.IntegrityCheck.IntegrityError
instance GHC.Show.Show Unison.Codebase.IntegrityCheck.IntegrityError
instance GHC.Classes.Ord Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Classes.Eq Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Show.Show Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Base.Semigroup Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Base.Monoid Unison.Codebase.IntegrityCheck.IntegrityResult

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema3To4

-- | There was a bug in previous versions of UCM which incorrectly used
--   causal hashes as branch hashes. This remained undetected because there
--   was never a need for this hash to be verifiable, and the hashes were
--   still unique because the namespace hash was PART of the causal hash.
--   It did however result in many identical branches being stored multiple
--   times under different <tt>primary_hash_id</tt>s.
--   
--   However, with the advent of Share and Sync, we now need to correctly
--   verify these namespace hashes.
--   
--   This migration fixes the issue by re-hashing namespace objects where
--   the value_hash_id of a causal matches the self_hash_id. Luckily this
--   doesn't change any causal hashes.
--   
--   However, due to the possibility of multiple identical objects stored
--   under different <tt>primary_hash_id</tt>s, we may now have multiple
--   objects with the same <tt>primary_hash_id</tt>, which our DB schema
--   doesn't allow.
--   
--   To address this, we keep exactly one <tt>canonical</tt> object for
--   each hash, then remap all references to old objects into this
--   canonical object instead. Unfortunately this requires mapping over
--   every branch object and traversing the child references.
--   
--   It was also discovered that some developers had many branches which
--   referenced objects which weren't in their codebase. We're not yet sure
--   how this happened, but it's unlikely to be the case for most end
--   users, and it turned out that these references were in causals and
--   branches which were unreachable from the root namespace. As a fix,
--   this migration also tracks every causal and branch which is reachable
--   from the root namespace and deletes all causals and namespaces which
--   are unreachable. Note that this may orphan some definitions, patches,
--   etc. which were previously referenced in an <tt>unreachable</tt>
--   branch, but they were already floating around in an unreachable state.
migrateSchema3To4 :: Transaction ()
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema3To4.MigrationState

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema6To7

-- | Adds a table for tracking namespace statistics Adds stats for all
--   existing namespaces, even though missing stats are computed on-demand
--   if missing.
migrateSchema6To7 :: Transaction ()

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema7To8

-- | Adds a table for tracking namespace statistics Adds stats for all
--   existing namespaces, even though missing stats are computed on-demand
--   if missing.
migrateSchema7To8 :: Transaction ()

module Unison.Codebase.SqliteCodebase.SyncEphemeral
data Dependencies
Dependencies :: Set Hash -> Set Hash -> Dependencies
[$sel:definitions:Dependencies] :: Dependencies -> Set Hash
[$sel:branches:Dependencies] :: Dependencies -> Set Hash
data Error
Sync22Error :: Error -> Error
SrcWrongSchema :: SchemaVersion -> Error
DestWrongSchema :: SchemaVersion -> Error
DisappearingBranch :: CausalHash -> Error
instance GHC.Exception.Type.Exception Unison.Codebase.SqliteCodebase.SyncEphemeral.Error
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.SyncEphemeral.Error

module Unison.Codebase.TermEdit
data TermEdit
Replace :: Reference -> Typing -> TermEdit
Deprecate :: TermEdit
references :: TermEdit -> [Reference]
data Typing
Same :: Typing
Subtype :: Typing
Different :: Typing
toReference :: TermEdit -> Maybe Reference
isTypePreserving :: TermEdit -> Bool
isSame :: TermEdit -> Bool
instance GHC.Show.Show Unison.Codebase.TermEdit.Typing
instance GHC.Classes.Ord Unison.Codebase.TermEdit.Typing
instance GHC.Classes.Eq Unison.Codebase.TermEdit.Typing
instance GHC.Show.Show Unison.Codebase.TermEdit.TermEdit
instance GHC.Classes.Ord Unison.Codebase.TermEdit.TermEdit
instance GHC.Classes.Eq Unison.Codebase.TermEdit.TermEdit

module Unison.Codebase.TypeEdit
data TypeEdit
Replace :: Reference -> TypeEdit
Deprecate :: TypeEdit
references :: TypeEdit -> [Reference]
toReference :: TypeEdit -> Maybe Reference
instance GHC.Show.Show Unison.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Ord Unison.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Eq Unison.Codebase.TypeEdit.TypeEdit

module Unison.Codebase.Patch
data Patch
Patch :: Relation Reference TermEdit -> Relation Reference TypeEdit -> Patch
[$sel:_termEdits:Patch] :: Patch -> Relation Reference TermEdit
[$sel:_typeEdits:Patch] :: Patch -> Relation Reference TypeEdit
data PatchDiff
PatchDiff :: Relation Reference TermEdit -> Relation Reference TypeEdit -> Relation Reference TermEdit -> Relation Reference TypeEdit -> PatchDiff
[$sel:_addedTermEdits:PatchDiff] :: PatchDiff -> Relation Reference TermEdit
[$sel:_addedTypeEdits:PatchDiff] :: PatchDiff -> Relation Reference TypeEdit
[$sel:_removedTermEdits:PatchDiff] :: PatchDiff -> Relation Reference TermEdit
[$sel:_removedTypeEdits:PatchDiff] :: PatchDiff -> Relation Reference TypeEdit
typeEdits :: Lens' Patch (Relation Reference TypeEdit)
termEdits :: Lens' Patch (Relation Reference TermEdit)
removedTypeEdits :: Lens' PatchDiff (Relation Reference TypeEdit)
removedTermEdits :: Lens' PatchDiff (Relation Reference TermEdit)
addedTypeEdits :: Lens' PatchDiff (Relation Reference TypeEdit)
addedTermEdits :: Lens' PatchDiff (Relation Reference TermEdit)
diff :: Patch -> Patch -> PatchDiff
labeledDependencies :: Patch -> Set LabeledDependency
empty :: Patch
isEmpty :: Patch -> Bool
allReferences :: Patch -> Set Reference

-- | Returns the set of references which are the target of an arrow in the
--   patch
allReferenceTargets :: Patch -> Set Reference
updateTerm :: (Reference -> Reference -> Typing) -> Reference -> TermEdit -> Patch -> Patch
updateType :: Reference -> TypeEdit -> Patch -> Patch
conflicts :: Patch -> Patch
instance GHC.Base.Semigroup Unison.Codebase.Patch.Patch
instance GHC.Base.Monoid Unison.Codebase.Patch.Patch
instance GHC.Base.Semigroup Unison.Codebase.Patch.PatchDiff
instance GHC.Base.Monoid Unison.Codebase.Patch.PatchDiff
instance GHC.Show.Show Unison.Codebase.Patch.Patch
instance GHC.Classes.Ord Unison.Codebase.Patch.Patch
instance GHC.Classes.Eq Unison.Codebase.Patch.Patch
instance GHC.Show.Show Unison.Codebase.Patch.PatchDiff
instance GHC.Classes.Ord Unison.Codebase.Patch.PatchDiff
instance GHC.Classes.Eq Unison.Codebase.Patch.PatchDiff


-- | This module contains functionality related to computing a "unique type
--   guid lookup" function, which resolves a name to a unique type's GUID
--   to reuse.
module Unison.Codebase.UniqueTypeGuidLookup

-- | <tt>loadUniqueTypeGuid loadNamespaceAtPath path name</tt> looks up the
--   GUID associated with the unique type named <tt>name</tt> at child
--   namespace <tt>path</tt> in the root namespace. If there are multiple
--   such types, an arbitrary one is chosen.
--   
--   For (potential) efficiency, this function accepts an argument that
--   loads a namespace at a path, which may be backed by a cache.
loadUniqueTypeGuid :: ([NameSegment] -> Transaction (Maybe (Branch Transaction))) -> [NameSegment] -> NameSegment -> Transaction (Maybe Text)

module Unison.Codebase.Verbosity
data Verbosity
Verbose :: Verbosity
Silent :: Verbosity
isSilent :: Verbosity -> Bool
instance GHC.Show.Show Unison.Codebase.Verbosity.Verbosity
instance GHC.Classes.Eq Unison.Codebase.Verbosity.Verbosity

module Unison.CodebasePath

-- | A directory that contains a codebase.
type CodebasePath = FilePath
getCodebaseDir :: MonadIO m => Maybe CodebasePath -> m CodebasePath

module Unison.KindInference.UVar
data UVar v loc
UVar :: Symbol -> Type v loc -> UVar v loc
[$sel:_uvarSymbol:UVar] :: UVar v loc -> Symbol
[$sel:uvarType:UVar] :: UVar v loc -> Type v loc
instance GHC.Show.Show v => GHC.Show.Show (Unison.KindInference.UVar.UVar v loc)
instance U.Core.ABT.Var.Var v => GHC.Classes.Ord (Unison.KindInference.UVar.UVar v loc)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.KindInference.UVar.UVar v loc)

module Unison.KindInference.Constraint.Context

-- | The context in which the constraint was generated. This is useful when
--   generating user-facing error messages.
data ConstraintContext v loc
AppAbs :: !UVar v loc -> !UVar v loc -> ConstraintContext v loc
AppArg :: !UVar v loc -> !UVar v loc -> !UVar v loc -> ConstraintContext v loc
AppArrow :: loc -> !Type v loc -> !Type v loc -> ConstraintContext v loc
Annotation :: ConstraintContext v loc
EffectsList :: ConstraintContext v loc
ScopeReference :: ConstraintContext v loc
TypeAnnotation :: ConstraintContext v loc
DeclDefinition :: ConstraintContext v loc
Builtin :: ConstraintContext v loc
ContextLookup :: ConstraintContext v loc
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord loc) => GHC.Classes.Ord (Unison.KindInference.Constraint.Context.ConstraintContext v loc)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq loc) => GHC.Classes.Eq (Unison.KindInference.Constraint.Context.ConstraintContext v loc)
instance (GHC.Show.Show v, GHC.Show.Show loc) => GHC.Show.Show (Unison.KindInference.Constraint.Context.ConstraintContext v loc)

module Unison.KindInference.Constraint.Provenance

-- | A tag for a source span and context indicating where the generated
--   constraint came from. This is helpful to propagate the constraint
--   context through the solver for user-facing error messages.
data Provenance v loc
Provenance :: !ConstraintContext v loc -> !loc -> Provenance v loc
loc :: Lens' (Provenance v loc) loc
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord loc) => GHC.Classes.Ord (Unison.KindInference.Constraint.Provenance.Provenance v loc)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq loc) => GHC.Classes.Eq (Unison.KindInference.Constraint.Provenance.Provenance v loc)
instance (GHC.Show.Show v, GHC.Show.Show loc) => GHC.Show.Show (Unison.KindInference.Constraint.Provenance.Provenance v loc)

module Unison.KindInference.Constraint.Unsolved

-- | Unsolved constraints
--   
--   These are produced during constraint generation and given as input to
--   the constraint solver.
data Constraint uv v loc typeProv

-- | An IsType constraint may arise from generation or from the solver.
--   During generation the provenance is always a real source code
--   location, but the solver defaults unconstrained kind vars to Star.
IsType :: uv -> typeProv v loc -> Constraint uv v loc typeProv
IsArr :: uv -> Provenance v loc -> uv -> uv -> Constraint uv v loc typeProv
IsAbility :: uv -> Provenance v loc -> Constraint uv v loc typeProv
Unify :: Provenance v loc -> uv -> uv -> Constraint uv v loc typeProv
typeProv :: Traversal (Constraint uv v loc prov) (Constraint uv v loc prov') (prov v loc) (prov' v loc)
prov :: Lens (Constraint uv v loc Provenance) (Constraint uv v loc' Provenance) (Provenance v loc) (Provenance v loc')
loc :: Lens' (Constraint uv v loc Provenance) loc
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord uv, GHC.Classes.Ord loc, GHC.Classes.Ord (typeProv v loc)) => GHC.Classes.Ord (Unison.KindInference.Constraint.Unsolved.Constraint uv v loc typeProv)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq uv, GHC.Classes.Eq loc, GHC.Classes.Eq (typeProv v loc)) => GHC.Classes.Eq (Unison.KindInference.Constraint.Unsolved.Constraint uv v loc typeProv)
instance (GHC.Show.Show uv, GHC.Show.Show v, GHC.Show.Show loc, GHC.Show.Show (typeProv v loc)) => GHC.Show.Show (Unison.KindInference.Constraint.Unsolved.Constraint uv v loc typeProv)

module Unison.KindInference.Generate.Monad
newtype Gen v loc a
Gen :: (GenState v loc -> (a, GenState v loc)) -> Gen v loc a
[$sel:unGen:Gen] :: Gen v loc a -> GenState v loc -> (a, GenState v loc)

-- | The <tt>Gen</tt> monad state
data GenState v loc
GenState :: !Set Symbol -> !Map (Type v loc) (NonEmpty (UVar v loc)) -> [UVar v loc] -> GenState v loc
[$sel:unifVars:GenState] :: GenState v loc -> !Set Symbol
[$sel:typeMap:GenState] :: GenState v loc -> !Map (Type v loc) (NonEmpty (UVar v loc))
[$sel:newVars:GenState] :: GenState v loc -> [UVar v loc]

-- | A generated constraint
type GeneratedConstraint v loc = Constraint (UVar v loc) v loc Provenance

-- | <tt>Gen</tt> monad runner
run :: Gen v loc a -> GenState v loc -> (a, GenState v loc)

-- | Create a unique <tt>UVar</tt> associated with <tt>typ</tt>
freshVar :: Var v => Type v loc -> Gen v loc (UVar v loc)

-- | Associate a fresh <tt>UVar</tt> with <tt>t</tt>, push onto context
pushType :: Var v => Type v loc -> Gen v loc (UVar v loc)

-- | Remove a <tt>Type</tt> from the context
popType :: Var v => Type v loc -> Gen v loc ()

-- | Helper to run an action with the given <tt>Type</tt> in the context
scopedType :: Var v => Type v loc -> (UVar v loc -> Gen v loc r) -> Gen v loc r

-- | Lookup the <tt>UVar</tt> associated with a <tt>Type</tt>
lookupType :: Var v => Type v loc -> Gen v loc (Maybe (UVar v loc))
instance GHC.Generics.Generic (Unison.KindInference.Generate.Monad.GenState v loc)
instance Control.Monad.State.Class.MonadState (Unison.KindInference.Generate.Monad.GenState v loc) (Unison.KindInference.Generate.Monad.Gen v loc)
instance GHC.Base.Monad (Unison.KindInference.Generate.Monad.Gen v loc)
instance GHC.Base.Applicative (Unison.KindInference.Generate.Monad.Gen v loc)
instance GHC.Base.Functor (Unison.KindInference.Generate.Monad.Gen v loc)

module Unison.KindInference.Constraint.TypeProvenance

-- | Provenance of an <tt>IsType</tt> constraint. <tt>IsType</tt>
--   constraints arise in constraint generation (in which case it will have
--   a <tt>Provenance</tt>) and also in the solver through kind-defaulting
--   on unconstrained unification variables.
data TypeProvenance v loc
NotDefault :: Provenance v loc -> TypeProvenance v loc
Default :: TypeProvenance v loc
prov :: Traversal (TypeProvenance v loc) (TypeProvenance v loc') (Provenance v loc) (Provenance v loc')
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord loc) => GHC.Classes.Ord (Unison.KindInference.Constraint.TypeProvenance.TypeProvenance v loc)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq loc) => GHC.Classes.Eq (Unison.KindInference.Constraint.TypeProvenance.TypeProvenance v loc)
instance (GHC.Show.Show v, GHC.Show.Show loc) => GHC.Show.Show (Unison.KindInference.Constraint.TypeProvenance.TypeProvenance v loc)

module Unison.KindInference.Constraint.Solved

-- | Solved constraints
--   
--   These constraints are associated with unification variables during
--   kind inference.
data Constraint uv v loc
IsType :: TypeProvenance v loc -> Constraint uv v loc
IsAbility :: Provenance v loc -> Constraint uv v loc
IsArr :: Provenance v loc -> uv -> uv -> Constraint uv v loc
prov :: Traversal (Constraint uv v loc) (Constraint uv v loc') (Provenance v loc) (Provenance v loc')
loc :: Traversal' (Constraint uv v loc) loc
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord loc, GHC.Classes.Ord uv) => GHC.Classes.Ord (Unison.KindInference.Constraint.Solved.Constraint uv v loc)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq loc, GHC.Classes.Eq uv) => GHC.Classes.Eq (Unison.KindInference.Constraint.Solved.Constraint uv v loc)
instance (GHC.Show.Show v, GHC.Show.Show loc, GHC.Show.Show uv) => GHC.Show.Show (Unison.KindInference.Constraint.Solved.Constraint uv v loc)

module Unison.PatternMatchCoverage.Fix
newtype Fix f
Fix :: f (Fix f) -> Fix f
[$sel:unFix:Fix] :: Fix f -> f (Fix f)
cata :: Functor f => (f a -> a) -> Fix f -> a
para :: Functor f => (f (Fix f, a) -> a) -> Fix f -> a
instance (forall a. GHC.Show.Show a => GHC.Show.Show (f a)) => GHC.Show.Show (Unison.PatternMatchCoverage.Fix.Fix f)
instance (forall a. GHC.Classes.Eq a => GHC.Classes.Eq (f a)) => GHC.Classes.Eq (Unison.PatternMatchCoverage.Fix.Fix f)
instance (GHC.Classes.Eq (Unison.PatternMatchCoverage.Fix.Fix f), forall a. GHC.Classes.Ord a => GHC.Classes.Ord (f a)) => GHC.Classes.Ord (Unison.PatternMatchCoverage.Fix.Fix f)

module Unison.PatternMatchCoverage.GrdTree

-- | A <tt>GrdTree</tt> is the simple language to desugar matches into. All
--   pattern matching constructs (<i>e.g.</i> structural pattern matching,
--   boolean guards, pattern guards, view patterns, etc) are desugared into
--   this simpler structure.
--   
--   It is parameterized by the values at guard nodes, <tt>n</tt>, and the
--   values at the leaves, <tt>l</tt>. When desugaring, <tt>n</tt> is
--   <a>PmGrd</a> and <tt>l</tt> is the source location. After annotating
--   the <tt>GrdTree</tt>, <tt>n</tt> is a refinement type representing
--   matching values and the <tt>l</tt> is pairs of the aforementioned
--   refinement type and source location.
--   
--   For example:
--   
--   <pre>
--   example : Optional Nat -&gt; Nat
--   example = cases
--     None -&gt; 0
--     Some x
--       | isEven x -&gt; 0
--       | otherwise -&gt; 1
--   </pre>
--   
--   is desugared into
--   
--   <pre>
--   ──┬─ None &lt;- v0 ── srcloc
--     ├─ Some ( v1 :: ##Nat ) &lt;- v0 ── let v2 = isEven v1 ── True &lt;- v2 ── srcloc
--     └─ Some ( v3 :: ##Nat ) &lt;- v0 ── srcloc
--   </pre>
type GrdTree n l = Fix (GrdTreeF n l)
data GrdTreeF n l a

-- | A successful match
LeafF :: l -> GrdTreeF n l a

-- | A constraint of some kind (structural pattern match, boolan guard,
--   etc)
GrdF :: n -> a -> GrdTreeF n l a

-- | A list of alternative matches, tried in order
ForkF :: NonEmpty a -> GrdTreeF n l a
pattern Leaf :: l -> GrdTree n l
pattern Grd :: n -> GrdTree n l -> GrdTree n l
pattern Fork :: NonEmpty (GrdTree n l) -> GrdTree n l
prettyGrdTree :: forall n l s. (ListLike s Char, IsString s) => (n -> Pretty s) -> (l -> Pretty s) -> GrdTree n l -> Pretty s
instance (GHC.Show.Show l, GHC.Show.Show n, GHC.Show.Show a) => GHC.Show.Show (Unison.PatternMatchCoverage.GrdTree.GrdTreeF n l a)
instance GHC.Base.Functor (Unison.PatternMatchCoverage.GrdTree.GrdTreeF n l)

module Unison.PatternMatchCoverage.IntervalSet
data IntervalSet
empty :: IntervalSet
singleton :: (Int, Int) -> IntervalSet
fromList :: [(Int, Int)] -> IntervalSet

-- | insert inclusive bounds interval into set
insert :: (Int, Int) -> IntervalSet -> IntervalSet
delete :: (Int, Int) -> IntervalSet -> IntervalSet
difference :: IntervalSet -> IntervalSet -> IntervalSet
intersection :: IntervalSet -> IntervalSet -> IntervalSet
complement :: IntervalSet -> IntervalSet
null :: IntervalSet -> Bool
member :: Int -> IntervalSet -> Bool
extractSingleton :: IntervalSet -> Maybe Int
intersectIntervals :: (Int, Int) -> (Int, Int) -> Maybe (Int, Int)
map :: ((Int, Int) -> (Int, Int)) -> IntervalSet -> IntervalSet
foldr :: (Int -> Int -> b -> b) -> b -> IntervalSet -> b
lookupMin :: IntervalSet -> Maybe Int
lookupMax :: IntervalSet -> Maybe Int
instance GHC.Classes.Ord Unison.PatternMatchCoverage.IntervalSet.IntervalSet
instance GHC.Classes.Eq Unison.PatternMatchCoverage.IntervalSet.IntervalSet
instance GHC.Show.Show Unison.PatternMatchCoverage.IntervalSet.IntervalSet

module Unison.PatternMatchCoverage.ListPat
data ListPat
Cons :: ListPat
Snoc :: ListPat
Nil :: ListPat
prettyListPat :: ListPat -> Pretty ColorText
instance GHC.Classes.Ord Unison.PatternMatchCoverage.ListPat.ListPat
instance GHC.Classes.Eq Unison.PatternMatchCoverage.ListPat.ListPat
instance GHC.Show.Show Unison.PatternMatchCoverage.ListPat.ListPat

module Unison.PatternMatchCoverage.PmLit
data PmLit
Int :: Int64 -> PmLit
Nat :: Word64 -> PmLit
Boolean :: Bool -> PmLit
Float :: Double -> PmLit
Text :: Text -> PmLit
Char :: Char -> PmLit
prettyPmLit :: IsString s => PmLit -> Pretty s
instance GHC.Classes.Ord Unison.PatternMatchCoverage.PmLit.PmLit
instance GHC.Classes.Eq Unison.PatternMatchCoverage.PmLit.PmLit
instance GHC.Show.Show Unison.PatternMatchCoverage.PmLit.PmLit

module Unison.PatternMatchCoverage.UFMap

-- | A union-find structure. Used by <a>NormalizedConstraints</a> to
--   provide efficient unification.
data UFMap k v
data UFValue k v

-- | This is not the canonical value, lookup k in the map to try again
Indirection :: !k -> UFValue k v

-- | The number of elements in the equivalence class
Canonical :: !Int -> !v -> UFValue k v
empty :: UFMap k v

-- | Lookup the canonical value
lookupCanon :: Ord k => k -> UFMap k v -> Maybe (k, Int, v, UFMap k v)
insert :: Ord k => k -> v -> UFMap k v -> UFMap k v
union :: forall m k v r. (MonadFix m, Ord k) => k -> k -> UFMap k v -> (UFMap k v -> m r) -> (k -> v -> UFMap k v -> m (Maybe r)) -> m (Maybe r)
alterF :: forall f k v. (Functor f, Ord k) => k -> f (Maybe v) -> (k -> Int -> v -> f (UFValue k v)) -> UFMap k v -> f (UFMap k v)
alter :: forall k v. Ord k => k -> Maybe v -> (k -> Int -> v -> UFValue k v) -> UFMap k v -> UFMap k v
keys :: UFMap k v -> [k]

-- | Dump the <tt>UFmap</tt> to a list grouped by equivalence class
toClasses :: forall k v. Ord k => UFMap k v -> [(k, Set k, v)]
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Unison.PatternMatchCoverage.UFMap.UFValue k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.UFMap.UFValue k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.UFMap.UFValue k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Unison.PatternMatchCoverage.UFMap.UFMap k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.UFMap.UFMap k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.UFMap.UFMap k v)
instance GHC.Base.Functor (Unison.PatternMatchCoverage.UFMap.UnionValue k v)

module Unison.PrettyPrintEnv
data PrettyPrintEnv
PrettyPrintEnv :: (Referent -> [(HashQualified Name, HashQualified Name)]) -> (Reference -> [(HashQualified Name, HashQualified Name)]) -> PrettyPrintEnv
[$sel:termNames:PrettyPrintEnv] :: PrettyPrintEnv -> Referent -> [(HashQualified Name, HashQualified Name)]
[$sel:typeNames:PrettyPrintEnv] :: PrettyPrintEnv -> Reference -> [(HashQualified Name, HashQualified Name)]
patterns :: PrettyPrintEnv -> ConstructorReference -> Maybe (HashQualified Name)
patternName :: PrettyPrintEnv -> ConstructorReference -> HashQualified Name
terms :: PrettyPrintEnv -> Referent -> Maybe (HashQualified Name)
types :: PrettyPrintEnv -> Reference -> Maybe (HashQualified Name)
allTermNames :: PrettyPrintEnv -> Referent -> [HashQualified Name]
allTypeNames :: PrettyPrintEnv -> Reference -> [HashQualified Name]
termName :: PrettyPrintEnv -> Referent -> HashQualified Name
typeName :: PrettyPrintEnv -> Reference -> HashQualified Name
termNameOrHashOnly :: PrettyPrintEnv -> Referent -> HashQualified Name
typeNameOrHashOnly :: PrettyPrintEnv -> Reference -> HashQualified Name
termNameOrHashOnlyFq :: PrettyPrintEnv -> Referent -> HashQualified Name
typeNameOrHashOnlyFq :: PrettyPrintEnv -> Reference -> HashQualified Name

-- | Prefer names which share a common prefix with any provided target.
--   
--   Results are sorted according to the longest common prefix found
--   against ANY target.
biasTo :: [Name] -> PrettyPrintEnv -> PrettyPrintEnv

-- | Get a name for a LabeledDependency from the PPE.
labeledRefName :: PrettyPrintEnv -> LabeledDependency -> HashQualified Name
todoHashLength :: Int

-- | Attempts to find a name in primary ppe, falls back to backup ppe only
--   if no names are found. Typically one can use this to shadow global or
--   absolute names with names that are within the current path.
addFallback :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnv

-- | Finds names from both PPEs, if left unbiased the name from the left
--   ppe is preferred.
--   
--   This is distinct from <a>addFallback</a> with respect to biasing; A
--   bias applied to a union might select a name in the right half of the
--   union. Whereas, a bias applied to the result of <a>addFallback</a>
--   will bias within the available names inside the left PPE and will only
--   search in the fallback if there aren't ANY names in the primary ppe.
--   
--   If you don't know the difference, it's likely you want
--   <a>addFallback</a> where you add global names as a fallback for local
--   names.
union :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnv
empty :: PrettyPrintEnv
instance GHC.Generics.Generic Unison.PrettyPrintEnv.PrettyPrintEnv
instance GHC.Show.Show Unison.PrettyPrintEnv.PrettyPrintEnv

module Unison.PatternMatchCoverage.Class

-- | A typeclass for the queries required to perform pattern match coverage
--   checking.
class (Ord loc, Var vt, Var v, MonadFix m) => Pmc vt v loc m | m -> vt v loc

-- | Get the constructors of a type
getConstructors :: Pmc vt v loc m => Type vt loc -> m (EnumeratedConstructors vt v loc)

-- | Get the types of the arguments of a specific constructor
getConstructorVarTypes :: Pmc vt v loc m => Type vt loc -> ConstructorReference -> m [Type vt loc]

-- | Get a fresh variable
fresh :: Pmc vt v loc m => m v
getPrettyPrintEnv :: Pmc vt v loc m => m PrettyPrintEnv
data EnumeratedConstructors vt v loc
ConstructorType :: [(v, ConstructorReference, Type vt loc)] -> EnumeratedConstructors vt v loc
AbilityType :: Type vt loc -> Map ConstructorReference (v, Type vt loc) -> EnumeratedConstructors vt v loc
SequenceType :: [(ListPat, [Type vt loc])] -> EnumeratedConstructors vt v loc
BooleanType :: EnumeratedConstructors vt v loc
OtherType :: EnumeratedConstructors vt v loc
traverseConstructorTypes :: Applicative f => (v -> ConstructorReference -> Type vt loc -> f (Type vt loc)) -> EnumeratedConstructors vt v loc -> f (EnumeratedConstructors vt v loc)
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.Class.EnumeratedConstructors vt v loc)

module Unison.KindInference.Solve.Monad
newtype Solve v loc a
Solve :: (Env -> SolveState v loc -> (a, SolveState v loc)) -> Solve v loc a
[$sel:unSolve:Solve] :: Solve v loc a -> Env -> SolveState v loc -> (a, SolveState v loc)
data Env
Env :: PrettyPrintEnv -> Env
[$sel:prettyPrintEnv:Env] :: Env -> PrettyPrintEnv

-- | The <tt>SolveState</tt> holds all kind constraints gathered for each
--   type. For example, after processing data and effect decls the
--   <tt>typeMap</tt> will hold entries for every decl, and looking up the
--   corresponding <tt>UVar</tt> in <tt>constraints</tt> will return its
--   kind.
--   
--   The other fields, <tt>unifVars</tt> and <tt>newUnifVars</tt>, are
--   relevant when interleaving constraint generation with solving.
--   Constraint generation needs to create fresh unification variables, so
--   it needs the set of bound unification variables from
--   <tt>unifVars</tt>. <tt>newUnifVars</tt> holds the uvars that are
--   candidates for kind defaulting (see <a>defaultUnconstrainedVars</a>).
data SolveState v loc
SolveState :: !Set Symbol -> [UVar v loc] -> !UFMap (UVar v loc) (Descriptor v loc) -> !Map (Type v loc) (NonEmpty (UVar v loc)) -> SolveState v loc
[$sel:unifVars:SolveState] :: SolveState v loc -> !Set Symbol
[$sel:newUnifVars:SolveState] :: SolveState v loc -> [UVar v loc]
[$sel:constraints:SolveState] :: SolveState v loc -> !UFMap (UVar v loc) (Descriptor v loc)
[$sel:typeMap:SolveState] :: SolveState v loc -> !Map (Type v loc) (NonEmpty (UVar v loc))

-- | Constraints associated with a unification variable
data Descriptor v loc
Descriptor :: Maybe (Constraint (UVar v loc) v loc) -> Descriptor v loc
[$sel:descriptorConstraint:Descriptor] :: Descriptor v loc -> Maybe (Constraint (UVar v loc) v loc)
type ConstraintMap v loc = UFMap (UVar v loc) (Descriptor v loc)

-- | Runner for the <tt>Solve</tt> monad
run :: Env -> SolveState v loc -> Solve v loc a -> (a, SolveState v loc)

-- | Initial solve state
emptyState :: SolveState v loc

-- | Lookup the constraints associated with a unification variable
find :: Var v => UVar v loc -> Solve v loc (Maybe (Constraint (UVar v loc) v loc))

-- | Helper for inteleaving constraint generation and solving
genStateL :: Lens' (SolveState v loc) (GenState v loc)

-- | Interleave constraint generation into constraint solving
runGen :: Var v => Gen v loc a -> Solve v loc a

-- | Add a unification variable to the constarint mapping with no
--   constraints. This is done on uvars created during constraint
--   generation to initialize the new uvars (see <a>runGen</a>).
addUnconstrainedVar :: Var v => UVar v loc -> Solve v loc ()
instance Control.Monad.State.Class.MonadState (Unison.KindInference.Solve.Monad.SolveState v loc) (Unison.KindInference.Solve.Monad.Solve v loc)
instance Control.Monad.Reader.Class.MonadReader Unison.KindInference.Solve.Monad.Env (Unison.KindInference.Solve.Monad.Solve v loc)
instance Control.Monad.Fix.MonadFix (Unison.KindInference.Solve.Monad.Solve v loc)
instance GHC.Base.Monad (Unison.KindInference.Solve.Monad.Solve v loc)
instance GHC.Base.Applicative (Unison.KindInference.Solve.Monad.Solve v loc)
instance GHC.Base.Functor (Unison.KindInference.Solve.Monad.Solve v loc)

module Unison.KindInference.Error

-- | Errors that may arise during kind inference
data KindError v loc

-- | A variable is constrained to have an infinite kind
CycleDetected :: loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc

-- | Something of kind * or Effect is applied to an argument
UnexpectedArgument :: loc -> UVar v loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc
ArgumentMismatch :: UVar v loc -> UVar v loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc
ArgumentMismatchArrow :: (loc, Type v loc, Type v loc) -> ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc

-- | Something appeared in an effect list that isn't of kind Effect
EffectListMismatch :: ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc

-- | Generic constraint conflict
ConstraintConflict :: GeneratedConstraint v loc -> ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc
lspLoc :: Semigroup loc => KindError v loc -> loc

-- | Two incompatible constraints on a <tt>UVar</tt>.
data ConstraintConflict v loc
ConstraintConflict' :: UVar v loc -> Constraint (UVar v loc) v loc -> Constraint (UVar v loc) v loc -> ConstraintConflict v loc
[$sel:conflictedVar:ConstraintConflict'] :: ConstraintConflict v loc -> UVar v loc
[$sel:impliedConstraint:ConstraintConflict'] :: ConstraintConflict v loc -> Constraint (UVar v loc) v loc
[$sel:conflictedConstraint:ConstraintConflict'] :: ConstraintConflict v loc -> Constraint (UVar v loc) v loc

-- | Transform generic constraint conflicts into more specific error by
--   examining its <tt>ConstraintContext</tt>.
improveError :: Var v => KindError v loc -> Solve v loc (KindError v loc)
instance GHC.Show.Show (Unison.KindInference.Error.KindError v loc)


module Unison.KindInference.Constraint.Pretty

-- | Pretty print the kind constraint on the given <tt>UVar</tt>.
--   
--   <b>Precondition:</b> The <tt>ConstraintMap</tt> is acyclic.
prettyUVarKind :: Var v => PrettyPrintEnv -> ConstraintMap v loc -> UVar v loc -> Pretty ColorText

-- | Pretty print a <a>Constraint</a>
--   
--   <b>Precondition:</b> The <tt>ConstraintMap</tt> is acyclic.
prettySolvedConstraint :: Var v => PrettyPrintEnv -> ConstraintMap v loc -> Constraint (UVar v loc) v loc -> Pretty ColorText

-- | A pretty printer for cyclic kind constraints on a <tt>UVar</tt>.
--   Expresses the infinite kind by a generating equation.
--   
--   <b>Precondition:</b> The <tt>UVar</tt> has a cyclic constraint.
prettyCyclicUVarKind :: Var v => PrettyPrintEnv -> ConstraintMap v loc -> UVar v loc -> (Pretty ColorText -> Pretty ColorText) -> (Pretty ColorText, Pretty ColorText)

module Unison.KindInference.Error.Pretty

-- | Pretty print a user-facing <tt>KindError</tt>.
prettyKindError :: Var v => (Type v loc -> Pretty ColorText) -> ([(loc, Color)] -> Pretty ColorText) -> Color -> Color -> PrettyPrintEnv -> KindError v loc -> Pretty ColorText

module Unison.PrettyPrintEnv.FQN
type Imports = Map Name Suffix
type Prefix = [Text]
type Suffix = Text
elideFQN :: Imports -> HashQualified Name -> HashQualified Name

module Unison.PrettyPrintEnv.MonadPretty
type MonadPretty v m = (Var v, MonadReader (PrettyPrintEnv, Set v) m)
getPPE :: MonadPretty v m => m PrettyPrintEnv

-- | Run a computation with a modified PrettyPrintEnv, restoring the
--   original
withPPE :: MonadPretty v m => PrettyPrintEnv -> m a -> m a
applyPPE :: MonadPretty v m => (PrettyPrintEnv -> a) -> m a
applyPPE2 :: MonadPretty v m => (PrettyPrintEnv -> a -> b) -> a -> m b
applyPPE3 :: MonadPretty v m => (PrettyPrintEnv -> a -> b -> c) -> a -> b -> m c

-- | Run a computation with a modified PrettyPrintEnv, restoring the
--   original
modifyPPE :: MonadPretty v m => (PrettyPrintEnv -> PrettyPrintEnv) -> m a -> m a
modifyTypeVars :: MonadPretty v m => (Set v -> Set v) -> m a -> m a

-- | Add type variables to the set of variables that need to be avoided
addTypeVars :: MonadPretty v m => [v] -> m a -> m a

-- | Check if a list of type variables contains any variables that need to
--   be avoided
willCapture :: MonadPretty v m => [v] -> m Bool
runPretty :: Var v => PrettyPrintEnv -> Reader (PrettyPrintEnv, Set v) a -> a

module Unison.PrettyPrintEnv.Names

-- | A "namer" associates a set of (possibly hash-qualified) names with a
--   referent / type reference.
data Namer
Namer :: (Referent -> Set (HashQualified Name)) -> (TypeReference -> Set (HashQualified Name)) -> Namer
[$sel:nameTerm:Namer] :: Namer -> Referent -> Set (HashQualified Name)
[$sel:nameType:Namer] :: Namer -> TypeReference -> Set (HashQualified Name)

-- | Make a "namer" out of a collection of names, respecting conflicted
--   names. That is, if references #foo and #bar are both associated with
--   name "baz", then the returned namer maps #foo too "baz"#foo and #bar
--   to "baz"#bar, but otherwise if a reference #qux has a single name
--   "qux", then the returned namer maps #qux to "qux" (not "qux"#qux).
hqNamer :: Int -> Names -> Namer

-- | Make a "namer" out of a collection of names, ignoring conflicted
--   names. That is, if references #foo and #bar are both associated with
--   name "baz", then the returned namer maps #foo too "baz" (not
--   "baz"#foo) and #bar to "baz" (not "baz"#bar).
namer :: Names -> Namer
data Suffixifier
dontSuffixify :: Suffixifier
suffixifyByHash :: Names -> Suffixifier
suffixifyByName :: Names -> Suffixifier
makePPE :: Namer -> Suffixifier -> PrettyPrintEnv
makeTermNames :: Namer -> Suffixifier -> Referent -> [(HashQualified Name, HashQualified Name)]
makeTypeNames :: Namer -> Suffixifier -> TypeReference -> [(HashQualified Name, HashQualified Name)]

module Unison.PrettyPrintEnvDecl
data PrettyPrintEnvDecl
PrettyPrintEnvDecl :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnvDecl
[$sel:unsuffixifiedPPE:PrettyPrintEnvDecl] :: PrettyPrintEnvDecl -> PrettyPrintEnv
[$sel:suffixifiedPPE:PrettyPrintEnvDecl] :: PrettyPrintEnvDecl -> PrettyPrintEnv

-- | Lifts <a>biasTo</a> over a PrettyPrintEnvDecl
biasTo :: [Name] -> PrettyPrintEnvDecl -> PrettyPrintEnvDecl
empty :: PrettyPrintEnvDecl

-- | Will use names from the fallback pped if no names were found in the
--   primary. <tt>addFallback primary fallback</tt>
addFallback :: PrettyPrintEnvDecl -> PrettyPrintEnvDecl -> PrettyPrintEnvDecl
instance GHC.Show.Show Unison.PrettyPrintEnvDecl.PrettyPrintEnvDecl
instance GHC.Generics.Generic Unison.PrettyPrintEnvDecl.PrettyPrintEnvDecl

module Unison.PrettyPrintEnv.Util
declarationPPE :: PrettyPrintEnvDecl -> Reference -> PrettyPrintEnv
declarationPPEDecl :: PrettyPrintEnvDecl -> Reference -> PrettyPrintEnvDecl

module Unison.PrettyPrintEnvDecl.Names
makePPED :: Namer -> Suffixifier -> PrettyPrintEnvDecl

module Unison.Project.Util

-- | Get the path that a project is stored at. Users aren't supposed to go
--   here.
--   
--   <pre>
--   &gt;&gt;&gt; projectPath "ABCD"
--   .__projects._ABCD
--   </pre>
projectPath :: ProjectId -> Absolute

-- | Get the path that a project's branches are stored at. Users aren't
--   supposed to go here.
--   
--   <pre>
--   &gt;&gt;&gt; projectBranchesPath "ABCD"
--   .__projects._ABCD.branches
--   </pre>
projectBranchesPath :: ProjectId -> Absolute

-- | Get the path that a branch is stored at. Users aren't supposed to go
--   here.
--   
--   <pre>
--   &gt;&gt;&gt; projectBranchPath ProjectAndBranch { project = "ABCD", branch = "DEFG" }
--   .__projects._ABCD.branches._DEFG
--   </pre>
projectBranchPath :: ProjectAndBranch ProjectId ProjectBranchId -> Absolute

-- | Get the name segment that a branch is stored at.
--   
--   <pre>
--   &gt;&gt;&gt; projectBranchSegment "DEFG"
--   "_DEFG"
--   </pre>
projectBranchSegment :: ProjectBranchId -> NameSegment

-- | The prism between paths like
--   
--   <pre>
--   .__projects._XX_XX
--   </pre>
--   
--   and the project id
--   
--   <pre>
--   XX-XX
--   </pre>
projectPathPrism :: Prism' Absolute ProjectId

-- | The prism between paths like
--   
--   <pre>
--   .__projects._XX_XX.branches._YY_YY.foo.bar
--   </pre>
--   
--   and the <tt>(project id, branch id, path)</tt> triple
--   
--   <pre>
--   (XX-XX, YY-YY, foo.bar)
--   </pre>
projectBranchPathPrism :: Prism' Absolute (ProjectAndBranch ProjectId ProjectBranchId, Path)
projectContextFromPath :: Absolute -> ProjectContext
pattern UUIDNameSegment :: UUID -> NameSegment

-- | The project information about the current path. NOTE: if the user has
--   cd'd into the project storage area but NOT into a branch, (where they
--   shouldn't ever be), this will result in a LooseCodePath.
data ProjectContext
LooseCodePath :: Absolute -> ProjectContext
ProjectBranchPath :: ProjectId -> ProjectBranchId -> Path -> ProjectContext
pattern ProjectsNameSegment :: NameSegment
pattern BranchesNameSegment :: NameSegment
instance GHC.Show.Show Unison.Project.Util.ProjectContext
instance GHC.Classes.Eq Unison.Project.Util.ProjectContext

module Unison.Runtime.Array

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length and
--   potentially uses it to construct the structure <tt>l</tt> more
--   efficiently compared to <a>fromList</a>. If the given number does not
--   equal to the input list's length the behaviour of <a>fromListN</a> is
--   not specified.
--   
--   <pre>
--   fromListN (length xs) xs == fromList xs
--   </pre>
fromListN :: IsList l => Int -> [Item l] -> l

-- | A boxed, unlifted datatype representing a region of raw memory in the
--   garbage-collected heap, which is not scanned for pointers during
--   garbage collection.
--   
--   It is created by freezing a 'MutableByteArray#' with
--   'unsafeFreezeByteArray#'. Freezing is essentially a no-op, as
--   MutableByteArray# and ByteArray# share the same heap structure under
--   the hood.
--   
--   The immutable and mutable variants are commonly used for scenarios
--   requiring high-performance data structures, like Text, Primitive
--   Vector, Unboxed Array, and ShortByteString.
--   
--   Another application of fundamental importance is 'Integer', which is
--   backed by 'ByteArray#'.
--   
--   The representation on the heap of a Byte Array is:
--   
--   <pre>
--   +------------+-----------------+-----------------------+
--   |            |                 |                       |
--   |   HEADER   | SIZE (in bytes) |       PAYLOAD         |
--   |            |                 |                       |
--   +------------+-----------------+-----------------------+
--   </pre>
--   
--   To obtain a pointer to actual payload (e.g., for FFI purposes) use
--   'byteArrayContents#' or 'mutableByteArrayContents#'.
--   
--   Alternatively, enabling the UnliftedFFITypes extension allows to
--   mention 'ByteArray#' and 'MutableByteArray#' in FFI type signatures
--   directly.
data ByteArray# :: UnliftedType

-- | A mutable ByteAray#. It can be created in three ways:
--   
--   <ul>
--   <li>'newByteArray#': Create an unpinned array.</li>
--   <li>'newPinnedByteArray#': This will create a pinned array,</li>
--   <li>'newAlignedPinnedByteArray#': This will create a pinned array,
--   with a custom alignment.</li>
--   </ul>
--   
--   Unpinned arrays can be moved around during garbage collection, so you
--   must not store or pass pointers to these values if there is a chance
--   for the garbage collector to kick in. That said, even unpinned arrays
--   can be passed to unsafe FFI calls, because no garbage collection
--   happens during these unsafe calls (see <a>Guaranteed Call Safety</a>
--   in the GHC Manual). For safe FFI calls, byte arrays must be not only
--   pinned, but also kept alive by means of the keepAlive# function for
--   the duration of a call (that's because garbage collection cannot move
--   a pinned array, but is free to scrap it altogether).
data MutableByteArray# a :: UnliftedType

-- | Mutable byte arrays associated with a primitive state token.
data MutableByteArray s
MutableByteArray :: MutableByteArray# s -> MutableByteArray s

-- | Mutable boxed arrays associated with a primitive state token.
data MutableArray s a
MutableArray :: MutableArray# s a -> MutableArray s a
[marray#] :: MutableArray s a -> MutableArray# s a

-- | Boxed arrays.
data Array a
Array :: Array# a -> Array a
[array#] :: Array a -> Array# a

-- | The number of elements in an immutable array.
sizeofArray :: Array a -> Int

-- | The number of elements in a mutable array.
sizeofMutableArray :: MutableArray s a -> Int

-- | Create a new mutable array of the specified size and initialise all
--   elements with the given value.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newArray :: PrimMonad m => Int -> a -> m (MutableArray (PrimState m) a)

-- | Read a value from the immutable array at the given index.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArray :: Array a -> Int -> a

-- | Read a value from the immutable array at the given index, returning
--   the result in an unboxed unary tuple. This is currently used to
--   implement folds.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArray## :: Array a -> Int -> (# a #)

-- | Monadically read a value from the immutable array at the given index.
--   This allows us to be strict in the array while remaining lazy in the
--   read element which is very useful for collective operations. Suppose
--   we want to copy an array. We could do something like this:
--   
--   <pre>
--   copy marr arr ... = do ...
--                          writeArray marr i (indexArray arr i) ...
--                          ...
--   </pre>
--   
--   But since the arrays are lazy, the calls to <a>indexArray</a> will not
--   be evaluated. Rather, <tt>marr</tt> will be filled with thunks each of
--   which would retain a reference to <tt>arr</tt>. This is definitely not
--   what we want!
--   
--   With <a>indexArrayM</a>, we can instead write
--   
--   <pre>
--   copy marr arr ... = do ...
--                          x &lt;- indexArrayM arr i
--                          writeArray marr i x
--                          ...
--   </pre>
--   
--   Now, indexing is executed immediately although the returned element is
--   still not evaluated.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArrayM :: Monad m => Array a -> Int -> m a

-- | Create an immutable copy of a slice of an array.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezeArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> Int -> m (Array a)

-- | Convert a mutable array to an immutable one without copying. The array
--   should not be modified after the conversion.
unsafeFreezeArray :: PrimMonad m => MutableArray (PrimState m) a -> m (Array a)

-- | Create a mutable array from a slice of an immutable array.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawArray :: PrimMonad m => Array a -> Int -> Int -> m (MutableArray (PrimState m) a)

-- | Convert an immutable array to an mutable one without copying. The
--   immutable array should not be used after the conversion.
unsafeThawArray :: PrimMonad m => Array a -> m (MutableArray (PrimState m) a)

-- | Check whether the two arrays refer to the same memory block.
sameMutableArray :: MutableArray s a -> MutableArray s a -> Bool

-- | Return a newly allocated <a>Array</a> with the specified subrange of
--   the provided <a>Array</a>.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
cloneArray :: Array a -> Int -> Int -> Array a

-- | The empty <a>Array</a>.
emptyArray :: Array a

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runArray m = runST $ m &gt;&gt;= unsafeFreezeArray
--   </pre>
runArray :: (forall s. () => ST s (MutableArray s a)) -> Array a

-- | Create an array of the given size with a default value, apply the
--   monadic function and freeze the result. If the size is 0, return
--   <a>emptyArray</a> (rather than a new copy thereof).
--   
--   <pre>
--   createArray 0 _ _ = emptyArray
--   createArray n x f = runArray $ do
--     mary &lt;- newArray n x
--     f mary
--     pure mary
--   </pre>
createArray :: Int -> a -> (forall s. () => MutableArray s a -> ST s ()) -> Array a

-- | This is the fastest, most straightforward way to traverse an array,
--   but it only works correctly with a sufficiently "affine"
--   <a>PrimMonad</a> instance. In particular, it must only produce
--   <i>one</i> result array. <a>ListT</a>-transformed monads, for example,
--   will not work right at all.
traverseArrayP :: PrimMonad m => (a -> m b) -> Array a -> m (Array b)

-- | Strict map over the elements of the array.
mapArray' :: (a -> b) -> Array a -> Array b

-- | Create an array from a list of a known length. If the length of the
--   list does not match the given length, this throws an exception.
arrayFromListN :: Int -> [a] -> Array a

-- | Create an array from a list.
arrayFromList :: [a] -> Array a

-- | Byte arrays.
data ByteArray
ByteArray :: ByteArray# -> ByteArray

-- | Create a new mutable byte array of the specified size in bytes.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newByteArray :: PrimMonad m => Int -> m (MutableByteArray (PrimState m))

-- | Create a <i>pinned</i> byte array of the specified size in bytes. The
--   garbage collector is guaranteed not to move it.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newPinnedByteArray :: PrimMonad m => Int -> m (MutableByteArray (PrimState m))

-- | Create a <i>pinned</i> byte array of the specified size in bytes and
--   with the given alignment. The garbage collector is guaranteed not to
--   move it.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newAlignedPinnedByteArray :: PrimMonad m => Int -> Int -> m (MutableByteArray (PrimState m))

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <a>newPinnedByteArray</a> or
--   <a>newAlignedPinnedByteArray</a>.
byteArrayContents :: ByteArray -> Ptr Word8

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <a>newPinnedByteArray</a> or
--   <a>newAlignedPinnedByteArray</a>.
mutableByteArrayContents :: MutableByteArray s -> Ptr Word8

-- | Check if the two arrays refer to the same memory block.
sameMutableByteArray :: MutableByteArray s -> MutableByteArray s -> Bool

-- | Resize a mutable byte array. The new size is given in bytes.
--   
--   This will either resize the array in-place or, if not possible,
--   allocate the contents into a new, unpinned array and copy the original
--   array's contents.
--   
--   To avoid undefined behaviour, the original <a>MutableByteArray</a>
--   shall not be accessed anymore after a <a>resizeMutableByteArray</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutableByteArray</a> in case a new <a>MutableByteArray</a> had to
--   be allocated.
resizeMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m (MutableByteArray (PrimState m))

-- | Get the size of a byte array in bytes. Unlike
--   <a>sizeofMutableByteArray</a>, this function ensures sequencing in the
--   presence of resizing.
getSizeofMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> m Int

-- | Create an immutable copy of a slice of a byte array. The offset and
--   length are given in bytes.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezeByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> m ByteArray

-- | Create a mutable byte array from a slice of an immutable byte array.
--   The offset and length are given in bytes.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawByteArray :: PrimMonad m => ByteArray -> Int -> Int -> m (MutableByteArray (PrimState m))

-- | Convert a mutable byte array to an immutable one without copying. The
--   array should not be modified after the conversion.
unsafeFreezeByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> m ByteArray

-- | Convert an immutable byte array to a mutable one without copying. The
--   original array should not be used after the conversion.
unsafeThawByteArray :: PrimMonad m => ByteArray -> m (MutableByteArray (PrimState m))

-- | Size of the byte array in bytes.
sizeofByteArray :: ByteArray -> Int

-- | Size of the mutable byte array in bytes. This function's behavior is
--   undefined if <a>resizeMutableByteArray</a> is ever called on the
--   mutable byte array given as the argument. Consequently, use of this
--   function is discouraged. Prefer <a>getSizeofMutableByteArray</a>,
--   which ensures correct sequencing in the presence of resizing.
sizeofMutableByteArray :: MutableByteArray s -> Int

-- | Shrink a mutable byte array. The new size is given in bytes. It must
--   be smaller than the old size. The array will be resized in place.
shrinkMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m ()

-- | Check whether or not the byte array is pinned. Pinned byte arrays
--   cannot be moved by the garbage collector. It is safe to use
--   <a>byteArrayContents</a> on such byte arrays. This function is only
--   available when compiling with GHC 8.2 or newer.
isByteArrayPinned :: ByteArray -> Bool

-- | Check whether or not the mutable byte array is pinned. This function
--   is only available when compiling with GHC 8.2 or newer.
isMutableByteArrayPinned :: MutableByteArray s -> Bool

-- | Right-fold over the elements of a <a>ByteArray</a>.
foldrByteArray :: Prim a => (a -> b -> b) -> b -> ByteArray -> b

-- | Create a <a>ByteArray</a> from a list.
--   
--   <pre>
--   byteArrayFromList xs = <a>byteArrayFromListN</a> (length xs) xs
--   </pre>
byteArrayFromList :: Prim a => [a] -> ByteArray

-- | Create a <a>ByteArray</a> from a list of a known length. If the length
--   of the list does not match the given length, this throws an exception.
byteArrayFromListN :: Prim a => Int -> [a] -> ByteArray

-- | Copy a slice of a byte array to an unmanaged pointer address. These
--   must not overlap. The offset and length are given in elements, not in
--   bytes.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyByteArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> ByteArray -> Int -> Int -> m ()

-- | Copy a slice of a mutable byte array to an unmanaged pointer address.
--   These must not overlap. The offset and length are given in elements,
--   not in bytes.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutableByteArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Copy a slice of a byte array to an unmanaged address. These must not
--   overlap.
--   
--   Note: This function is just <a>copyByteArrayToPtr</a> where <tt>a</tt>
--   is <a>Word8</a>.
copyByteArrayToAddr :: PrimMonad m => Ptr Word8 -> ByteArray -> Int -> Int -> m ()

-- | Copy a slice of a mutable byte array to an unmanaged address. These
--   must not overlap.
--   
--   Note: This function is just <a>copyMutableByteArrayToPtr</a> where
--   <tt>a</tt> is <a>Word8</a>.
copyMutableByteArrayToAddr :: PrimMonad m => Ptr Word8 -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Fill a slice of a mutable byte array with a value. The offset and
--   length are given in elements of type <tt>a</tt> rather than in bytes.
--   
--   <i>Note:</i> this function does not do bounds checking.
setByteArray :: (Prim a, PrimMonad m) => MutableByteArray (PrimState m) -> Int -> Int -> a -> m ()

-- | Fill a slice of a mutable byte array with a byte.
--   
--   <i>Note:</i> this function does not do bounds checking.
fillByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> Word8 -> m ()

-- | Lexicographic comparison of equal-length slices into two byte arrays.
--   This wraps the <tt>compareByteArrays#</tt> primop, which wraps
--   <tt>memcmp</tt>.
compareByteArrays :: ByteArray -> Int -> ByteArray -> Int -> Int -> Ordering

-- | The empty <a>ByteArray</a>.
emptyByteArray :: ByteArray

-- | Return a newly allocated array with the specified subrange of the
--   provided array. The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
cloneByteArray :: ByteArray -> Int -> Int -> ByteArray

-- | Return a newly allocated mutable array with the specified subrange of
--   the provided mutable array. The provided mutable array should contain
--   the full subrange specified by the two Ints, but this is not checked.
cloneMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> m (MutableByteArray (PrimState m))

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runByteArray m = runST $ m &gt;&gt;= unsafeFreezeByteArray
--   </pre>
runByteArray :: (forall s. () => ST s (MutableByteArray s)) -> ByteArray

-- | Mutable primitive arrays associated with a primitive state token.
--   These can be written to and read from in a monadic context that
--   supports sequencing, such as <a>IO</a> or <a>ST</a>. Typically, a
--   mutable primitive array will be built and then converted to an
--   immutable primitive array using <a>unsafeFreezePrimArray</a>. However,
--   it is also acceptable to simply discard a mutable primitive array
--   since it lives in managed memory and will be garbage collected when no
--   longer referenced.
data MutablePrimArray s a
MutablePrimArray :: MutableByteArray# s -> MutablePrimArray s a

-- | Arrays of unboxed elements. This accepts types like <a>Double</a>,
--   <a>Char</a>, <a>Int</a> and <a>Word</a>, as well as their fixed-length
--   variants (<tt>Word8</tt>, <tt>Word16</tt>, etc.). Since the elements
--   are unboxed, a <a>PrimArray</a> is strict in its elements. This
--   differs from the behavior of <a>Array</a>, which is lazy in its
--   elements.
data PrimArray a
PrimArray :: ByteArray# -> PrimArray a

-- | Create a <a>PrimArray</a> from a list.
--   
--   <pre>
--   primArrayFromList vs = <a>primArrayFromListN</a> (length vs) vs
--   </pre>
primArrayFromList :: Prim a => [a] -> PrimArray a

-- | Create a <a>PrimArray</a> from a list of a known length. If the length
--   of the list does not match the given length, this throws an exception.
primArrayFromListN :: Prim a => Int -> [a] -> PrimArray a

-- | Convert a <a>PrimArray</a> to a list.
primArrayToList :: Prim a => PrimArray a -> [a]

-- | The empty <a>PrimArray</a>.
emptyPrimArray :: PrimArray a

-- | Create a new mutable primitive array of the given length. The
--   underlying memory is left uninitialized.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Resize a mutable primitive array. The new size is given in elements.
--   
--   This will either resize the array in-place or, if not possible,
--   allocate the contents into a new, unpinned array and copy the original
--   array's contents.
--   
--   To avoid undefined behaviour, the original <a>MutablePrimArray</a>
--   shall not be accessed anymore after a <a>resizeMutablePrimArray</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutablePrimArray</a> in case a new <a>MutablePrimArray</a> had to
--   be allocated.
resizeMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Shrink a mutable primitive array. The new size is given in elements.
--   It must be smaller than the old size. The array will be resized in
--   place.
shrinkMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> m ()

-- | Copy part of a mutable array into another mutable array. In the case
--   that the destination and source arrays are the same, the regions may
--   overlap.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> MutablePrimArray (PrimState m) a -> Int -> Int -> m ()

-- | Copy part of an array into another mutable array.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> PrimArray a -> Int -> Int -> m ()

-- | Copy a slice of an immutable primitive array to a pointer. The offset
--   and length are given in elements of type <tt>a</tt>. This function
--   assumes that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPrimArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> PrimArray a -> Int -> Int -> m ()

-- | Copy a slice of a mutable primitive array to a pointer. The offset and
--   length are given in elements of type <tt>a</tt>. This function assumes
--   that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutablePrimArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> MutablePrimArray (PrimState m) a -> Int -> Int -> m ()

-- | Fill a slice of a mutable primitive array with a value.
--   
--   <i>Note:</i> this function does not do bounds checking.
setPrimArray :: (Prim a, PrimMonad m) => MutablePrimArray (PrimState m) a -> Int -> Int -> a -> m ()

-- | Get the size of a mutable primitive array in elements. Unlike
--   <a>sizeofMutablePrimArray</a>, this function ensures sequencing in the
--   presence of resizing.
getSizeofMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> m Int

-- | Size of the mutable primitive array in elements. This function shall
--   not be used on primitive arrays that are an argument to or a result of
--   <a>resizeMutablePrimArray</a> or <a>shrinkMutablePrimArray</a>.
sizeofMutablePrimArray :: forall s a. Prim a => MutablePrimArray s a -> Int

-- | Check if the two arrays refer to the same memory block.
sameMutablePrimArray :: MutablePrimArray s a -> MutablePrimArray s a -> Bool

-- | Create an immutable copy of a slice of a primitive array. The offset
--   and length are given in elements.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Int -> m (PrimArray a)

-- | Create a mutable primitive array from a slice of an immutable
--   primitive array. The offset and length are given in elements.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawPrimArray :: (PrimMonad m, Prim a) => PrimArray a -> Int -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Convert a mutable primitive array to an immutable one without copying.
--   The array should not be modified after the conversion.
unsafeFreezePrimArray :: PrimMonad m => MutablePrimArray (PrimState m) a -> m (PrimArray a)

-- | Convert an immutable array to a mutable one without copying. The
--   original array should not be used after the conversion.
unsafeThawPrimArray :: PrimMonad m => PrimArray a -> m (MutablePrimArray (PrimState m) a)

-- | Get the size, in elements, of the primitive array.
sizeofPrimArray :: Prim a => PrimArray a -> Int

-- | Check whether or not the primitive array is pinned. Pinned primitive
--   arrays cannot be moved by the garbage collector. It is safe to use
--   <a>primArrayContents</a> on such arrays. This function is only
--   available when compiling with GHC 8.2 or newer.
isPrimArrayPinned :: PrimArray a -> Bool

-- | Check whether or not the mutable primitive array is pinned. This
--   function is only available when compiling with GHC 8.2 or newer.
isMutablePrimArrayPinned :: MutablePrimArray s a -> Bool

-- | Lazy right-associated fold over the elements of a <a>PrimArray</a>.
foldrPrimArray :: Prim a => (a -> b -> b) -> b -> PrimArray a -> b

-- | Strict right-associated fold over the elements of a <a>PrimArray</a>.
foldrPrimArray' :: Prim a => (a -> b -> b) -> b -> PrimArray a -> b

-- | Lazy left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArray :: Prim a => (b -> a -> b) -> b -> PrimArray a -> b

-- | Strict left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArray' :: Prim a => (b -> a -> b) -> b -> PrimArray a -> b

-- | Strict left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArrayM' :: (Prim a, Monad m) => (b -> a -> m b) -> b -> PrimArray a -> m b

-- | Traverse a primitive array. The traversal forces the resulting values
--   and writes them to the new primitive array as it performs the monadic
--   effects. Consequently:
--   
--   <pre>
--   &gt;&gt;&gt; traversePrimArrayP (\x -&gt; print x $&gt; bool x undefined (x == 2)) (fromList [1, 2, 3 :: Int])
--   1
--   2
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   In many situations, <a>traversePrimArrayP</a> can replace
--   <a>traversePrimArray</a>, changing the strictness characteristics of
--   the traversal but typically improving the performance. Consider the
--   following short-circuiting traversal:
--   
--   <pre>
--   incrPositiveA :: PrimArray Int -&gt; Maybe (PrimArray Int)
--   incrPositiveA xs = traversePrimArray (\x -&gt; bool Nothing (Just (x + 1)) (x &gt; 0)) xs
--   </pre>
--   
--   This can be rewritten using <a>traversePrimArrayP</a>. To do this, we
--   must change the traversal context to <tt>MaybeT (ST s)</tt>, which has
--   a <a>PrimMonad</a> instance:
--   
--   <pre>
--   incrPositiveB :: PrimArray Int -&gt; Maybe (PrimArray Int)
--   incrPositiveB xs = runST $ runMaybeT $ traversePrimArrayP
--     (\x -&gt; bool (MaybeT (return Nothing)) (MaybeT (return (Just (x + 1)))) (x &gt; 0))
--     xs
--   </pre>
--   
--   Benchmarks demonstrate that the second implementation runs 150 times
--   faster than the first. It also results in fewer allocations.
traversePrimArrayP :: (PrimMonad m, Prim a, Prim b) => (a -> m b) -> PrimArray a -> m (PrimArray b)

-- | Filter the primitive array, keeping the elements for which the monadic
--   predicate evaluates to true.
filterPrimArrayP :: (PrimMonad m, Prim a) => (a -> m Bool) -> PrimArray a -> m (PrimArray a)

-- | Map over the primitive array, keeping the elements for which the
--   monadic predicate provides a <a>Just</a>.
mapMaybePrimArrayP :: (PrimMonad m, Prim a, Prim b) => (a -> m (Maybe b)) -> PrimArray a -> m (PrimArray b)

-- | Generate a primitive array by evaluating the monadic generator
--   function at each index.
generatePrimArrayP :: (PrimMonad m, Prim a) => Int -> (Int -> m a) -> m (PrimArray a)

-- | Execute the monadic action the given number of times and store the
--   results in a primitive array.
replicatePrimArrayP :: (PrimMonad m, Prim a) => Int -> m a -> m (PrimArray a)

-- | Map over the elements of a primitive array.
mapPrimArray :: (Prim a, Prim b) => (a -> b) -> PrimArray a -> PrimArray b

-- | Indexed map over the elements of a primitive array.
imapPrimArray :: (Prim a, Prim b) => (Int -> a -> b) -> PrimArray a -> PrimArray b

-- | Filter elements of a primitive array according to a predicate.
filterPrimArray :: Prim a => (a -> Bool) -> PrimArray a -> PrimArray a

-- | Filter the primitive array, keeping the elements for which the monadic
--   predicate evaluates true.
filterPrimArrayA :: (Applicative f, Prim a) => (a -> f Bool) -> PrimArray a -> f (PrimArray a)

-- | Map over the primitive array, keeping the elements for which the
--   applicative predicate provides a <a>Just</a>.
mapMaybePrimArrayA :: (Applicative f, Prim a, Prim b) => (a -> f (Maybe b)) -> PrimArray a -> f (PrimArray b)

-- | Map over a primitive array, optionally discarding some elements. This
--   has the same behavior as <tt>Data.Maybe.mapMaybe</tt>.
mapMaybePrimArray :: (Prim a, Prim b) => (a -> Maybe b) -> PrimArray a -> PrimArray b

-- | Traverse a primitive array. The traversal performs all of the
--   applicative effects <i>before</i> forcing the resulting values and
--   writing them to the new primitive array. Consequently:
--   
--   <pre>
--   &gt;&gt;&gt; traversePrimArray (\x -&gt; print x $&gt; bool x undefined (x == 2)) (fromList [1, 2, 3 :: Int])
--   1
--   2
--   3
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   The function <a>traversePrimArrayP</a> always outperforms this
--   function, but it requires a <a>PrimMonad</a> constraint, and it forces
--   the values as it performs the effects.
traversePrimArray :: (Applicative f, Prim a, Prim b) => (a -> f b) -> PrimArray a -> f (PrimArray b)

-- | Traverse a primitive array with the index of each element.
itraversePrimArray :: (Applicative f, Prim a, Prim b) => (Int -> a -> f b) -> PrimArray a -> f (PrimArray b)

-- | Traverse a primitive array with the indices. The traversal forces the
--   resulting values and writes them to the new primitive array as it
--   performs the monadic effects.
itraversePrimArrayP :: (Prim a, Prim b, PrimMonad m) => (Int -> a -> m b) -> PrimArray a -> m (PrimArray b)

-- | Generate a primitive array.
generatePrimArray :: Prim a => Int -> (Int -> a) -> PrimArray a

-- | Create a primitive array by copying the element the given number of
--   times.
replicatePrimArray :: Prim a => Int -> a -> PrimArray a

-- | Generate a primitive array by evaluating the applicative generator
--   function at each index.
generatePrimArrayA :: (Applicative f, Prim a) => Int -> (Int -> f a) -> f (PrimArray a)

-- | Execute the applicative action the given number of times and store the
--   results in a <a>PrimArray</a>.
replicatePrimArrayA :: (Applicative f, Prim a) => Int -> f a -> f (PrimArray a)

-- | Traverse the primitive array, discarding the results. There is no
--   <a>PrimMonad</a> variant of this function, since it would not provide
--   any performance benefit.
traversePrimArray_ :: (Applicative f, Prim a) => (a -> f b) -> PrimArray a -> f ()

-- | Traverse the primitive array with the indices, discarding the results.
--   There is no <a>PrimMonad</a> variant of this function, since it would
--   not provide any performance benefit.
itraversePrimArray_ :: (Applicative f, Prim a) => (Int -> a -> f b) -> PrimArray a -> f ()

-- | Create a <i>pinned</i> primitive array of the specified size (in
--   elements). The garbage collector is guaranteed not to move it.
newPinnedPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Create a <i>pinned</i> primitive array of the specified size (in
--   elements) and with the alignment given by its <a>Prim</a> instance.
--   The garbage collector is guaranteed not to move it.
newAlignedPinnedPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> prim arrays allocated by <tt>newPinnedByteArray</tt> or
--   <tt>newAlignedPinnedByteArray</tt>.
primArrayContents :: PrimArray a -> Ptr a

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <tt>newPinnedByteArray</tt> or
--   <tt>newAlignedPinnedByteArray</tt>.
mutablePrimArrayContents :: MutablePrimArray s a -> Ptr a

-- | Return a newly allocated array with the specified subrange of the
--   provided array. The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
clonePrimArray :: Prim a => PrimArray a -> Int -> Int -> PrimArray a

-- | Return a newly allocated mutable array with the specified subrange of
--   the provided mutable array. The provided mutable array should contain
--   the full subrange specified by the two Ints, but this is not checked.
cloneMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runPrimArray m = runST $ m &gt;&gt;= unsafeFreezePrimArray
--   </pre>
runPrimArray :: (forall s. () => ST s (MutablePrimArray s a)) -> PrimArray a
byteArrayToList :: ByteArray -> [Word8]
readArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> m a
writeArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> a -> m ()
copyArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> Array a -> Int -> Int -> m ()
copyMutableArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> MutableArray (PrimState m) a -> Int -> Int -> m ()
cloneMutableArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> Int -> m (MutableArray (PrimState m) a)
readByteArray :: forall a m. CheckCtx => PrimMonad m => Prim a => MutableByteArray (PrimState m) -> Int -> m a
writeByteArray :: forall a m. CheckCtx => PrimMonad m => Prim a => MutableByteArray (PrimState m) -> Int -> a -> m ()
indexByteArray :: forall a. CheckCtx => Prim a => ByteArray -> Int -> a
copyByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> ByteArray -> Int -> Int -> m ()
copyMutableByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> MutableByteArray (PrimState m) -> Int -> Int -> m ()
moveByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> MutableByteArray (PrimState m) -> Int -> Int -> m ()
readPrimArray :: CheckCtx => PrimMonad m => Prim a => MutablePrimArray (PrimState m) a -> Int -> m a
writePrimArray :: CheckCtx => PrimMonad m => Prim a => MutablePrimArray (PrimState m) a -> Int -> a -> m ()
indexPrimArray :: CheckCtx => Prim a => PrimArray a -> Int -> a

module Unison.Runtime.SparseVector
data SparseVector bits a
SparseVector :: !bits -> !Vector a -> SparseVector bits a
[$sel:indices:SparseVector] :: SparseVector bits a -> !bits
[$sel:elements:SparseVector] :: SparseVector bits a -> !Vector a
map :: (Unbox a, Unbox b) => (a -> b) -> SparseVector bits a -> SparseVector bits b
mask :: forall a bits. (Unbox a, FiniteBits bits) => bits -> SparseVector bits a -> SparseVector bits a
zipWith :: (Unbox a, Unbox b, Unbox c, FiniteBits bits) => (a -> b -> c) -> SparseVector bits a -> SparseVector bits b -> SparseVector bits c
_1 :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> SparseVector bits a
_2 :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> SparseVector bits b
unzip :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> (SparseVector bits a, SparseVector bits b)
choose :: (FiniteBits bits, Unbox a) => bits -> SparseVector bits a -> SparseVector bits a -> SparseVector bits a
merge :: forall a bits. (FiniteBits bits, Unbox a) => SparseVector bits a -> SparseVector bits a -> SparseVector bits a
eq :: a -> a -> Bool

module Unison.Runtime.Vector
data Vec a
[Scalar] :: a -> Vec a
[Vec] :: Unbox a => Vector a -> Vec a
[Pair] :: Vec a -> Vec b -> Vec (a, b)
[Choose] :: Vec Bool -> Vec a -> Vec a -> Vec a
[Mux] :: Vec Nat -> Vec (Vec a) -> Vec a
type Nat = Word64
mu :: Vec a -> Nat -> Maybe a
bound :: Nat -> Vec a -> Nat
toList :: Vec a -> [a]


-- | Types related to Share and Codeservers.
module Unison.Share.Types

-- | This type is expanded out into all of its fields because we require
--   certain pieces which are optional in a URI, and also to make it more
--   typesafe to eventually convert into a BaseURL for servant clients.
data CodeserverURI
CodeserverURI :: Scheme -> String -> String -> Maybe Int -> [String] -> CodeserverURI
[$sel:codeserverScheme:CodeserverURI] :: CodeserverURI -> Scheme
[$sel:codeserverUserInfo:CodeserverURI] :: CodeserverURI -> String
[$sel:codeserverRegName:CodeserverURI] :: CodeserverURI -> String
[$sel:codeserverPort:CodeserverURI] :: CodeserverURI -> Maybe Int
[$sel:codeserverPath:CodeserverURI] :: CodeserverURI -> [String]

-- | This is distinct from the codeserver URI in that we store credentials
--   by a normalized ID, since it's much easier to look up that way than
--   from an arbitrary path. We may wish to use explicitly named
--   configurations in the future. This currently uses a stringified
--   uriAuthority.
newtype CodeserverId
CodeserverId :: Text -> CodeserverId
[$sel:codeserverId:CodeserverId] :: CodeserverId -> Text
data Scheme
Http :: Scheme
Https :: Scheme

-- | <pre>
--   &gt;&gt;&gt; import Data.Maybe (fromJust)
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "http://localhost:8080"
--   Just http://localhost:8080
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "http://localhost:80"
--   Just http://localhost:80
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "https://share.unison-lang.org/api"
--   Just https://share.unison-lang.org/api
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "http://share.unison-lang.org/api"
--   Just http://share.unison-lang.org/api
--   </pre>
codeserverFromURI :: URI -> Maybe CodeserverURI

-- | Gets the part of the CodeserverURI that we use for identifying that
--   codeserver in credentials files.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Maybe (fromJust)
--   
--   &gt;&gt;&gt; import Network.URI (parseURI)
--   
--   &gt;&gt;&gt; codeserverIdFromURI (fromJust $ parseURI "http://localhost:5424/api")
--   
--   &gt;&gt;&gt; codeserverIdFromURI (fromJust $ parseURI "https://share.unison-lang.org/api")
--   Right "localhost:5424"
--   Right "share.unison-lang.org"
--   </pre>
codeserverIdFromURI :: URI -> Either Text CodeserverId
codeserverToURI :: CodeserverURI -> URI

-- | Gets the CodeserverId for a given CodeserverURI
codeserverIdFromCodeserverURI :: CodeserverURI -> CodeserverId

-- | Builds a servant-compatible BaseUrl for a given CodeserverURI.
codeserverBaseURL :: CodeserverURI -> BaseUrl
instance GHC.Show.Show Unison.Share.Types.Scheme
instance GHC.Classes.Ord Unison.Share.Types.Scheme
instance GHC.Classes.Eq Unison.Share.Types.Scheme
instance GHC.Classes.Ord Unison.Share.Types.CodeserverURI
instance GHC.Classes.Eq Unison.Share.Types.CodeserverURI
instance Data.Aeson.Types.FromJSON.FromJSONKey Unison.Share.Types.CodeserverId
instance Data.Aeson.Types.ToJSON.ToJSONKey Unison.Share.Types.CodeserverId
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Share.Types.CodeserverId
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Share.Types.CodeserverId
instance GHC.Classes.Ord Unison.Share.Types.CodeserverId
instance GHC.Classes.Eq Unison.Share.Types.CodeserverId
instance GHC.Show.Show Unison.Share.Types.CodeserverId
instance GHC.Show.Show Unison.Share.Types.CodeserverURI

module Unison.Codebase.Editor.RemoteRepo
data ShareCodeserver
DefaultCodeserver :: ShareCodeserver
CustomCodeserver :: CodeserverURI -> ShareCodeserver
newtype ShareUserHandle
ShareUserHandle :: Text -> ShareUserHandle
[$sel:shareUserHandleToText:ShareUserHandle] :: ShareUserHandle -> Text

-- | <pre>
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; import Data.Maybe (fromJust)
--   
--   &gt;&gt;&gt; import Network.URI
--   
--   &gt;&gt;&gt; displayShareCodeserver DefaultCodeserver "share" ["base", "List"]
--   "share.base.List"
--   
--   &gt;&gt;&gt; displayShareCodeserver DefaultCodeserver "share" []
--   "share"
--   
--   &gt;&gt;&gt; displayShareCodeserver (CustomCodeserver . fromJust $ parseURI "https://share-next.unison-lang.org/api" &gt;&gt;= codeserverFromURI ) "unison" ["base", "List"]
--   "share(https://share-next.unison-lang.org:443/api).unison.base.List"
--   </pre>
displayShareCodeserver :: ShareCodeserver -> ShareUserHandle -> Path -> Text
writeNamespaceToRead :: WriteRemoteNamespace Void -> ReadRemoteNamespace void

-- | print remote namespace
printReadRemoteNamespace :: (a -> Text) -> ReadRemoteNamespace a -> Text

-- | Render a <a>WriteRemoteNamespace</a> as text.
printWriteRemoteNamespace :: WriteRemoteNamespace (ProjectAndBranch ProjectName ProjectBranchName) -> Text
maybePrintPath :: Path -> Text
data ReadRemoteNamespace a
ReadShare'LooseCode :: !ReadShareLooseCode -> ReadRemoteNamespace a

-- | A remote project+branch, specified by name (e.g.
--   @unison<i>base</i>main). Currently assumed to be hosted on Share,
--   though we could include a ShareCodeserver in here, too.
ReadShare'ProjectBranch :: !a -> ReadRemoteNamespace a
data ReadShareLooseCode
ReadShareLooseCode :: !ShareCodeserver -> !ShareUserHandle -> !Path -> ReadShareLooseCode
[$sel:server:ReadShareLooseCode] :: ReadShareLooseCode -> !ShareCodeserver
[$sel:repo:ReadShareLooseCode] :: ReadShareLooseCode -> !ShareUserHandle
[$sel:path:ReadShareLooseCode] :: ReadShareLooseCode -> !Path
isPublic :: ReadShareLooseCode -> Bool
data WriteRemoteNamespace a
WriteRemoteNamespaceShare :: !WriteShareRemoteNamespace -> WriteRemoteNamespace a
WriteRemoteProjectBranch :: a -> WriteRemoteNamespace a

-- | A lens which focuses the path of a remote namespace.
remotePath_ :: Lens' (WriteRemoteNamespace Void) Path
data WriteShareRemoteNamespace
WriteShareRemoteNamespace :: !ShareCodeserver -> !ShareUserHandle -> !Path -> WriteShareRemoteNamespace
[$sel:server:WriteShareRemoteNamespace] :: WriteShareRemoteNamespace -> !ShareCodeserver
[$sel:repo:WriteShareRemoteNamespace] :: WriteShareRemoteNamespace -> !ShareUserHandle
[$sel:path:WriteShareRemoteNamespace] :: WriteShareRemoteNamespace -> !Path
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ShareCodeserver
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.ShareCodeserver
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ShareCodeserver
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ShareUserHandle
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.ShareUserHandle
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ShareUserHandle
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ReadShareLooseCode
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ReadShareLooseCode
instance GHC.Generics.Generic (Unison.Codebase.Editor.RemoteRepo.ReadRemoteNamespace a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.Editor.RemoteRepo.ReadRemoteNamespace a)
instance GHC.Base.Functor Unison.Codebase.Editor.RemoteRepo.ReadRemoteNamespace
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.Editor.RemoteRepo.ReadRemoteNamespace a)
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.WriteShareRemoteNamespace
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.WriteShareRemoteNamespace
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.Editor.RemoteRepo.WriteRemoteNamespace a)
instance GHC.Base.Functor Unison.Codebase.Editor.RemoteRepo.WriteRemoteNamespace
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.Editor.RemoteRepo.WriteRemoteNamespace a)

module Unison.Syntax.NamePrinter
type SyntaxText = SyntaxText' Reference
prettyName :: IsString s => Name -> Pretty s
prettyHashQualified :: HashQualified Name -> Pretty SyntaxText
prettyHashQualified' :: HashQualified Name -> Pretty SyntaxText
prettyHashQualified0 :: IsString s => HashQualified Name -> Pretty s

-- | Pretty-print a reference as a name and the given number of characters
--   of its hash.
prettyNamedReference :: Int -> Name -> Reference -> Pretty SyntaxText

-- | Pretty-print a referent as a name and the given number of characters
--   of its hash.
prettyNamedReferent :: Int -> Name -> Referent -> Pretty SyntaxText

-- | Pretty-print a reference as the given number of characters of its
--   hash.
prettyReference :: Int -> Reference -> Pretty SyntaxText

-- | Pretty-print a referent as the given number of characters of its hash.
prettyReferent :: Int -> Referent -> Pretty SyntaxText
prettyLabeledDependency :: Int -> LabeledDependency -> Pretty SyntaxText
prettyShortHash :: IsString s => ShortHash -> Pretty s
styleHashQualified :: IsString s => (Pretty s -> Pretty s) -> HashQualified Name -> Pretty s
styleHashQualified' :: IsString s => (Pretty s -> Pretty s) -> (Pretty s -> Pretty s) -> HashQualified Name -> Pretty s
styleHashQualified'' :: (Pretty SyntaxText -> Pretty SyntaxText) -> HashQualified Name -> Pretty SyntaxText
fmt :: Element r -> Pretty (SyntaxText' r) -> Pretty (SyntaxText' r)

module Unison.Typechecker.Components

-- | Algorithm for minimizing cycles of a `let rec`. This can improve
--   generalization during typechecking and may also be more efficient for
--   execution.
--   
--   For instance:
--   
--   minimize (let rec id x = x; g = id 42; y = id "hi" in g) ==&gt; Just
--   (let id x = x; g = id 42; y = id "hi" in g)
--   
--   Gets rid of the let rec and replaces it with an ordinary `let`, such
--   that <a>id</a> is suitably generalized.
--   
--   Fails on the left if there are duplicate definitions.
minimize :: Var v => Term' vt v a -> Either (NonEmpty (v, [a])) (Maybe (Term' vt v a))
minimize' :: Var v => Term' vt v a -> Either (NonEmpty (v, [a])) (Term' vt v a)

module Unison.Typechecker.TypeLookup
data TypeLookup v a
TypeLookup :: Map TermReference (Type v a) -> Map TypeReference (DataDeclaration v a) -> Map TypeReference (EffectDeclaration v a) -> TypeLookup v a
[$sel:typeOfTerms:TypeLookup] :: TypeLookup v a -> Map TermReference (Type v a)
[$sel:dataDecls:TypeLookup] :: TypeLookup v a -> Map TypeReference (DataDeclaration v a)
[$sel:effectDecls:TypeLookup] :: TypeLookup v a -> Map TypeReference (EffectDeclaration v a)
typeOfReferent :: TypeLookup v a -> Referent -> Maybe (Type v a)
unsafeConstructorType :: TypeLookup v a -> TypeReference -> ConstructorType
constructorType :: TypeLookup v a -> TypeReference -> Maybe ConstructorType
typeOfDataConstructor :: TypeLookup v a -> ConstructorReference -> Maybe (Type v a)
typeOfEffectConstructor :: TypeLookup v a -> ConstructorReference -> Maybe (Type v a)
typeOfTerm :: TypeLookup v a -> TermReference -> Maybe (Type v a)
typeOfTerm' :: TypeLookup v a -> TermReference -> Either TermReference (Type v a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Semigroup (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Monoid (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Functor (Unison.Typechecker.TypeLookup.TypeLookup v)

module Unison.Typechecker.TypeVar
data TypeVar b v
Universal :: v -> TypeVar b v
Existential :: b -> v -> TypeVar b v
underlying :: TypeVar b v -> v
liftType :: Ord v => Type v a -> Type (TypeVar b v) a
lowerType :: Ord v => Type (TypeVar b v) a -> Type v a
liftTerm :: Ord v => Term v a -> Term' (TypeVar b v) v a
lowerTerm :: Ord v => Term' (TypeVar b v) v a -> Term v a
instance GHC.Base.Functor (Unison.Typechecker.TypeVar.TypeVar b)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Typechecker.TypeVar.TypeVar b v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Typechecker.TypeVar.TypeVar b v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.TypeVar.TypeVar b v)
instance U.Core.ABT.Var.Var v => U.Core.ABT.Var.Var (Unison.Typechecker.TypeVar.TypeVar b v)
instance Unison.Var.Var v => Unison.Var.Var (Unison.Typechecker.TypeVar.TypeVar b v)

module Unison.UnisonFile.Env
data Env v a
Env :: Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> Names -> Env v a
[$sel:datasId:Env] :: Env v a -> Map v (Id, DataDeclaration v a)
[$sel:effectsId:Env] :: Env v a -> Map v (Id, EffectDeclaration v a)
[$sel:names:Env] :: Env v a -> Names
datas :: Env v a -> Map v (Reference, DataDeclaration v a)

module Unison.UnisonFile.Type
data UnisonFile v a
UnisonFileId :: Map v (TypeReferenceId, DataDeclaration v a) -> Map v (TypeReferenceId, EffectDeclaration v a) -> Map v (a, Term v a) -> Map WatchKind [(v, a, Term v a)] -> UnisonFile v a
[$sel:dataDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TypeReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TypeReferenceId, EffectDeclaration v a)
[$sel:terms:UnisonFileId] :: UnisonFile v a -> Map v (a, Term v a)
[$sel:watches:UnisonFileId] :: UnisonFile v a -> Map WatchKind [(v, a, Term v a)]
pattern UnisonFile :: Map v (TypeReference, DataDeclaration v a) -> Map v (TypeReference, EffectDeclaration v a) -> Map v (a, Term v a) -> Map WatchKind [(v, a, Term v a)] -> UnisonFile v a

-- | A UnisonFile after typechecking. Terms are split into groups by cycle
--   and the type of each term is known.
data TypecheckedUnisonFile v a
TypecheckedUnisonFileId :: Map v (TypeReferenceId, DataDeclaration v a) -> Map v (TypeReferenceId, EffectDeclaration v a) -> [[(v, a, Term v a, Type v a)]] -> [(WatchKind, [(v, a, Term v a, Type v a)])] -> Map v (a, TermReferenceId, Maybe WatchKind, Term v a, Type v a) -> TypecheckedUnisonFile v a
[$sel:dataDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, EffectDeclaration v a)
[$sel:topLevelComponents':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [[(v, a, Term v a, Type v a)]]
[$sel:watchComponents:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [(WatchKind, [(v, a, Term v a, Type v a)])]
[$sel:hashTermsId:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (a, TermReferenceId, Maybe WatchKind, Term v a, Type v a)
pattern TypecheckedUnisonFile :: Map v (TypeReference, DataDeclaration v a) -> Map v (TypeReference, EffectDeclaration v a) -> [[(v, a, Term v a, Type v a)]] -> [(WatchKind, [(v, a, Term v a, Type v a)])] -> Map v (a, TermReference, Maybe WatchKind, Term (F v a a) v a, Term F v a) -> TypecheckedUnisonFile v a
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.UnisonFile.Type.UnisonFile v a)
instance GHC.Generics.Generic (Unison.UnisonFile.Type.UnisonFile v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.UnisonFile.Type.TypecheckedUnisonFile v a)
instance GHC.Generics.Generic (Unison.UnisonFile.Type.TypecheckedUnisonFile v a)
instance GHC.Classes.Ord v => GHC.Base.Functor (Unison.UnisonFile.Type.TypecheckedUnisonFile v)

module Unison.Util.CycleTable
data CycleTable k v
CycleTable :: BasicHashTable k v -> IOPRef Int -> CycleTable k v
[$sel:table:CycleTable] :: CycleTable k v -> BasicHashTable k v
[$sel:sizeRef:CycleTable] :: CycleTable k v -> IOPRef Int
new :: Int -> IO (CycleTable k v)
lookup :: (Hashable k, Eq k) => k -> CycleTable k v -> IO (Maybe v)
insert :: (Hashable k, Eq k) => k -> v -> CycleTable k v -> IO ()
size :: CycleTable k v -> IO Int
insertEnd :: (Hashable k, Eq k) => k -> CycleTable k Int -> IO ()

module Unison.Util.CyclicEq
class CyclicEq a
cyclicEq :: CyclicEq a => CycleTable Int Int -> CycleTable Int Int -> a -> a -> IO Bool
bothEq' :: (Eq a, CyclicEq b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Bool
bothEq :: (CyclicEq a, CyclicEq b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Bool
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq [a]
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq (Data.Sequence.Internal.Seq a)
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq (Data.Vector.Vector a)

module Unison.Util.CyclicOrd
class CyclicOrd a
cyclicOrd :: CyclicOrd a => CycleTable Int Int -> CycleTable Int Int -> a -> a -> IO Ordering
bothOrd' :: (Ord a, CyclicOrd b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Ordering
bothOrd :: (CyclicOrd a, CyclicOrd b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Ordering
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd [a]
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd (Data.Sequence.Internal.Seq a)
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd (Data.Vector.Vector a)

module Unison.Util.EnumContainers
data EnumMap k a
data EnumSet k
class EnumKey k
keyToInt :: EnumKey k => k -> Int
intToKey :: EnumKey k => Int -> k
mapFromList :: EnumKey k => [(k, a)] -> EnumMap k a
setFromList :: EnumKey k => [k] -> EnumSet k
setToList :: EnumKey k => EnumSet k -> [k]
mapSingleton :: EnumKey k => k -> a -> EnumMap k a
setSingleton :: EnumKey k => k -> EnumSet k
mapInsert :: EnumKey k => k -> a -> EnumMap k a -> EnumMap k a
unionWith :: EnumKey k => (a -> a -> a) -> EnumMap k a -> EnumMap k a -> EnumMap k a
intersectionWith :: (a -> b -> c) -> EnumMap k a -> EnumMap k b -> EnumMap k c
hasKey :: EnumKey k => k -> EnumMap k a -> Bool
keys :: EnumKey k => EnumMap k a -> [k]
keysSet :: EnumKey k => EnumMap k a -> EnumSet k
restrictKeys :: EnumKey k => EnumMap k a -> EnumSet k -> EnumMap k a
withoutKeys :: EnumKey k => EnumMap k a -> EnumSet k -> EnumMap k a
member :: EnumKey k => k -> EnumSet k -> Bool
lookup :: EnumKey k => k -> EnumMap k a -> Maybe a
lookupWithDefault :: EnumKey k => a -> k -> EnumMap k a -> a
mapWithKey :: EnumKey k => (k -> a -> b) -> EnumMap k a -> EnumMap k b
foldMapWithKey :: EnumKey k => Monoid m => (k -> a -> m) -> EnumMap k a -> m
mapToList :: EnumKey k => EnumMap k a -> [(k, a)]
(!) :: EnumKey k => EnumMap k a -> k -> a
findMin :: EnumKey k => EnumSet k -> k
interverse :: Applicative f => (a -> b -> f c) -> EnumMap k a -> EnumMap k b -> f (EnumMap k c)
traverseSet_ :: Applicative f => EnumKey k => (k -> f ()) -> EnumSet k -> f ()
traverseWithKey :: Applicative f => EnumKey k => (k -> a -> f b) -> EnumMap k a -> f (EnumMap k b)
setSize :: EnumSet k -> Int
instance GHC.Base.Semigroup (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Base.Monoid (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Util.EnumContainers.EnumMap k a)
instance Data.Traversable.Traversable (Unison.Util.EnumContainers.EnumMap k)
instance Data.Foldable.Foldable (Unison.Util.EnumContainers.EnumMap k)
instance GHC.Base.Functor (Unison.Util.EnumContainers.EnumMap k)
instance GHC.Base.Semigroup (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Base.Monoid (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Classes.Ord (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Classes.Eq (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Show.Show (Unison.Util.EnumContainers.EnumSet k)
instance Unison.Util.EnumContainers.EnumKey GHC.Word.Word64
instance Unison.Util.EnumContainers.EnumKey GHC.Word.Word16

module Unison.Util.Exception
tryAny :: MonadIO m => IO a -> m (Either SomeException a)
catchAny :: IO a -> (SomeException -> IO a) -> IO a


-- | Small logging library. Typical usage, import qualified:
--   
--   import qualified Unison.Util.Logger as L
--   
--   do logger &lt;- L.atomic . L.atInfo . L.scope "worker" . L.toHandle $
--   stderr L.warn logger "WARNING!!!" L.debug logger "Debug message, will
--   be ignored" let logger2 = L.atDebug logger L.debug logger2 "Debug
--   message, will be printed" logger' &lt;- L.at L.warnLevel
module Unison.Util.Logger
type Level = Int
type Scope = [String]
data Logger
Logger :: !Scope -> (String -> String) -> !Level -> (String -> IO ()) -> Logger
[$sel:getScope:Logger] :: Logger -> !Scope
[$sel:prefix:Logger] :: Logger -> String -> String
[$sel:getLevel:Logger] :: Logger -> !Level
[$sel:raw:Logger] :: Logger -> String -> IO ()

-- | Ensure at most one message is logged at the same time
atomic :: Logger -> IO Logger
toHandle :: Handle -> Logger
toStandardError :: Logger
toStandardOut :: Logger
logHandleAt :: Logger -> Level -> Handle -> IO ()
logAt' :: Logger -> Level -> IO String -> IO ()
logAt :: Logger -> Level -> String -> IO ()
scope :: String -> Logger -> Logger
scope' :: [String] -> Logger -> Logger
logger :: (String -> IO ()) -> Logger
error :: Logger -> String -> IO ()
warn :: Logger -> String -> IO ()
info :: Logger -> String -> IO ()
debug :: Logger -> String -> IO ()
trace :: Logger -> String -> IO ()
error' :: Logger -> IO String -> IO ()
warn' :: Logger -> IO String -> IO ()
info' :: Logger -> IO String -> IO ()
debug' :: Logger -> IO String -> IO ()
trace' :: Logger -> IO String -> IO ()
errorLevel :: Level
warnLevel :: Level
infoLevel :: Level
debugLevel :: Level
traceLevel :: Level
at :: Level -> Logger -> Logger
atError :: Logger -> Logger
atWarn :: Logger -> Logger
atInfo :: Logger -> Logger
atDebug :: Logger -> Logger
atTrace :: Logger -> Logger
increment :: Logger -> Logger
decrement :: Logger -> Logger

module Unison.Util.Pretty.MegaParsec
prettyPrintParseError :: String -> ParseErrorBundle Text Void -> Pretty ColorText
showErrorFancy :: ShowErrorComponent e => ErrorFancy e -> String
showErrorItem :: ErrorItem (Token Text) -> String

module Unison.Util.RefPromise

-- | When performing compare-and-swaps, the <i>ticket</i> encapsulates
--   proof that a thread observed a specific previous value of a mutable
--   variable. It is provided in lieu of the "old" value to
--   compare-and-swap.
--   
--   Design note: <a>Ticket</a>s exist to hide objects from the GHC
--   compiler, which can normally perform many optimizations that change
--   pointer equality. A Ticket, on the other hand, is a first-class object
--   that can be handled by the user, but will not have its pointer
--   identity changed by compiler optimizations (but will of course, change
--   addresses during garbage collection).
data Ticket a

-- | A ticket contains or can get the usable Haskell value. This function
--   does just that.
peekTicket :: Ticket a -> a

-- | Ordinary processor load instruction (non-atomic, not implying any
--   memory barriers).
--   
--   The difference between this function and <a>readIORef</a>, is that it
--   returns a <i>ticket</i>, for use in future compare-and-swap
--   operations.
readForCAS :: IORef a -> IO (Ticket a)

-- | Performs a machine-level compare and swap (CAS) operation on an
--   <a>IORef</a>. Returns a tuple containing a <a>Bool</a> which is
--   <a>True</a> when a swap is performed, along with the most
--   <tt>current</tt> value from the <a>IORef</a>. Note that this differs
--   from the more common CAS behavior, which is to return the <i>old</i>
--   value before the CAS occured.
--   
--   The reason for the difference is the ticket API. This function always
--   returns the ticket that you should use in your next CAS attempt. In
--   case of success, this ticket corresponds to the <tt>new</tt> value
--   which you yourself installed in the <a>IORef</a>, whereas in the case
--   of failure it represents the preexisting value currently in the IORef.
--   
--   Note "compare" here means pointer equality in the sense of
--   <a>reallyUnsafePtrEquality#</a>. However, the ticket API absolves the
--   user of this module from needing to worry about the pointer equality
--   of their values, which in general requires reasoning about the details
--   of the Haskell implementation (GHC).
--   
--   By convention this function is strict in the "new" value argument.
--   This isn't absolutely necesary, but we think it's a bad habit to use
--   unevaluated thunks in this context.
casIORef :: IORef a -> Ticket a -> a -> IO (Bool, Ticket a)
data Promise a
newPromise :: IO (Promise a)
readPromise :: Promise a -> IO a
tryReadPromise :: Promise a -> IO (Maybe a)
writePromise :: Promise a -> a -> IO Bool

module Unison.Util.Star2
data Star2 fact d1 d2
Star2 :: Set fact -> Relation fact d1 -> Relation fact d2 -> Star2 fact d1 d2
($sel:fact:Star2) :: Star2 fact d1 d2 -> Set fact
insertD1 :: (Ord fact, Ord d1) => (fact, d1) -> Star2 fact d1 d2 -> Star2 fact d1 d2
insertD2 :: (Ord fact, Ord d2) => (fact, d2) -> Star2 fact d1 d2 -> Star2 fact d1 d2
deleteD1 :: (Ord fact, Ord d1, Ord d2) => d1 -> Star2 fact d1 d2 -> Star2 fact d1 d2
deleteD2 :: (Ord fact, Ord d1, Ord d2) => (fact, d2) -> Star2 fact d1 d2 -> Star2 fact d1 d2
deleteFact :: (Ord fact, Ord d1, Ord d2) => Set fact -> Star2 fact d1 d2 -> Star2 fact d1 d2
deletePrimaryD1 :: (Ord fact, Ord d1, Ord d2) => (fact, d1) -> Star2 fact d1 d2 -> Star2 fact d1 d2
($sel:d1:Star2) :: Star2 fact d1 d2 -> Relation fact d1
($sel:d2:Star2) :: Star2 fact d1 d2 -> Relation fact d2
difference :: (Ord fact, Ord d1, Ord d2) => Star2 fact d1 d2 -> Star2 fact d1 d2 -> Star2 fact d1 d2
lookupD1 :: (Ord fact, Ord d1) => d1 -> Star2 fact d1 d2 -> Set fact
mapD2 :: (Ord fact, Ord d2, Ord d2a) => (d2 -> d2a) -> Star2 fact d1 d2 -> Star2 fact d1 d2a
memberD1 :: (Ord fact, Ord d1) => (fact, d1) -> Star2 fact d1 d2 -> Bool
replaceFacts :: (Ord fact, Ord d1, Ord d2) => (fact -> fact -> Star2 fact d1 d2 -> Star2 fact d1 d2) -> Map fact fact -> Star2 fact d1 d2 -> Star2 fact d1 d2
instance (GHC.Show.Show fact, GHC.Show.Show d1, GHC.Show.Show d2) => GHC.Show.Show (Unison.Util.Star2.Star2 fact d1 d2)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2) => GHC.Classes.Ord (Unison.Util.Star2.Star2 fact d1 d2)
instance (GHC.Classes.Eq fact, GHC.Classes.Eq d1, GHC.Classes.Eq d2) => GHC.Classes.Eq (Unison.Util.Star2.Star2 fact d1 d2)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2) => GHC.Base.Semigroup (Unison.Util.Star2.Star2 fact d1 d2)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2) => GHC.Base.Monoid (Unison.Util.Star2.Star2 fact d1 d2)

module Unison.Codebase.Metadata
type Star a n = Star2 a n Value
type Value = TermReference
insert :: (Ord a, Ord n) => (a, Value) -> Star a n -> Star a n
delete :: (Ord a, Ord n) => (a, Value) -> Star a n -> Star a n

module Unison.Codebase.Branch.Raw
type Star r n = Star r n
type EditHash = Hash
data Raw
Raw :: Star Referent NameSegment -> Star Reference NameSegment -> Map NameSegment Hash -> Map NameSegment EditHash -> Raw
[$sel:_termsR:Raw] :: Raw -> Star Referent NameSegment
[$sel:_typesR:Raw] :: Raw -> Star Reference NameSegment
[$sel:_childrenR:Raw] :: Raw -> Map NameSegment Hash
[$sel:_editsR:Raw] :: Raw -> Map NameSegment EditHash

module Unison.Codebase.Branch.Type

-- | A Hash for a namespace itself, it doesn't incorporate any history.
type NamespaceHash m = HashFor (Branch0 m)
head :: Branch m -> Branch0 m
headHash :: Branch m -> CausalHash
namespaceHash :: Branch m -> NamespaceHash m

-- | A node in the Unison namespace hierarchy along with its history.
newtype Branch m
Branch :: UnwrappedBranch m -> Branch m
[$sel:_history:Branch] :: Branch m -> UnwrappedBranch m

-- | A node in the Unison namespace hierarchy.
--   
--   <a>$sel:_terms:Branch0</a> and <a>$sel:_types:Branch0</a> are the
--   declarations at this level. <a>$sel:_children:Branch0</a> are the
--   nodes one level below us. <a>$sel:_edits:Branch0</a> are the
--   <a>Patch</a>s stored at this node in the code.
--   
--   The remaining fields are derived from the four above. None of the
--   record fields are exported to avoid accidental tweaking without
--   updating the associated derived fields.
--   
--   Use either the lensy accessors or the field getters.
data Branch0 m
branch0 :: forall m. Star Referent NameSegment -> Star TypeReference NameSegment -> Map NameSegment (Branch m) -> Map NameSegment (PatchHash, m Patch) -> Branch0 m
terms :: Lens' (Branch0 m) (Star Referent NameSegment)
types :: Lens' (Branch0 m) (Star TypeReference NameSegment)
children :: Lens' (Branch0 m) (Map NameSegment (Branch m))
nonEmptyChildren :: Branch0 m -> Map NameSegment (Branch m)
history :: Iso' (Branch m) (UnwrappedBranch m)
edits :: Lens' (Branch0 m) (Map NameSegment (PatchHash, m Patch))
isEmpty0 :: Branch0 m -> Bool
deepTerms :: Branch0 m -> Relation Referent Name
deepTypes :: Branch0 m -> Relation TypeReference Name
deepPaths :: Branch0 m -> Set Path
deepEdits :: Branch0 m -> Map Name PatchHash
type Star r n = Star r n
type UnwrappedBranch m = Causal m (Branch0 m)
instance GHC.Classes.Ord (Unison.Codebase.Branch.Type.Branch m)
instance GHC.Classes.Eq (Unison.Codebase.Branch.Type.Branch m)
instance GHC.Classes.Eq (Unison.Codebase.Branch.Type.Branch0 m)


module Unison.Hashing.V2.Convert
type ResolutionResult v a r = Either Seq ResolutionFailure v a r
hashBranch0 :: Branch0 m -> Hash
hashCausal :: ContentAddressable e => e -> Set CausalHash -> (CausalHash, HashFor e)
hashDataDecls :: Var v => Map v (DataDeclaration v a) -> ResolutionResult v a [(v, Id, DataDeclaration v a)]
hashDecls :: Var v => Map v (Decl v a) -> ResolutionResult v a [(v, Id, Decl v a)]
hashPatch :: Patch -> Hash
hashClosedTerm :: Var v => Term v a -> Id
hashTermComponents :: forall v a extra. Var v => Map v (Term v a, Type v a, extra) -> Map v (TermReferenceId, Term v a, Type v a, extra)

-- | This shouldn't be used when storing terms in the codebase, as it
--   doesn't incorporate the type into the hash. this should only be used
--   in cases where you just need a way to identify some terms that you
--   have, but won't be saving them.
hashTermComponentsWithoutTypes :: forall v a. Var v => Map v (Term v a) -> Map v (TermReferenceId, Term v a)
typeToReference :: Var v => Type v a -> Reference
typeToReferenceMentions :: Var v => Type v a -> Set Reference

module Unison.Codebase.Causal
data Causal m e
pattern One :: CausalHash -> HashFor e -> e -> Causal m e
pattern Cons :: CausalHash -> HashFor e -> e -> (CausalHash, m (Causal m e)) -> Causal m e
pattern Merge :: CausalHash -> HashFor e -> e -> Map CausalHash (m (Causal m e)) -> Causal m e

-- | Focus the current head, keeping the hash up to date.
head_ :: ContentAddressable e => Lens' (Causal m e) e
one :: ContentAddressable e => e -> Causal m e
cons :: (Applicative m, ContentAddressable e) => e -> Causal m e -> Causal m e
consDistinct :: (Applicative m, Eq e, ContentAddressable e) => e -> Causal m e -> Causal m e

-- | An optimized variant of <a>fromListM</a> for when it is known we have
--   2+ predecessors (merge node).
mergeNode :: ContentAddressable e => e -> Map CausalHash (m (Causal m e)) -> Causal m e
uncons :: Applicative m => Causal m e -> m (Maybe (e, Causal m e))
predecessors :: Causal m e -> Seq (m (Causal m e))
threeWayMerge :: forall m e. (Monad m, ContentAddressable e) => (Maybe e -> e -> e -> m e) -> Causal m e -> Causal m e -> m (Causal m e)
threeWayMerge' :: forall m e. (Monad m, ContentAddressable e) => (Causal m e -> Causal m e -> m (Maybe (Causal m e))) -> (Maybe e -> e -> e -> m e) -> Causal m e -> Causal m e -> m (Causal m e)
squashMerge' :: forall m e. (Monad m, ContentAddressable e, Eq e) => (Causal m e -> Causal m e -> m (Maybe (Causal m e))) -> (e -> m e) -> (Maybe e -> e -> e -> m e) -> Causal m e -> Causal m e -> m (Causal m e)
lca :: Monad m => Causal m e -> Causal m e -> m (Maybe (Causal m e))
stepDistinct :: (Applicative m, Eq e, ContentAddressable e) => (e -> e) -> Causal m e -> Causal m e
stepDistinctM :: (Applicative m, Functor n, Eq e, ContentAddressable e) => (e -> n e) -> Causal m e -> n (Causal m e)
transform :: Functor m => (forall a. m a -> n a) -> Causal m e -> Causal n e
unsafeMapHashPreserving :: forall m e e2. Functor m => (e -> e2) -> Causal m e -> Causal m e2
before :: Monad m => Causal m e -> Causal m e -> m Bool
beforeHash :: forall m e. Monad m => Word -> CausalHash -> Causal m e -> m Bool
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.Causal.FoldHistoryResult a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Codebase.Causal.FoldHistoryResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.Causal.FoldHistoryResult a)

module Unison.Builtin.Decls
lookupDeclRef :: Text -> Reference
lookupEffectRef :: Text -> Reference
unitRef :: Reference
pairRef :: Reference
optionalRef :: Reference
eitherRef :: Reference
testResultRef :: Reference
testResultListRef :: Reference
linkRef :: Reference
docRef :: Reference
ioErrorRef :: Reference
stdHandleRef :: Reference
failureRef :: Reference
ioFailureRef :: Reference
tlsFailureRef :: Reference
arrayFailureRef :: Reference
cryptoFailureRef :: Reference
exceptionRef :: Reference
tlsSignedCertRef :: Reference
tlsPrivateKeyRef :: Reference
isPropagatedRef :: Reference
isTestRef :: Reference
runtimeFailureRef :: Reference
arithmeticFailureRef :: Reference
miscFailureRef :: Reference
stmFailureRef :: Reference
threadKilledFailureRef :: Reference
fileModeRef :: Reference
filePathRef :: Reference
bufferModeRef :: Reference
seekModeRef :: Reference
seqViewRef :: Reference
pairCtorRef :: Referent
unitCtorRef :: Referent
constructorId :: Reference -> Text -> Maybe ConstructorId
noneId :: ConstructorId
someId :: ConstructorId
okConstructorId :: ConstructorId
failConstructorId :: ConstructorId
docBlobId :: ConstructorId
docLinkId :: ConstructorId
docSignatureId :: ConstructorId
docSourceId :: ConstructorId
docEvaluateId :: ConstructorId
docJoinId :: ConstructorId
linkTermId :: ConstructorId
linkTypeId :: ConstructorId
eitherRightId :: ConstructorId
eitherLeftId :: ConstructorId
isPropagatedConstructorId :: ConstructorId
isTestConstructorId :: ConstructorId
bufferModeNoBufferingId :: ConstructorId
bufferModeLineBufferingId :: ConstructorId
bufferModeBlockBufferingId :: ConstructorId
bufferModeSizedBlockBufferingId :: ConstructorId
seqViewEmpty :: ConstructorId
seqViewElem :: ConstructorId
okConstructorReferent :: Referent
failConstructorReferent :: Referent
rewriteTermRef :: Reference
pattern RewriteTerm' :: Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
unRewriteTerm :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a, Term2 vt at ap v a)
rewriteCaseRef :: Reference
pattern RewriteCase' :: Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
rewriteCase :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
rewriteTerm :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
unRewriteCase :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a, Term2 vt at ap v a)
rewriteTypeRef :: Reference
pattern RewriteSignature' :: forall vt at ap v a. [vt] -> Type vt at -> Type vt at -> Term2 vt at ap v a
rewriteType :: (Var v, Semigroup a) => a -> [v] -> Type v a -> Type v a -> Term2 v a a v a
unRewriteSignature :: Term2 vt at ap v a -> Maybe ([vt], Type vt at, Type vt at)
rewritesRef :: Reference
pattern Rewrites' :: [Term2 vt at ap v a] -> Term2 vt at ap v a
rewrites :: (Var v, Monoid a) => a -> [Term2 vt at ap v a] -> Term2 vt at ap v a
unRewrites :: Term2 vt at ap v a -> Maybe [Term2 vt at ap v a]

-- | parse some builtin data types, and resolve their free variables using
--   | builtinTypes' and those types defined herein
builtinDataDecls :: [(Symbol, Id, DataDeclaration Symbol ())]
builtinEffectDecls :: [(Symbol, Id, EffectDeclaration Symbol ())]
pattern UnitRef :: Reference
pattern PairRef :: Reference
pattern EitherRef :: Reference
pattern OptionalRef :: Reference
pattern OptionalNone' :: Term (F typeVar typeAnn patternAnn) v a
pattern OptionalSome' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern TupleType' :: Var v => [Type v a] -> Type v a
pattern TupleTerm' :: [Term2 vt at ap v a] -> Term2 vt at ap v a
pattern TuplePattern :: [Pattern loc] -> Pattern loc
pattern EitherLeft' :: Term2 vt at ap v a -> Term2 vt at ap v a
pattern EitherRight' :: Term2 vt at ap v a -> Term2 vt at ap v a
pattern EitherLeftId :: ConstructorId
pattern EitherRightId :: ConstructorId
unLeftTerm :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
unRightTerm :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
pattern DocRef :: Reference
pattern DocJoin :: Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term (F typeVar typeAnn patternAnn) v a
pattern DocBlob :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern DocLink :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocSignature :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocEvaluate :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc :: Term (F typeVar typeAnn patternAnn) v a
pattern DocSignatureId :: ConstructorId
pattern DocBlobId :: ConstructorId
pattern DocLinkId :: ConstructorId
pattern DocSourceId :: ConstructorId
pattern DocEvaluateId :: ConstructorId
pattern DocJoinId :: ConstructorId
pattern LinkTermId :: ConstructorId
pattern LinkTypeId :: ConstructorId
pattern LinkRef :: Reference
pattern LinkTerm :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern LinkType :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
unitType :: Ord v => a -> Type v a
pairType :: Ord v => a -> Type v a
optionalType :: Ord v => a -> Type v a
testResultListType :: Ord v => a -> Type v a
eitherType :: Ord v => a -> Type v a
ioErrorType :: Ord v => a -> Type v a
fileModeType :: Ord v => a -> Type v a
filePathType :: Ord v => a -> Type v a
bufferModeType :: Ord v => a -> Type v a
seekModeType :: Ord v => a -> Type v a
stdHandleType :: Ord v => a -> Type v a
failureType :: Ord v => a -> Type v a
thunkArgType :: Ord v => a -> Type v a
exceptionType :: Ord v => a -> Type v a
tlsSignedCertType :: Var v => a -> Type v a
unitTerm :: Var v => a -> Term2 vt at ap v a
tupleConsTerm :: (Ord v, Semigroup a) => Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
tupleTerm :: (Var v, Monoid a) => [Term2 vt at ap v a] -> Term2 vt at ap v a
forceTerm :: Var v => a -> a -> Term v a -> Term v a
delayTerm :: Var v => a -> Term v a -> Term v a
unTupleTerm :: Term2 vt at ap v a -> Maybe [Term2 vt at ap v a]
unTupleType :: Var v => Type v a -> Maybe [Type v a]
unTuplePattern :: Pattern loc -> Maybe [Pattern loc]
unUnitRef :: Reference -> Bool
unPairRef :: Reference -> Bool
unOptionalRef :: Reference -> Bool

module Unison.UnisonFile
data UnisonFile v a
UnisonFileId :: Map v (TypeReferenceId, DataDeclaration v a) -> Map v (TypeReferenceId, EffectDeclaration v a) -> Map v (a, Term v a) -> Map WatchKind [(v, a, Term v a)] -> UnisonFile v a
[$sel:dataDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TypeReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TypeReferenceId, EffectDeclaration v a)
[$sel:terms:UnisonFileId] :: UnisonFile v a -> Map v (a, Term v a)
[$sel:watches:UnisonFileId] :: UnisonFile v a -> Map WatchKind [(v, a, Term v a)]
pattern UnisonFile :: Map v (TypeReference, DataDeclaration v a) -> Map v (TypeReference, EffectDeclaration v a) -> Map v (a, Term v a) -> Map WatchKind [(v, a, Term v a)] -> UnisonFile v a

-- | An empty Unison file.
emptyUnisonFile :: UnisonFile v a
allWatches :: UnisonFile v a -> [(v, a, Term v a)]
dataDeclarations :: UnisonFile v a -> Map v (Reference, DataDeclaration v a)
declsToTypeLookup :: Var v => UnisonFile v a -> TypeLookup v a
dependencies :: (Monoid a, Var v) => UnisonFile v a -> Set Reference
effectDeclarations :: UnisonFile v a -> Map v (Reference, EffectDeclaration v a)
typecheckingTerm :: (Var v, Monoid a) => UnisonFile v a -> Term v a
watchesOfKind :: WatchKind -> UnisonFile v a -> [(v, a, Term v a)]

-- | Get the location of a given definition in the file.
definitionLocation :: Var v => v -> UnisonFile v a -> Maybe a
termBindings :: UnisonFile v a -> [(v, a, Term v a)]
leftBiasedMerge :: forall v a. Ord v => UnisonFile v a -> UnisonFile v a -> UnisonFile v a

-- | A UnisonFile after typechecking. Terms are split into groups by cycle
--   and the type of each term is known.
data TypecheckedUnisonFile v a
TypecheckedUnisonFileId :: Map v (TypeReferenceId, DataDeclaration v a) -> Map v (TypeReferenceId, EffectDeclaration v a) -> [[(v, a, Term v a, Type v a)]] -> [(WatchKind, [(v, a, Term v a, Type v a)])] -> Map v (a, TermReferenceId, Maybe WatchKind, Term v a, Type v a) -> TypecheckedUnisonFile v a
[$sel:dataDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, EffectDeclaration v a)
[$sel:topLevelComponents':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [[(v, a, Term v a, Type v a)]]
[$sel:watchComponents:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [(WatchKind, [(v, a, Term v a, Type v a)])]
[$sel:hashTermsId:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (a, TermReferenceId, Maybe WatchKind, Term v a, Type v a)

-- | A mapping of all terms in the file by their var name. The returned
--   terms refer to other definitions in the file by their var, not by
--   reference. Includes test watches.
allTerms :: Ord v => TypecheckedUnisonFile v a -> Map v (Term v a)
dataDeclarations' :: TypecheckedUnisonFile v a -> Map v (Reference, DataDeclaration v a)
discardTypes :: Ord v => TypecheckedUnisonFile v a -> UnisonFile v a
effectDeclarations' :: TypecheckedUnisonFile v a -> Map v (Reference, EffectDeclaration v a)
hashConstructors :: forall v a. Ord v => TypecheckedUnisonFile v a -> Map v Id

-- | Returns the set of constructor names for decls whose names in the
--   given Set.
constructorsForDecls :: Ord v => Set v -> TypecheckedUnisonFile v a -> Set v
hashTerms :: TypecheckedUnisonFile v a -> Map v (a, Reference, Maybe WatchKind, Term v a, Type v a)
indexByReference :: TypecheckedUnisonFile v a -> (Map Id (a, Term v a, Type v a), Map Id (Decl v a))
lookupDecl :: Ord v => v -> TypecheckedUnisonFile v a -> Maybe (Id, Decl v a)
nonEmpty :: TypecheckedUnisonFile v a -> Bool
termSignatureExternalLabeledDependencies :: Ord v => TypecheckedUnisonFile v a -> Set LabeledDependency

-- | the top level components (no watches) plus test watches.
topLevelComponents :: TypecheckedUnisonFile v a -> [[(v, a, Term v a, Type v a)]]
typecheckedUnisonFile :: forall v a. Var v => Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> [[(v, a, Term v a, Type v a)]] -> [(WatchKind, [(v, a, Term v a, Type v a)])] -> TypecheckedUnisonFile v a
rewrite :: (Var v, Eq a) => Set v -> (Term v a -> Maybe (Term v a)) -> UnisonFile v a -> ([v], UnisonFile v a)

-- | This function should be called in preparation for a call to
--   UnisonFile.rewrite. It prevents the possibility of accidental variable
--   capture while still allowing the rules to capture variables where
--   that's the intent. For example:
--   
--   f x = x + 42 ex = List.map (x -&gt; Nat.increment x) [1,2,3]
--   
--   rule1 f = <tt>rewrite term (x -&gt; f x) ==&gt; f rule2 = </tt>rewrite
--   term (x -&gt; f x) ==&gt; f
--   
--   Here, <tt>rule1</tt> introduces a variable <tt>f</tt>, which can stand
--   for any definition. Whereas <tt>rule2</tt> refers to the top-level
--   <tt>f</tt> function in the file.
--   
--   This function returns a tuple of: (prepareRule, preparedFile, finish)
--   <tt>prepareRule</tt> should be called on any `@rewrite` block to do
--   prevent accidental capture. It receives the [v] of variables bound
--   locally by the rule (<tt>rule1</tt> above binds <tt>f</tt>).
--   <tt>preparedFile</tt> should be passed to <a>rewrite</a>
--   <tt>finish</tt> should be called on the result of <a>rewrite</a>
--   
--   Internally, the function works by replacing all free variables in the
--   file with a unique reference, performing the rewrite using the ABT
--   machinery, then converting back to a "regular" UnisonFile with free
--   variables in the terms.
prepareRewrite :: (Monoid a, Var v) => UnisonFile v a -> ([v] -> Term v a -> Term v a, UnisonFile v a, UnisonFile v a -> UnisonFile v a)

module Unison.UnisonFile.Names
toNames :: Var v => UnisonFile v a -> Names
addNamesFromUnisonFile :: Var v => UnisonFile v a -> Names -> Names
typecheckedToNames :: Var v => TypecheckedUnisonFile v a -> Names
addNamesFromTypeCheckedUnisonFile :: Var v => TypecheckedUnisonFile v a -> Names -> Names
typecheckedUnisonFile0 :: Ord v => TypecheckedUnisonFile v a
bindNames :: Var v => Names -> UnisonFile v a -> ResolutionResult v a (UnisonFile v a)

-- | Given the set of fully-qualified variable names, this computes a Map
--   from unique suffixes to the fully qualified name.
--   
--   Example, given [foo.bar, qux.bar, baz.quaffle], this returns:
--   
--   Map [ foo.bar -&gt; foo.bar , qux.bar -&gt; qux.bar , baz.quaffle
--   -&gt; baz.quaffle , quaffle -&gt; baz.quaffle ]
--   
--   This is used to replace variable references with their canonical fully
--   qualified variables.
--   
--   It's used below in <a>environmentFor</a> and also during the term
--   resolution process.
variableCanonicalizer :: forall v. Var v => [v] -> Map v v
environmentFor :: forall v a. Var v => Names -> Map v (DataDeclaration v a) -> Map v (EffectDeclaration v a) -> ResolutionResult v a (Either [Error v a] (Env v a))

module Unison.UnisonFile.Summary

-- | A file that parses might not always type-check, but often we just want
--   to get as much information as we have available. This provides a type
--   where we can summarize the information available in a Unison file.
--   
--   If the file typechecked then all the Ref Ids and types will be filled
--   in, otherwise they will be Nothing.
data FileSummary
FileSummary :: Map Symbol (Id, DataDeclaration Symbol Ann) -> Map Id (Map Symbol (DataDeclaration Symbol Ann)) -> Map Symbol (Id, EffectDeclaration Symbol Ann) -> Map Id (Map Symbol (EffectDeclaration Symbol Ann)) -> Map Symbol (Ann, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann)) -> Map (Maybe Id) (Map Symbol (Ann, Term Symbol Ann, Maybe (Type Symbol Ann))) -> [(Ann, Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))] -> [(Ann, Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann), Maybe WatchKind)] -> Names -> FileSummary
[$sel:dataDeclsBySymbol:FileSummary] :: FileSummary -> Map Symbol (Id, DataDeclaration Symbol Ann)
[$sel:dataDeclsByReference:FileSummary] :: FileSummary -> Map Id (Map Symbol (DataDeclaration Symbol Ann))
[$sel:effectDeclsBySymbol:FileSummary] :: FileSummary -> Map Symbol (Id, EffectDeclaration Symbol Ann)
[$sel:effectDeclsByReference:FileSummary] :: FileSummary -> Map Id (Map Symbol (EffectDeclaration Symbol Ann))
[$sel:termsBySymbol:FileSummary] :: FileSummary -> Map Symbol (Ann, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))
[$sel:termsByReference:FileSummary] :: FileSummary -> Map (Maybe Id) (Map Symbol (Ann, Term Symbol Ann, Maybe (Type Symbol Ann)))
[$sel:testWatchSummary:FileSummary] :: FileSummary -> [(Ann, Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))]
[$sel:exprWatchSummary:FileSummary] :: FileSummary -> [(Ann, Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann), Maybe WatchKind)]
[$sel:fileNames:FileSummary] :: FileSummary -> Names
allWatches :: FileSummary -> [(Ann, Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann), Maybe WatchKind)]
allTypeDecls :: FileSummary -> Map Symbol (Id, Either (EffectDeclaration Symbol Ann) (DataDeclaration Symbol Ann))

-- | Summarize the information available to us from the current state of
--   the file. See <a>FileSummary</a> for more information.
mkFileSummary :: Maybe (UnisonFile Symbol Ann) -> Maybe (TypecheckedUnisonFile Symbol Ann) -> Maybe FileSummary

-- | Compute the location of user defined definitions within the file
fileDefLocations :: FileSummary -> Map Symbol (Set Ann)
instance GHC.Show.Show Unison.UnisonFile.Summary.FileSummary

module Unison.Codebase.CodeLookup.Util
fromTypecheckedUnisonFile :: forall m v a. (Var v, Monad m) => TypecheckedUnisonFile v a -> CodeLookup v m a

module Unison.Syntax.TypePrinter
pretty :: Var v => PrettyPrintEnv -> Type v a -> Pretty ColorText
pretty0 :: forall v a m. MonadPretty v m => Imports -> Int -> Type v a -> m (Pretty SyntaxText)
prettyRaw :: forall v a m. MonadPretty v m => Imports -> Int -> Type v a -> m (Pretty SyntaxText)
prettyStr :: Var v => Maybe Width -> PrettyPrintEnv -> Type v a -> String
prettySyntax :: Var v => PrettyPrintEnv -> Type v a -> Pretty SyntaxText
prettySignaturesST :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> [Pretty SyntaxText]
prettySignaturesCT :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> [Pretty ColorText]
prettySignaturesCTCollapsed :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> Pretty ColorText
prettySignaturesAlt :: Var v => PrettyPrintEnv -> [([HashQualified Name], Type v a)] -> Pretty ColorText
prettySignaturesAlt' :: Var v => PrettyPrintEnv -> [([HashQualified Name], Type v a)] -> [Pretty ColorText]
runPretty :: Var v => PrettyPrintEnv -> Reader (PrettyPrintEnv, Set v) a -> a

module Unison.Syntax.TypeParser
computationType :: (Monad m, Var v) => TypeP v m
valueType :: (Monad m, Var v) => TypeP v m
valueTypeLeaf :: (Monad m, Var v) => TypeP v m

module Unison.Syntax.TermPrinter
emptyAc :: AmbientContext
pretty :: Var v => PrettyPrintEnv -> Term v a -> Pretty ColorText
prettyBlock :: Var v => Bool -> PrettyPrintEnv -> Term v a -> Pretty ColorText
prettyBlock' :: Var v => Bool -> PrettyPrintEnv -> Term v a -> Pretty SyntaxText
pretty' :: Var v => Maybe Width -> PrettyPrintEnv -> Term v a -> ColorText

-- | Render a binding, producing output of the form
--   
--   foo : t -&gt; u foo a = ...
--   
--   The first line is only output if the term has a type annotation as the
--   outermost constructor.
--   
--   Binary functions with symbolic names are output infix, as follows:
--   
--   (+) : t -&gt; t -&gt; t a + b = ...
prettyBinding :: Var v => PrettyPrintEnv -> HashQualified Name -> Term2 v at ap v a -> Pretty SyntaxText
prettyBinding' :: Var v => PrettyPrintEnv -> Width -> HashQualified Name -> Term v a -> ColorText

-- | Like <a>prettyBinding</a>, but elides the type signature (if any).
prettyBindingWithoutTypeSignature :: Var v => PrettyPrintEnv -> HashQualified Name -> Term2 v at ap v a -> Pretty SyntaxText
pretty0 :: forall v m. MonadPretty v m => AmbientContext -> Term3 v PrintAnnotation -> m (Pretty SyntaxText)
runPretty :: Var v => PrettyPrintEnv -> Reader (PrettyPrintEnv, Set v) a -> a
prettyPattern :: forall v loc. Var v => PrettyPrintEnv -> AmbientContext -> Int -> [v] -> Pattern loc -> (Pretty SyntaxText, [v])
instance GHC.Show.Show Unison.Syntax.TermPrinter.BlockContext
instance GHC.Classes.Eq Unison.Syntax.TermPrinter.BlockContext
instance GHC.Show.Show Unison.Syntax.TermPrinter.InfixContext
instance GHC.Classes.Eq Unison.Syntax.TermPrinter.InfixContext
instance GHC.Show.Show Unison.Syntax.TermPrinter.DocLiteralContext
instance GHC.Classes.Eq Unison.Syntax.TermPrinter.DocLiteralContext
instance GHC.Show.Show Unison.Syntax.TermPrinter.PrintAnnotation
instance GHC.Base.Semigroup Unison.Syntax.TermPrinter.PrintAnnotation
instance GHC.Base.Monoid Unison.Syntax.TermPrinter.PrintAnnotation

module Unison.PatternMatchCoverage.Pretty
prettyVar :: Var v => v -> Pretty ColorText
prettyConstructorReference :: PrettyPrintEnv -> ConstructorReference -> Pretty ColorText

module Unison.PatternMatchCoverage.PmGrd
data PmGrd vt v loc

-- | <tt>PmCon x Con xs ys</tt> corresponds to the constraint <tt>Con ys
--   &lt;- x</tt>
PmCon :: v -> ConstructorReference -> [(v, Type vt loc)] -> PmGrd vt v loc
PmEffect :: v -> ConstructorReference -> [(v, Type vt loc)] -> PmGrd vt v loc
PmEffectPure :: v -> (v, Type vt loc) -> PmGrd vt v loc
PmLit :: v -> PmLit -> PmGrd vt v loc
PmListHead :: v -> Int -> v -> Type vt loc -> PmGrd vt v loc
PmListTail :: v -> Int -> v -> Type vt loc -> PmGrd vt v loc

-- | The size of the list must fall within this inclusive range
PmListInterval :: v -> Int -> Int -> PmGrd vt v loc

-- | If a guard performs an effect
PmBang :: v -> PmGrd vt v loc

-- | <tt>PmLet x expr</tt> corresponds to a <tt>let x = expr</tt> guard.
--   This actually <i>binds</i> <tt>x</tt>.
PmLet :: v -> Term' vt v loc -> Type vt loc -> PmGrd vt v loc
prettyPmGrd :: (Var vt, Var v) => PrettyPrintEnv -> PmGrd vt v loc -> Pretty ColorText
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.PmGrd.PmGrd vt v loc)

module Unison.PatternMatchCoverage.Desugar

-- | Desugar a match into a <a>GrdTree</a>
desugarMatch :: forall loc vt v m. Pmc vt v loc m => loc -> Type vt loc -> v -> [MatchCase loc (Term' vt v loc)] -> m (GrdTree (PmGrd vt v loc) loc)
instance GHC.Base.Functor (Unison.PatternMatchCoverage.Desugar.NormalizedListF loc)

module Unison.PatternMatchCoverage.EffectHandler
data EffectHandler
NoEffect :: EffectHandler
Effect :: ConstructorReference -> EffectHandler
prettyEffectHandler :: PrettyPrintEnv -> EffectHandler -> Pretty ColorText
instance GHC.Generics.Generic Unison.PatternMatchCoverage.EffectHandler.EffectHandler
instance GHC.Classes.Ord Unison.PatternMatchCoverage.EffectHandler.EffectHandler
instance GHC.Classes.Eq Unison.PatternMatchCoverage.EffectHandler.EffectHandler
instance GHC.Show.Show Unison.PatternMatchCoverage.EffectHandler.EffectHandler

module Unison.PatternMatchCoverage.Constraint

-- | A constraint to add to a <a>normalized constraint set</a> (fig 6) See
--   <a>addConstraint</a>
data Constraint vt v loc

-- | Positive constraint regarding data type. States that the given
--   variable must be the given constructor, and it also binds variables
--   corresponding to constructor arguments.
PosCon :: v -> ConstructorReference -> [(v, Type vt loc)] -> Constraint vt v loc

-- | Negative constraint concerning data type. States that the given
--   variable must not be the given constructor.
NegCon :: v -> ConstructorReference -> Constraint vt v loc

-- | Positive constraint regarding data type. States that the given
--   variable must be the given constructor, and it also binds variables
--   corresponding to constructor arguments.
PosEffect :: v -> EffectHandler -> [(v, Type vt loc)] -> Constraint vt v loc

-- | Negative constraint concerning data type. States that the given
--   variable must not be the given constructor.
NegEffect :: v -> EffectHandler -> Constraint vt v loc

-- | Positive constraint regarding literal
PosLit :: v -> PmLit -> Constraint vt v loc

-- | Negative constraint regarding literal
NegLit :: v -> PmLit -> Constraint vt v loc

-- | Positive constraint on list element with position relative to head of
--   list
PosListHead :: v -> Int -> v -> Constraint vt v loc

-- | Positive constraint on list element with position relative to end of
--   list
PosListTail :: v -> Int -> v -> Constraint vt v loc

-- | Negative constraint on length of the list (<i>i.e.</i> the list may
--   not be an element of the interval set)
NegListInterval :: v -> IntervalSet -> Constraint vt v loc

-- | An effect is performed
Effectful :: v -> Constraint vt v loc

-- | Equality constraint
Eq :: v -> v -> Constraint vt v loc
prettyConstraint :: forall vt v loc. (Var vt, Var v) => PrettyPrintEnv -> Constraint vt v loc -> Pretty ColorText
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.Constraint.Constraint vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.Constraint.Constraint vt v loc)

module Unison.PatternMatchCoverage.NormalizedConstraints

-- | Normalized refinement types (fig 6)
--   
--   Each variable may be associated with a number of constraints
--   represented by <a>VarInfo</a>. A <a>NormalizedConstraints</a> is
--   conceptually the conjunction of all constraints in the map.
--   Disjunction is represented by passing a Set of NormalizedConstraints.
--   So, the constraints are normalized into disjunctive normal form and
--   each <tt>NormalizedConstraints</tt> is a DNF term.
--   
--   Additionally, the following invariants are enforced (Section 3.4)
--   
--   <ul>
--   <li>Mutual compatibility: No two constraints should conflict with each
--   other.</li>
--   <li>Inhabitation: There must be at least one value that inhabits each
--   refinement type. (N.B. We don't truly know if a type is inhabited, see
--   <tt>inhabited</tt> in <a>Unison.PatternMatchCoverage.Solve</a> for
--   details. However, the refinement type is inhabited as far as our
--   inhabitation checker is concerned.)</li>
--   </ul>
--   
--   These invariants ensure that each term in our DNF has at least one
--   solution, and it is easy to expand and print these solutions.
data NormalizedConstraints vt v loc
NormalizedConstraints :: UFMap v (VarInfo vt v loc) -> Set v -> NormalizedConstraints vt v loc

-- | Constraints keyed by the variable they constrain. Equality constraints
--   are handled by <a>UFMap</a>.
[$sel:constraintMap:NormalizedConstraints] :: NormalizedConstraints vt v loc -> UFMap v (VarInfo vt v loc)

-- | dirty variables are ones that must be checked for inhabitance
[$sel:dirtySet:NormalizedConstraints] :: NormalizedConstraints vt v loc -> Set v

-- | Normalized constraints on a specific variable
data VarInfo vt v loc
VarInfo :: v -> Type vt loc -> VarConstraints vt v loc -> EffectInfo -> VarInfo vt v loc
[$sel:vi_id:VarInfo] :: VarInfo vt v loc -> v
[$sel:vi_typ:VarInfo] :: VarInfo vt v loc -> Type vt loc
[$sel:vi_con:VarInfo] :: VarInfo vt v loc -> VarConstraints vt v loc
[$sel:vi_eff:VarInfo] :: VarInfo vt v loc -> EffectInfo

-- | The constraints are different for different types, although most of
--   them take the form of an optional positive constraint and a set of
--   negative constraints.
data VarConstraints vt v loc
Vc'Constructor :: Maybe (ConstructorReference, [(v, Type vt loc)]) -> Set ConstructorReference -> VarConstraints vt v loc
Vc'Effect :: Maybe (EffectHandler, [(v, Type vt loc)]) -> Set EffectHandler -> VarConstraints vt v loc
Vc'Boolean :: Maybe Bool -> Set Bool -> VarConstraints vt v loc
Vc'Int :: Maybe Int64 -> Set Int64 -> VarConstraints vt v loc
Vc'Nat :: Maybe Word64 -> Set Word64 -> VarConstraints vt v loc
Vc'Float :: Maybe Double -> Set Double -> VarConstraints vt v loc
Vc'Text :: Maybe Text -> Set Text -> VarConstraints vt v loc
Vc'Char :: Maybe Char -> Set Char -> VarConstraints vt v loc
Vc'ListRoot :: Type vt loc -> Seq v -> Seq v -> IntervalSet -> VarConstraints vt v loc
data EffectInfo
IsEffectful :: EffectInfo
IsNotEffectful :: EffectInfo

-- | Mark a variable as requiring a new test for inhabitation.
markDirty :: Ord v => v -> NormalizedConstraints vt v loc -> NormalizedConstraints vt v loc
emptyNormalizedConstraints :: Ord v => NormalizedConstraints vt v loc

-- | Generic function to lookup or alter constraints in the constraint map.
--   Throws an error if the variable is not in the map.
updateF :: forall vt v loc f. (Var v, Functor f) => v -> (v -> VarInfo vt v loc -> f (ConstraintUpdate (VarInfo vt v loc))) -> NormalizedConstraints vt v loc -> f (NormalizedConstraints vt v loc)
data ConstraintUpdate a
Update :: a -> ConstraintUpdate a
Ignore :: ConstraintUpdate a

-- | Lookup the canonical value of <tt>v</tt> from the constraint map.
--   Throws an error if the variable is not in the map.
expectCanon :: forall vt v loc. Var v => v -> NormalizedConstraints vt v loc -> (v, VarInfo vt v loc, NormalizedConstraints vt v loc)

-- | Install a new variable into the constraint map. Throws an error if the
--   variable already exists in the map.
declVar :: forall vt v loc. Var v => v -> Type vt loc -> (VarInfo vt v loc -> VarInfo vt v loc) -> NormalizedConstraints vt v loc -> NormalizedConstraints vt v loc
prettyNormalizedConstraints :: forall vt v loc. (Var v, Var vt) => PrettyPrintEnv -> NormalizedConstraints vt v loc -> Pretty ColorText
prettyDnf :: (Var v, Var vt) => PrettyPrintEnv -> Set (NormalizedConstraints vt v loc) -> Pretty ColorText
instance GHC.Base.Functor Unison.PatternMatchCoverage.NormalizedConstraints.ConstraintUpdate
instance GHC.Generics.Generic (Unison.PatternMatchCoverage.NormalizedConstraints.VarConstraints vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.NormalizedConstraints.VarConstraints vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.NormalizedConstraints.VarConstraints vt v loc)
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.NormalizedConstraints.VarConstraints vt v loc)
instance GHC.Classes.Ord Unison.PatternMatchCoverage.NormalizedConstraints.EffectInfo
instance GHC.Classes.Eq Unison.PatternMatchCoverage.NormalizedConstraints.EffectInfo
instance GHC.Show.Show Unison.PatternMatchCoverage.NormalizedConstraints.EffectInfo
instance GHC.Generics.Generic (Unison.PatternMatchCoverage.NormalizedConstraints.VarInfo vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.NormalizedConstraints.VarInfo vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.NormalizedConstraints.VarInfo vt v loc)
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.NormalizedConstraints.VarInfo vt v loc)
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.NormalizedConstraints.NormalizedConstraints vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.NormalizedConstraints.NormalizedConstraints vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.NormalizedConstraints.NormalizedConstraints vt v loc)

module Unison.PatternMatchCoverage.Literal

-- | Refinement type literals (fig 3)
data Literal vt v loc

-- | True
T :: Literal vt v loc

-- | False
F :: Literal vt v loc

-- | Positive constraint regarding data type. States that the given
--   variable must be the given constructor, and it also binds variables
--   corresponding to constructor arguments.
PosCon :: v -> ConstructorReference -> [(v, Type vt loc)] -> Literal vt v loc

-- | Negative constraint concerning data type. States that the given
--   variable must not be the given constructor.
NegCon :: v -> ConstructorReference -> Literal vt v loc

-- | Positive constraint regarding data type. States that the given
--   variable must be the given constructor, and it also binds variables
--   corresponding to constructor arguments.
PosEffect :: v -> EffectHandler -> [(v, Type vt loc)] -> Literal vt v loc

-- | Negative constraint concerning data type. States that the given
--   variable must not be the given constructor.
NegEffect :: v -> EffectHandler -> Literal vt v loc

-- | Positive constraint regarding literal
PosLit :: v -> PmLit -> Literal vt v loc

-- | Negative constraint regarding literal
NegLit :: v -> PmLit -> Literal vt v loc

-- | Positive constraint on list element with position relative to head of
--   list
PosListHead :: v -> Int -> v -> Type vt loc -> Literal vt v loc

-- | Positive constraint on list element with position relative to end of
--   list
PosListTail :: v -> Int -> v -> Type vt loc -> Literal vt v loc

-- | Negative constraint on length of the list (<i>i.e.</i> the list may
--   not be an element of the interval set)
NegListInterval :: v -> IntervalSet -> Literal vt v loc

-- | An effect is performed
Effectful :: v -> Literal vt v loc

-- | Introduce a binding for a term
Let :: v -> Term' vt v loc -> Type vt loc -> Literal vt v loc
prettyLiteral :: Var v => Literal (TypeVar b v) v loc -> Pretty ColorText
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.Literal.Literal vt v loc)

module Unison.Syntax.TermParser

-- | Rules for the annotation of the resulting binding is as follows: * If
--   the binding has a type signature, the top level scope of the
--   annotation for the type Ann node will contain the _entire_ binding,
--   including the type signature. * The body expression of the binding
--   contains the entire lhs (including the name of the binding) and the
--   entire body. * If the binding is a lambda, the lambda node includes
--   the entire LHS of the binding, including the name as well.
binding :: forall m v. (Monad m, Var v) => P v m ((Ann, v), Term v Ann)
blockTerm :: (Monad m, Var v) => TermP v m
doc2Block :: forall m v. (Monad m, Var v) => P v m (Ann, Term v Ann)
imports :: (Monad m, Var v) => P v m (Names, [(v, v)])
lam :: Var v => TermP v m -> TermP v m
substImports :: Var v => Names -> [(v, v)] -> Term v Ann -> Term v Ann
term :: (Monad m, Var v) => TermP v m
verifyRelativeVarName :: Var v => P v m (Token v) -> P v m (Token v)
instance GHC.Show.Show Unison.Syntax.TermParser.UnbreakCase
instance GHC.Classes.Eq Unison.Syntax.TermParser.UnbreakCase
instance GHC.Show.Show v => GHC.Show.Show (Unison.Syntax.TermParser.BlockElement v)

module Unison.Syntax.DeclParser
declarations :: (Monad m, Var v) => P v m (Map v (DataDeclaration v Ann), Map v (EffectDeclaration v Ann), Accessors v)

module Unison.Syntax.FileParser
file :: forall m v. (Monad m, Var v) => P v m (UnisonFile v Ann)
instance GHC.Base.Functor (Unison.Syntax.FileParser.Stanza v)
instance Data.Traversable.Traversable (Unison.Syntax.FileParser.Stanza v)
instance Data.Foldable.Foldable (Unison.Syntax.FileParser.Stanza v)

module Unison.PatternMatchCoverage.Solve

-- | top-down traversal of the <a>GrdTree</a> that produces:
--   
--   <ul>
--   <li>a refinement type describing values that do not match the
--   <a>GrdTree</a> (the "uncovered" set)</li>
--   <li>a new <a>GrdTree</a> annotated with refinement types at the nodes
--   describing values that cause an effect to be performed and values that
--   match the case at the leaves.</li>
--   </ul>
--   
--   If the former is inhabited then its inhabitants are unmatched values.
--   If the leaves of the latter are inhabited then the case is redundant.
uncoverAnnotate :: forall vt v loc m l. Pmc vt v loc m => Set (NormalizedConstraints vt v loc) -> GrdTree (PmGrd vt v loc) l -> m (Set (NormalizedConstraints vt v loc), GrdTree (Set (NormalizedConstraints vt v loc)) (Set (NormalizedConstraints vt v loc), l))

-- | Collect accessible, inaccessible, and redundant GRHSs
classify :: forall vt v loc l. GrdTree (Set (NormalizedConstraints vt v loc)) (Set (NormalizedConstraints vt v loc), l) -> ([l], [l], [l])

-- | Given a variable and a term in DNF, expand it to an identical DNF
--   expression with enough positive info to print pattern suggestions.
expandSolution :: forall vt v loc m. Pmc vt v loc m => v -> NormalizedConstraints vt v loc -> m (Set (NormalizedConstraints vt v loc))

-- | Expand a full DNF term (i.e. each term identifies exactly one
--   solution) into an inhabiting pattern.
generateInhabitants :: forall vt v loc. Var v => v -> NormalizedConstraints vt v loc -> Pattern ()
instance GHC.Num.Num Unison.PatternMatchCoverage.Solve.Fuel
instance GHC.Enum.Bounded Unison.PatternMatchCoverage.Solve.Fuel
instance GHC.Enum.Enum Unison.PatternMatchCoverage.Solve.Fuel
instance GHC.Classes.Ord Unison.PatternMatchCoverage.Solve.Fuel
instance GHC.Classes.Eq Unison.PatternMatchCoverage.Solve.Fuel
instance GHC.Show.Show Unison.PatternMatchCoverage.Solve.Fuel
instance Control.Monad.Trans.Class.MonadTrans (Unison.PatternMatchCoverage.Solve.C vt v loc)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (Unison.PatternMatchCoverage.NormalizedConstraints.NormalizedConstraints vt v loc) (Unison.PatternMatchCoverage.Solve.C vt v loc m)
instance GHC.Base.Monad m => GHC.Base.Monad (Unison.PatternMatchCoverage.Solve.C vt v loc m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Unison.PatternMatchCoverage.Solve.C vt v loc m)
instance GHC.Base.Functor m => GHC.Base.Functor (Unison.PatternMatchCoverage.Solve.C vt v loc m)


-- | Pattern match coverage checking is implemented following the algorithm
--   described in <a>Lower Your Guards</a>. The goal of pattern match
--   coverage checking is to identify the following problems that may arise
--   in a pattern match:
--   
--   <ul>
--   <li>It is missing clauses (<i>i.e.</i> it is non-exhaustive)</li>
--   <li>It contains redundant patterns (<i>i.e.</i> the case can be
--   deleted without altering the program)</li>
--   <li>It contains inaccessible patterns (<i>i.e</i> the rhs can never be
--   entered)</li>
--   </ul>
--   
--   Furthermore, in the case of a non-exhaustive match, the goal to
--   present the user with concrete values that do not match any of the
--   existing patterns.
--   
--   <i>N.B.</i> An inaccessible pattern in unison would be one that
--   performs effects in a guard although the constraints are
--   unsatisfiable. Such a pattern cannot be deleted without altering the
--   program.
--   
--   <h2>High-level algorithm overview</h2>
--   
--   <ol>
--   <li><a>Desugar</a> a match expression into a <a>GrdTree</a>.</li>
--   <li>Annotate the <tt>GrdTree</tt> leaves with <a>refinement types</a>
--   describing values that match this branch. Redundant and inaccessible
--   patterns are then identified by <tt>GrdTree</tt> leaves with
--   uninhabited refinement types. Inaccessible patterns are distinguished
--   by an effect being performed between the <tt>GrdTree</tt> root and the
--   leaf.</li>
--   <li>Traverse the <tt>GrdTree</tt> building up a refinement type
--   describing uncovered values. If the resulting refinement type is
--   inhabited then the match is missing clauses.</li>
--   <li>Find inhabitants of the uncovered refinement type to present to
--   the user.</li>
--   </ol>
--   
--   Step (1) is implemented by <a>desugarMatch</a>. Steps (2) and (3) are
--   implemented as a single traversal:
--   <a>uncoverAnnotate</a>/<a>classify</a>. Step (4) is implemented by
--   <a>expandSolution</a>/<a>generateInhabitants</a>.
module Unison.PatternMatchCoverage

-- | Perform pattern match coverage checking on a match expression
checkMatch :: forall vt v loc m. Pmc vt v loc m => loc -> Type vt loc -> [MatchCase loc (Term' vt v loc)] -> m ([loc], [loc], [Pattern ()])


-- | Handles generating kind constraints to be fed to the kind constraint
--   solver (found in <a>Unison.KindInference.Solve</a>).
module Unison.KindInference.Generate

-- | Generate kind constraints arising from a given type. The given
--   <tt>UVar</tt> is constrained to have the kind of the given type.
typeConstraints :: (Var v, Ord loc) => UVar v loc -> Type v loc -> Gen v loc [GeneratedConstraint v loc]

-- | Check that all annotations in a term are well-kinded
termConstraints :: forall v loc. (Var v, Ord loc) => Term v loc -> Gen v loc [GeneratedConstraint v loc]

-- | Generate kind constraints for a mutally recursive component of decls
declComponentConstraints :: forall v loc. (Var v, Ord loc) => [(Reference, Decl v loc)] -> Gen v loc [GeneratedConstraint v loc]

-- | Constraints on language builtins, used to initialize the kind
--   inference state (<a>initialState</a>)
builtinConstraints :: forall v loc. (Ord loc, BuiltinAnnotation loc, Var v) => Gen v loc [GeneratedConstraint v loc]


-- | Handles solving kind constraints generated by
--   <a>Unison.KindInference.Generate</a>.
module Unison.KindInference.Solve

-- | This is the primary function in the exposed API. <tt>step</tt> applies
--   some generated constraints to a solve state, returning a kind error if
--   detected or a new solve state.
step :: (Var v, Ord loc, Show loc) => Env -> SolveState v loc -> [GeneratedConstraint v loc] -> Either (NonEmpty (KindError v loc)) (SolveState v loc)

-- | Do an occurence check and return an error or the resulting solve state
verify :: Var v => SolveState v loc -> Either (NonEmpty (KindError v loc)) (SolveState v loc)
initialState :: forall v loc. (BuiltinAnnotation loc, Show loc, Ord loc, Var v) => Env -> SolveState v loc

-- | Default any unconstrained vars to <tt>Type</tt>
defaultUnconstrainedVars :: Var v => SolveState v loc -> SolveState v loc

-- | Errors that may arise during kind inference
data KindError v loc

-- | A variable is constrained to have an infinite kind
CycleDetected :: loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc

-- | Something of kind * or Effect is applied to an argument
UnexpectedArgument :: loc -> UVar v loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc
ArgumentMismatch :: UVar v loc -> UVar v loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc
ArgumentMismatchArrow :: (loc, Type v loc, Type v loc) -> ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc

-- | Something appeared in an effect list that isn't of kind Effect
EffectListMismatch :: ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc

-- | Generic constraint conflict
ConstraintConflict :: GeneratedConstraint v loc -> ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc

-- | Two incompatible constraints on a <tt>UVar</tt>.
data ConstraintConflict v loc
ConstraintConflict' :: UVar v loc -> Constraint (UVar v loc) v loc -> Constraint (UVar v loc) v loc -> ConstraintConflict v loc
[$sel:conflictedVar:ConstraintConflict'] :: ConstraintConflict v loc -> UVar v loc
[$sel:impliedConstraint:ConstraintConflict'] :: ConstraintConflict v loc -> Constraint (UVar v loc) v loc
[$sel:conflictedConstraint:ConstraintConflict'] :: ConstraintConflict v loc -> Constraint (UVar v loc) v loc


-- | Kind inference for Unison
--   
--   Unison has Type, -&gt;, and Ability kinds
--   
--   An algorithm sketch: First break all decls into strongly connected
--   components in reverse topological order. Then, for each component,
--   generate kind constraints that arise from the constructors in the decl
--   to discover constraints on the decl vars. These constraints are then
--   given to a constraint solver that determines a unique kind for each
--   type variable. Unconstrained variables are defaulted to kind Type
--   (just like Haskell 98). This is done by <a>inferDecls</a>.
--   
--   Afterwards, the <a>SolveState</a> holds the kinds of all decls and we
--   can check that type annotations in terms that may mention the decls
--   are well-kinded with <a>kindCheckAnnotations</a>.
module Unison.KindInference

-- | Infer the kinds of all decl vars
inferDecls :: forall v loc. (Var v, BuiltinAnnotation loc, Ord loc, Show loc) => PrettyPrintEnv -> Map Reference (Decl v loc) -> Either (NonEmpty (KindError v loc)) (SolveState v loc)

-- | Check that all annotations in a term are well-kinded
kindCheckAnnotations :: forall v loc. (Var v, Ord loc, Show loc, BuiltinAnnotation loc) => PrettyPrintEnv -> SolveState v loc -> Term v loc -> Either (NonEmpty (KindError v loc)) ()

-- | Errors that may arise during kind inference
data KindError v loc

module Unison.Typechecker.Context

-- | public interface to the typechecker
synthesizeClosed :: (BuiltinAnnotation loc, Var v, Ord loc, Show loc) => PrettyPrintEnv -> PatternMatchCoverageCheckAndKindInferenceSwitch -> [Type v loc] -> TypeLookup v loc -> Term v loc -> Result v loc (Type v loc)
data ErrorNote v loc
ErrorNote :: Cause v loc -> Seq (PathElement v loc) -> ErrorNote v loc
[$sel:cause:ErrorNote] :: ErrorNote v loc -> Cause v loc
[$sel:path:ErrorNote] :: ErrorNote v loc -> Seq (PathElement v loc)
data CompilerBug v loc
UnknownDecl :: Unknown -> Reference -> Map Reference (DataDeclaration v loc) -> CompilerBug v loc
UnknownConstructor :: Unknown -> ConstructorReference -> DataDeclaration v loc -> CompilerBug v loc
UndeclaredTermVariable :: v -> Context v loc -> CompilerBug v loc
RetractFailure :: Element v loc -> Context v loc -> CompilerBug v loc
EmptyLetRec :: Term v loc -> CompilerBug v loc
PatternMatchFailure :: CompilerBug v loc
EffectConstructorHadMultipleEffects :: Type v loc -> CompilerBug v loc
FreeVarsInTypeAnnotation :: Set (TypeVar v loc) -> CompilerBug v loc
UnannotatedReference :: Reference -> CompilerBug v loc
MalformedPattern :: Pattern loc -> CompilerBug v loc
UnknownTermReference :: Reference -> CompilerBug v loc
UnknownExistentialVariable :: v -> Context v loc -> CompilerBug v loc
IllegalContextExtension :: Context v loc -> Element v loc -> String -> CompilerBug v loc
OtherBug :: String -> CompilerBug v loc
data InfoNote v loc
SolvedBlank :: Recorded loc -> v -> Type v loc -> InfoNote v loc
Decision :: v -> loc -> Term v loc -> InfoNote v loc
TopLevelComponent :: [(v, Type v loc, RedundantTypeAnnotation)] -> InfoNote v loc
data Cause v loc
TypeMismatch :: Context v loc -> Cause v loc
IllFormedType :: Context v loc -> Cause v loc
UnknownSymbol :: loc -> v -> Cause v loc
UnknownTerm :: loc -> v -> [Suggestion v loc] -> Type v loc -> Cause v loc
AbilityCheckFailure :: [Type v loc] -> [Type v loc] -> Context v loc -> Cause v loc
AbilityEqFailure :: [Type v loc] -> [Type v loc] -> Context v loc -> Cause v loc
EffectConstructorWrongArgCount :: ExpectedArgCount -> ActualArgCount -> ConstructorReference -> Cause v loc
MalformedEffectBind :: Type v loc -> Type v loc -> [Type v loc] -> Cause v loc
PatternArityMismatch :: loc -> Type v loc -> Int -> Cause v loc
DuplicateDefinitions :: NonEmpty (v, [loc]) -> Cause v loc
UnguardedLetRecCycle :: [v] -> [(v, Term v loc)] -> Cause v loc
ConcatPatternWithoutConstantLength :: loc -> Type v loc -> Cause v loc
HandlerOfUnexpectedType :: loc -> Type v loc -> Cause v loc
DataEffectMismatch :: Unknown -> Reference -> DataDeclaration v loc -> Cause v loc
UncoveredPatterns :: loc -> NonEmpty (Pattern ()) -> Cause v loc
RedundantPattern :: loc -> Cause v loc
KindInferenceFailure :: KindError v loc -> Cause v loc
InaccessiblePattern :: loc -> Cause v loc
newtype Context v loc
Context :: [(Element v loc, Info v loc)] -> Context v loc
type ActualArgCount = Int
type ExpectedArgCount = Int
type ConstructorId = Word64

-- | Elements of an ordered algorithmic context
data Element v loc

-- | A variable declaration
Var :: TypeVar v loc -> Element v loc

-- | <tt>v</tt> is solved to some monotype
Solved :: Blank loc -> v -> Monotype v loc -> Element v loc

-- | <tt>v</tt> has type <tt>a</tt>, maybe quantified
Ann :: v -> Type v loc -> Element v loc

-- | used for scoping
Marker :: v -> Element v loc
data PathElement v loc
InSynthesize :: Term v loc -> PathElement v loc
InSubtype :: Type v loc -> Type v loc -> PathElement v loc
InEquate :: Type v loc -> Type v loc -> PathElement v loc
InCheck :: Term v loc -> Type v loc -> PathElement v loc
InInstantiateL :: v -> Type v loc -> PathElement v loc
InInstantiateR :: Type v loc -> v -> PathElement v loc
InSynthesizeApp :: Type v loc -> Term v loc -> Int -> PathElement v loc
InFunctionCall :: [v] -> Term v loc -> Type v loc -> [Term v loc] -> PathElement v loc
InAndApp :: PathElement v loc
InOrApp :: PathElement v loc
InIfCond :: PathElement v loc
InIfBody :: loc -> PathElement v loc
InVectorApp :: loc -> PathElement v loc
InMatch :: loc -> PathElement v loc
InMatchGuard :: PathElement v loc
InMatchBody :: PathElement v loc
type Term v loc = Term' (TypeVar v loc) v loc
type Type v loc = Type (TypeVar v loc) loc
type TypeVar v loc = TypeVar (Blank loc) v
data Result v loc a
Success :: !Seq (InfoNote v loc) -> !a -> Result v loc a
TypeError :: !NESeq (ErrorNote v loc) -> !Seq (InfoNote v loc) -> Result v loc a
CompilerBug :: !CompilerBug v loc -> !Seq (ErrorNote v loc) -> !Seq (InfoNote v loc) -> Result v loc a
data PatternMatchCoverageCheckAndKindInferenceSwitch
PatternMatchCoverageCheckAndKindInferenceSwitch'Enabled :: PatternMatchCoverageCheckAndKindInferenceSwitch
PatternMatchCoverageCheckAndKindInferenceSwitch'Disabled :: PatternMatchCoverageCheckAndKindInferenceSwitch
errorTerms :: ErrorNote v loc -> [Term v loc]
innermostErrorTerm :: ErrorNote v loc -> Maybe (Term v loc)
lookupAnn :: Ord v => Context v loc -> v -> Maybe (Type v loc)
lookupSolved :: Ord v => Context v loc -> v -> Maybe (Monotype v loc)

-- | Replace any existentials with their solution in the context
apply :: (Var v, Ord loc) => Context v loc -> Type v loc -> Type v loc
isEqual :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
isSubtype :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
fitsScheme :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
isRedundant :: (Var v, Ord loc) => Type v loc -> Type v loc -> M v loc Bool
data Suggestion v loc
Suggestion :: Name -> Type v loc -> Replacement v -> SuggestionMatch -> Suggestion v loc
[$sel:suggestionName:Suggestion] :: Suggestion v loc -> Name
[$sel:suggestionType:Suggestion] :: Suggestion v loc -> Type v loc
[$sel:suggestionReplacement:Suggestion] :: Suggestion v loc -> Replacement v
[$sel:suggestionMatch:Suggestion] :: Suggestion v loc -> SuggestionMatch
data Replacement v
ReplacementRef :: Referent -> Replacement v
ReplacementVar :: v -> Replacement v
data SuggestionMatch
Exact :: SuggestionMatch
WrongType :: SuggestionMatch
WrongName :: SuggestionMatch
isExact :: Suggestion v loc -> Bool
typeErrors :: Result v loc a -> Seq (ErrorNote v loc)
infoNotes :: Result v loc a -> Seq (InfoNote v loc)
data Unknown
Data :: Unknown
Effect :: Unknown
relax :: Var v => Ord loc => Type v loc -> Type v loc
generalizeAndUnTypeVar :: Var v => Type v a -> Type v a
instance GHC.Show.Show Unison.Typechecker.Context.Unknown
instance (GHC.Show.Show v, GHC.Show.Show loc) => GHC.Show.Show (Unison.Typechecker.Context.PathElement v loc)
instance GHC.Show.Show Unison.Typechecker.Context.SuggestionMatch
instance GHC.Classes.Eq Unison.Typechecker.Context.SuggestionMatch
instance GHC.Classes.Ord Unison.Typechecker.Context.SuggestionMatch
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.Context.Replacement v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Typechecker.Context.Replacement v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Typechecker.Context.Replacement v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.Context.Suggestion v loc)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Typechecker.Context.Suggestion v loc)
instance (GHC.Show.Show loc, GHC.Show.Show v) => GHC.Show.Show (Unison.Typechecker.Context.InfoNote v loc)
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.Cause v loc)
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.ErrorNote v loc)
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.CompilerBug v loc)
instance GHC.Base.Functor (Unison.Typechecker.Context.Result v loc)
instance GHC.Base.Functor f => GHC.Base.Functor (Unison.Typechecker.Context.MT v loc f)
instance (GHC.Classes.Ord loc, Unison.Var.Var v) => Unison.PatternMatchCoverage.Class.Pmc (Unison.Typechecker.Context.TypeVar v loc) v loc (Control.Monad.Trans.State.Lazy.StateT (Unison.Typechecker.Context.PmcState (Unison.Typechecker.Context.TypeVar v loc) v loc) (Unison.Typechecker.Context.M v loc))
instance GHC.Base.Monad f => GHC.Base.Monad (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => Control.Monad.Fail.MonadFail (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => GHC.Base.Applicative (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => Control.Monad.State.Class.MonadState (Unison.Typechecker.Context.Env v loc) (Unison.Typechecker.Context.MT v loc f)
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Applicative (Unison.Typechecker.Context.Result v loc)
instance GHC.Base.Monad (Unison.Typechecker.Context.Result v loc)
instance Control.Monad.Fix.MonadFix (Unison.Typechecker.Context.Result v loc)
instance (GHC.Classes.Ord loc, Unison.Var.Var v) => GHC.Show.Show (Unison.Typechecker.Context.Context v loc)
instance (GHC.Classes.Ord loc, Unison.Var.Var v) => GHC.Classes.Eq (Unison.Typechecker.Context.Element v loc)
instance Unison.Var.Var v => GHC.Show.Show (Unison.Typechecker.Context.Element v loc)

module Unison.Typechecker.Extractor
type RedundantTypeAnnotation = Bool
type Extractor e a = MaybeT (Reader e) a
type ErrorExtractor v loc a = Extractor (ErrorNote v loc) a
type InfoExtractor v loc a = Extractor (InfoNote v loc) a
type PathExtractor v loc a = Extractor (PathElement v loc) a
type SubseqExtractor v loc a = SubseqExtractor' (ErrorNote v loc) a
extractor :: (e -> Maybe a) -> Extractor e a
extract :: Extractor e a -> e -> Maybe a
subseqExtractor :: (ErrorNote v loc -> [Ranged a]) -> SubseqExtractor v loc a
traceSubseq :: Show a => String -> SubseqExtractor' n a -> SubseqExtractor' n a
traceNote :: Show a => String -> ErrorExtractor v loc a -> ErrorExtractor v loc a
unique :: SubseqExtractor v loc a -> ErrorExtractor v loc a
data SubseqExtractor' n a
SubseqExtractor' :: (n -> [Ranged a]) -> SubseqExtractor' n a
[$sel:runSubseq:SubseqExtractor'] :: SubseqExtractor' n a -> n -> [Ranged a]
data Ranged a
Pure :: a -> Ranged a
Ranged :: a -> Int -> Int -> Ranged a
[$sel:get:Pure] :: Ranged a -> a
[$sel:start:Pure] :: Ranged a -> Int
[$sel:end:Pure] :: Ranged a -> Int

-- | collects the regions where <tt>xa</tt> doesn't match / aka invert a
--   set of intervals unused, but don't want to delete it yet - Aug 30,
--   2018
_no :: SubseqExtractor' n a -> SubseqExtractor' n ()
_any :: SubseqExtractor v loc ()
_any' :: (n -> Int) -> SubseqExtractor' n ()
data DistinctRanged a
DistinctRanged :: a -> Int -> Int -> DistinctRanged a
some :: forall n a. SubseqExtractor' n a -> SubseqExtractor' n [a]
pathStart :: SubseqExtractor' n ()
asPathExtractor :: (PathElement v loc -> Maybe a) -> SubseqExtractor v loc a
inSynthesize :: SubseqExtractor v loc (Term v loc)
inSubtype :: SubseqExtractor v loc (Type v loc, Type v loc)
inEquate :: SubseqExtractor v loc (Type v loc, Type v loc)
inCheck :: SubseqExtractor v loc (Term v loc, Type v loc)
inSynthesizeApp :: SubseqExtractor v loc (Type v loc, Term v loc, Int)
inFunctionCall :: SubseqExtractor v loc ([v], Term v loc, Type v loc, [Term v loc])
inAndApp :: SubseqExtractor v loc ()
inOrApp :: SubseqExtractor v loc ()
inIfCond :: SubseqExtractor v loc ()
inMatchGuard :: SubseqExtractor v loc ()
inMatchBody :: SubseqExtractor v loc ()
inMatch :: SubseqExtractor v loc loc
inVector :: SubseqExtractor v loc loc
inIfBody :: SubseqExtractor v loc loc
cause :: ErrorExtractor v loc (Cause v loc)
duplicateDefinitions :: ErrorExtractor v loc (NonEmpty (v, [loc]))
uncoveredPatterns :: ErrorExtractor v loc (loc, NonEmpty (Pattern ()))
redundantPattern :: ErrorExtractor v loc loc
kindInferenceFailure :: ErrorExtractor v loc (KindError v loc)
typeMismatch :: ErrorExtractor v loc (Context v loc)
illFormedType :: ErrorExtractor v loc (Context v loc)
unknownSymbol :: ErrorExtractor v loc (loc, v)
unknownTerm :: Var v => ErrorExtractor v loc (loc, v, [Suggestion v loc], Type v loc)
abilityCheckFailure :: ErrorExtractor v loc ([Type v loc], [Type v loc], Context v loc)
abilityEqFailure :: ErrorExtractor v loc ([Type v loc], [Type v loc], Context v loc)
effectConstructorWrongArgCount :: ErrorExtractor v loc (ExpectedArgCount, ActualArgCount, ConstructorReference)
malformedEffectBind :: ErrorExtractor v loc (Type v loc, Type v loc, [Type v loc])
solvedBlank :: InfoExtractor v loc (Recorded loc, v, Type v loc)
errorNote :: ErrorExtractor v loc (ErrorNote v loc)
infoNote :: InfoExtractor v loc (InfoNote v loc)
innermostTerm :: ErrorExtractor v loc (Term v loc)
path :: ErrorExtractor v loc [PathElement v loc]
topLevelComponent :: InfoExtractor v loc [(v, Type v loc, RedundantTypeAnnotation)]
instance GHC.Show.Show a => GHC.Show.Show (Unison.Typechecker.Extractor.Ranged a)
instance GHC.Base.Functor Unison.Typechecker.Extractor.Ranged
instance GHC.Classes.Eq (Unison.Typechecker.Extractor.DistinctRanged a)
instance GHC.Classes.Ord (Unison.Typechecker.Extractor.DistinctRanged a)
instance GHC.Base.Functor (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Applicative (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance Control.Monad.Fail.MonadFail (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Monad (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Alternative (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.MonadPlus (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Monoid (Unison.Typechecker.Extractor.SubseqExtractor' n a)
instance GHC.Base.Semigroup (Unison.Typechecker.Extractor.SubseqExtractor' n a)

module Unison.Typechecker.TypeError
data BooleanMismatch
CondMismatch :: BooleanMismatch
AndMismatch :: BooleanMismatch
OrMismatch :: BooleanMismatch
GuardMismatch :: BooleanMismatch
data ExistentialMismatch
IfBody :: ExistentialMismatch
ListBody :: ExistentialMismatch
CaseBody :: ExistentialMismatch
data TypeError v loc
Mismatch :: Type v loc -> Type v loc -> Type v loc -> Type v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:foundLeaf:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedLeaf:Mismatch] :: TypeError v loc -> Type v loc
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
BooleanMismatch :: BooleanMismatch -> Term v loc -> Type v loc -> ErrorNote v loc -> TypeError v loc
[$sel:getBooleanMismatch:Mismatch] :: TypeError v loc -> BooleanMismatch
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
ExistentialMismatch :: ExistentialMismatch -> Type v loc -> loc -> Type v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[$sel:getExistentialMismatch:Mismatch] :: TypeError v loc -> ExistentialMismatch
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedLoc:Mismatch] :: TypeError v loc -> loc
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
FunctionApplication :: Term v loc -> Type v loc -> Term v loc -> Int -> Type v loc -> Type v loc -> Maybe (Type v loc, Type v loc) -> [(v, Type v loc)] -> ErrorNote v loc -> TypeError v loc
[$sel:f:Mismatch] :: TypeError v loc -> Term v loc
[$sel:ft:Mismatch] :: TypeError v loc -> Type v loc
[$sel:arg:Mismatch] :: TypeError v loc -> Term v loc
[$sel:argNum:Mismatch] :: TypeError v loc -> Int
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:leafs:Mismatch] :: TypeError v loc -> Maybe (Type v loc, Type v loc)
[$sel:solvedVars:Mismatch] :: TypeError v loc -> [(v, Type v loc)]
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
NotFunctionApplication :: Term v loc -> Type v loc -> ErrorNote v loc -> TypeError v loc
[$sel:f:Mismatch] :: TypeError v loc -> Term v loc
[$sel:ft:Mismatch] :: TypeError v loc -> Type v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
AbilityCheckFailure :: [Type v loc] -> [Type v loc] -> loc -> ErrorNote v loc -> TypeError v loc
[$sel:ambient:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:requested:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:abilityCheckFailureSite:Mismatch] :: TypeError v loc -> loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
AbilityEqFailure :: [Type v loc] -> [Type v loc] -> Type v loc -> Type v loc -> loc -> ErrorNote v loc -> TypeError v loc
[$sel:lhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:rhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:tlhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:trhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:abilityCheckFailureSite:Mismatch] :: TypeError v loc -> loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
AbilityEqFailureFromAp :: [Type v loc] -> [Type v loc] -> Type v loc -> Type v loc -> Term v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[$sel:lhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:rhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:tlhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:trhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UnguardedLetRecCycle :: [v] -> [loc] -> ErrorNote v loc -> TypeError v loc
[$sel:cycle:Mismatch] :: TypeError v loc -> [v]
[$sel:cycleLocs:Mismatch] :: TypeError v loc -> [loc]
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UnknownType :: v -> loc -> ErrorNote v loc -> TypeError v loc
[$sel:unknownTypeV:Mismatch] :: TypeError v loc -> v
[$sel:typeSite:Mismatch] :: TypeError v loc -> loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UnknownTerm :: v -> loc -> [Suggestion v loc] -> Type v loc -> ErrorNote v loc -> TypeError v loc
[$sel:unknownTermV:Mismatch] :: TypeError v loc -> v
[$sel:termSite:Mismatch] :: TypeError v loc -> loc
[$sel:suggestions:Mismatch] :: TypeError v loc -> [Suggestion v loc]
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
DuplicateDefinitions :: NonEmpty (v, [loc]) -> ErrorNote v loc -> TypeError v loc
[$sel:defns:Mismatch] :: TypeError v loc -> NonEmpty (v, [loc])
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UncoveredPatterns :: loc -> NonEmpty (Pattern ()) -> TypeError v loc
RedundantPattern :: loc -> TypeError v loc
KindInferenceFailure :: KindError v loc -> TypeError v loc
Other :: ErrorNote v loc -> TypeError v loc
type RedundantTypeAnnotation = Bool
data TypeInfo v loc
TopLevelComponent :: [(v, Type v loc, RedundantTypeAnnotation)] -> TypeInfo v loc
[$sel:definitions:TopLevelComponent] :: TypeInfo v loc -> [(v, Type v loc, RedundantTypeAnnotation)]
type TypeNote v loc = Either (TypeError v loc) (TypeInfo v loc)
typeErrorFromNote :: (Ord loc, Show loc, Var v) => ErrorNote v loc -> TypeError v loc
typeInfoFromNote :: (Ord loc, Show loc, Var v) => InfoNote v loc -> Maybe (TypeInfo v loc)
allErrors :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
topLevelComponent :: InfoExtractor v a (TypeInfo v a)
redundantPattern :: ErrorExtractor v a (TypeError v a)
kindInferenceFailure :: ErrorExtractor v a (TypeError v a)
uncoveredPatterns :: ErrorExtractor v a (TypeError v a)
abilityCheckFailure :: ErrorExtractor v a (TypeError v a)
abilityEqFailure :: ErrorExtractor v a (TypeError v a)
duplicateDefinitions :: ErrorExtractor v a (TypeError v a)
unknownType :: ErrorExtractor v loc (TypeError v loc)
unknownTerm :: Var v => ErrorExtractor v loc (TypeError v loc)
generalMismatch :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
and :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
or :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
cond :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
matchGuard :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
unguardedCycle :: ErrorExtractor v loc (TypeError v loc)

-- | helper function to support <a>and</a> <i> <a>or</a> </i> <a>cond</a>
booleanMismatch0 :: (Var v, Ord loc) => BooleanMismatch -> SubseqExtractor v loc () -> ErrorExtractor v loc (TypeError v loc)
existentialMismatch0 :: (Var v, Ord loc) => ExistentialMismatch -> SubseqExtractor v loc loc -> ErrorExtractor v loc (TypeError v loc)
ifBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
listBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
matchBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
applyingNonFunction :: Var v => ErrorExtractor v loc (TypeError v loc)

-- | Want to collect this info: The <tt>n</tt>th argument to
--   <a>$sel:f:Mismatch</a> is <a>$sel:foundType:Mismatch</a>, but I was
--   expecting <a>$sel:expectedType:Mismatch</a>.
--   
--   30 | asdf asdf asdf
--   
--   If you're curious <a>$sel:f:Mismatch</a> has type <tt>blah</tt>, where
--   <tt>a</tt> was chosen as <tt>A</tt> <tt>b</tt> was chosen as
--   <tt>B</tt> <tt>c</tt> was chosen as <tt>C</tt> (many colors / groups)
applyingFunction :: forall v loc. Var v => ErrorExtractor v loc (TypeError v loc)
inSubtypes :: SubseqExtractor v loc (Type v loc, Type v loc, Maybe (Type v loc, Type v loc))
instance GHC.Show.Show Unison.Typechecker.TypeError.BooleanMismatch
instance GHC.Show.Show Unison.Typechecker.TypeError.ExistentialMismatch
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.TypeError.TypeError v loc)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.TypeError.TypeInfo v loc)

module Unison.Result
type Result notes = ResultT notes Identity
type ResultT notes f = MaybeT (WriterT notes f)
data Note v loc
Parsing :: Err v -> Note v loc
NameResolutionFailures :: [ResolutionFailure v loc] -> Note v loc
UnknownSymbol :: v -> loc -> Note v loc
TypeError :: ErrorNote v loc -> Note v loc
TypeInfo :: InfoNote v loc -> Note v loc
CompilerBug :: CompilerBug v loc -> Note v loc
data CompilerBug v loc
TopLevelComponentNotFound :: v -> Term v loc -> CompilerBug v loc
ResolvedNameNotFound :: v -> loc -> Name -> CompilerBug v loc
TypecheckerBug :: CompilerBug v loc -> CompilerBug v loc
result :: Result notes a -> Maybe a
pattern Result :: w -> Maybe a -> MaybeT (WriterT w Identity) a
makeResult :: Applicative m => notes -> Maybe a -> ResultT notes m a
isSuccess :: Functor f => ResultT note f a -> f Bool
isFailure :: Functor f => ResultT note f a -> f Bool
toMaybe :: Functor f => ResultT note f a -> f (Maybe a)
runResultT :: ResultT notes f a -> f (Maybe a, notes)
getResult :: Functor f => ResultT notes f a -> f (Result notes a)
toEither :: Functor f => ResultT notes f a -> ExceptT notes f a
tell1 :: Monad f => note -> ResultT (Seq note) f ()
fromParsing :: Monad f => Either (Err v) a -> ResultT (Seq (Note v loc)) f a
tellAndFail :: Monad f => note -> ResultT (Seq note) f a
compilerBug :: Monad f => CompilerBug v loc -> ResultT (Seq (Note v loc)) f a
hoist :: (Monad f, Monoid notes) => (forall a. f a -> g a) -> ResultT notes f b -> ResultT notes g b
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Result.CompilerBug v loc)
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Result.Note v loc)


-- | This module is the primary interface to the Unison typechecker module
--   Unison.Typechecker (admissibleTypeAt, check, check', checkAdmissible',
--   equals, locals, subtype, isSubtype, synthesize, synthesize', typeAt,
--   wellTyped) where
module Unison.Typechecker

-- | Infer the type of a <a>Term</a>, using a function to resolve the type
--   of <tt>Ref</tt> constructors contained in that term.
synthesize :: (Monad f, Var v, BuiltinAnnotation loc, Ord loc, Show loc) => PrettyPrintEnv -> PatternMatchCoverageCheckAndKindInferenceSwitch -> Env v loc -> Term v loc -> ResultT (Notes v loc) f (Type v loc)

-- | Infer the type of a <a>Term</a>, using type-directed name resolution
--   to attempt to resolve unknown symbols.
synthesizeAndResolve :: (Monad f, Var v, Monoid loc, BuiltinAnnotation loc, Ord loc, Show loc) => PrettyPrintEnv -> Env v loc -> TDNR f v loc (Type v loc)

-- | Check whether a term matches a type, using a function to resolve the
--   type of <tt>Ref</tt> constructors contained in the term. Returns
--   <tt>typ</tt> if successful, and a note about typechecking failure
--   otherwise.
check :: (Monad f, Var v, BuiltinAnnotation loc, Ord loc, Show loc) => PrettyPrintEnv -> Env v loc -> Term v loc -> Type v loc -> ResultT (Notes v loc) f (Type v loc)

-- | <tt>checkAdmissible</tt> e t` tests that `(f : t -&gt; r) e` is
--   well-typed. If <tt>t</tt> has quantifiers, these are moved outside, so
--   if `t : forall a . a`, this will check that `(f : forall a . a -&gt;
--   a) e` is well typed. checkAdmissible' :: Var v =&gt; Term v -&gt; Type
--   v -&gt; Either Note (Type v) checkAdmissible' term typ = synthesize'
--   (Term.blank() <a>ann_</a> tweak typ <a>app_</a> term) where tweak
--   (Type.ForallNamed' v body) = Type.forall() v (tweak body) tweak t =
--   Type.arrow() t t | Returns <a>True</a> if the expression is
--   well-typed, <a>False</a> otherwise
wellTyped :: (Monad f, Var v, BuiltinAnnotation loc, Ord loc, Show loc) => PrettyPrintEnv -> Env v loc -> Term v loc -> f Bool
isEqual :: Var v => Type v loc -> Type v loc -> Bool
isSubtype :: Var v => Type v loc -> Type v loc -> Bool

-- | Similar to <a>isSubtype</a> but treats <tt>t2</tt> as a scheme where
--   the outermost variables are existential rather than universal.
--   
--   For example: <tt> let lhs = Unison.Type.ref ()
--   (Unison.Builtin.Decls.unitRef) rhs = Unison.Type.forall ()
--   (Unison.Var.named "x") (Unison.Type.var () (Unison.Var.named "x")) in
--   fitsScheme </tt>Symbol lhs rhs <tt> is </tt>True@ although the lhs is
--   not a subtype of the rhs.
--   
--   <a>fitsScheme</a> is used to check that runnable types are a subtype
--   of <tt> exists x. '{IO, Exception} x </tt>
fitsScheme :: Var v => Type v loc -> Type v loc -> Bool
data Env v loc
Env :: [Type v loc] -> TypeLookup v loc -> Map Name [NamedReference v loc] -> Env v loc
[$sel:ambientAbilities:Env] :: Env v loc -> [Type v loc]
[$sel:typeLookup:Env] :: Env v loc -> TypeLookup v loc
[$sel:termsByShortname:Env] :: Env v loc -> Map Name [NamedReference v loc]
data Notes v loc
Notes :: Seq (CompilerBug v loc) -> Seq (ErrorNote v loc) -> Seq (InfoNote v loc) -> Notes v loc
[$sel:bugs:Notes] :: Notes v loc -> Seq (CompilerBug v loc)
[$sel:errors:Notes] :: Notes v loc -> Seq (ErrorNote v loc)
[$sel:infos:Notes] :: Notes v loc -> Seq (InfoNote v loc)
data Resolution v loc
Resolution :: Text -> Type v loc -> loc -> v -> [Suggestion v loc] -> Resolution v loc
[$sel:resolvedName:Resolution] :: Resolution v loc -> Text
[$sel:inferredType:Resolution] :: Resolution v loc -> Type v loc
[$sel:resolvedLoc:Resolution] :: Resolution v loc -> loc
[$sel:v:Resolution] :: Resolution v loc -> v
[$sel:suggestions:Resolution] :: Resolution v loc -> [Suggestion v loc]
type Name = Text
data NamedReference v loc
NamedReference :: Name -> Type v loc -> Replacement v -> NamedReference v loc
[$sel:fqn:NamedReference] :: NamedReference v loc -> Name
[$sel:fqnType:NamedReference] :: NamedReference v loc -> Type v loc
[$sel:replacement:NamedReference] :: NamedReference v loc -> Replacement v
data PatternMatchCoverageCheckAndKindInferenceSwitch
PatternMatchCoverageCheckAndKindInferenceSwitch'Enabled :: PatternMatchCoverageCheckAndKindInferenceSwitch
PatternMatchCoverageCheckAndKindInferenceSwitch'Disabled :: PatternMatchCoverageCheckAndKindInferenceSwitch
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Notes v loc)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.NamedReference v loc)
instance GHC.Generics.Generic (Unison.Typechecker.Env v loc)
instance GHC.Base.Semigroup (Unison.Typechecker.Notes v loc)
instance GHC.Base.Monoid (Unison.Typechecker.Notes v loc)

module Unison.Codebase.TermEdit.Typing
typing :: Var v => Type v loc -> Type v loc -> Typing

module Unison.DataDeclaration.Dependencies
declTypeDependencies :: Ord v => Decl v a -> Set Reference

-- | All references to types mentioned in the given data declaration's
--   fields/constructors Note: Does not include references to the
--   constructors or the decl itself (unless the decl is self-referential)
--   Note: Does NOT include the referents for fields and field accessors.
--   Those must be computed separately because we need access to the
--   typechecker to do so.
typeDependencies :: Ord v => DataDeclaration v a -> Set Reference
labeledTypeDependencies :: Ord v => DataDeclaration v a -> Set LabeledDependency
labeledDeclTypeDependencies :: Ord v => Decl v a -> Set LabeledDependency

-- | Compute the dependencies of a data declaration, including the type
--   itself and references for each of its constructors.
--   
--   NOTE: You may prefer
--   labeledDeclDependenciesIncludingSelfAndFieldAccessors in
--   Unison.DataDeclaration.Dependencies, it also includes Referents for
--   accessors of record fields.
labeledDeclDependenciesIncludingSelf :: Ord v => TypeReference -> Decl v a -> Set LabeledDependency

-- | Generate the LabeledDependencies for everything in a Decl, including
--   the Decl itself, all its constructors, all referenced types, and all
--   possible record accessors.
--   
--   Note that we can't actually tell whether the Decl was originally a
--   record or not, so we include all possible accessors, but they may or
--   may not exist in the codebase.
labeledDeclDependenciesIncludingSelfAndFieldAccessors :: Var v => TypeReference -> Decl v a -> Set LabeledDependency

-- | Generate Referents for all possible field accessors of a Decl.
--   
--   Returns <tt>Nothing</tt> if inferring/typechecking of any accessor
--   fails, which shouldn't normally happen, but does when record fields
--   are higher rank, because the higher rank types can't be inferred.
--   
--   See <a>https://github.com/unisonweb/unison/issues/498</a>
hashFieldAccessors :: forall v a. Var v => PrettyPrintEnv -> v -> [v] -> TypeReference -> DataDeclaration v a -> Maybe (Map v (TermReferenceId, Term v (), Type v ()))

module Unison.Syntax.DeclPrinter
prettyDecl :: Var v => PrettyPrintEnvDecl -> TypeReference -> HashQualified Name -> Decl v a -> Pretty SyntaxText
prettyDeclW :: Var v => PrettyPrintEnvDecl -> TypeReference -> HashQualified Name -> Decl v a -> Writer (Set AccessorName) (Pretty SyntaxText)
prettyDeclHeader :: Var v => HashQualified Name -> Either (EffectDeclaration v a) (DataDeclaration v a) -> Pretty SyntaxText
prettyDeclOrBuiltinHeader :: Var v => HashQualified Name -> DeclOrBuiltin v a -> Pretty SyntaxText
getFieldAndAccessorNames :: forall v a. Var v => PrettyPrintEnv -> TypeReference -> HashQualified Name -> DataDeclaration v a -> Maybe ([Name], [Name])
type AccessorName = Name

module Unison.Codebase.Editor.DisplayObject
data DisplayObject b a
BuiltinObject :: b -> DisplayObject b a
MissingObject :: ShortHash -> DisplayObject b a
UserObject :: a -> DisplayObject b a
toMaybe :: DisplayObject b a -> Maybe a
termDisplayObjectLabeledDependencies :: TermReference -> DisplayObject (Type Symbol Ann) (Term Symbol Ann) -> Set LabeledDependency
typeDisplayObjectLabeledDependencies :: TypeReference -> DisplayObject () (Decl Symbol Ann) -> Set LabeledDependency
instance Data.Traversable.Traversable (Unison.Codebase.Editor.DisplayObject.DisplayObject b)
instance Data.Foldable.Foldable (Unison.Codebase.Editor.DisplayObject.DisplayObject b)
instance GHC.Generics.Generic (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance GHC.Base.Functor (Unison.Codebase.Editor.DisplayObject.DisplayObject b)
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance (GHC.Classes.Ord b, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance (GHC.Classes.Eq b, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance Data.Bifunctor.Bifunctor Unison.Codebase.Editor.DisplayObject.DisplayObject
instance Data.Bitraversable.Bitraversable Unison.Codebase.Editor.DisplayObject.DisplayObject
instance Data.Bifoldable.Bifoldable Unison.Codebase.Editor.DisplayObject.DisplayObject

module Unison.PrintError
type Env = PrettyPrintEnv
defaultWidth :: Width
prettyParseError :: forall v. Var v => String -> Err v -> Pretty ColorText

-- | Pretty prints resolution failure annotations, including a table of
--   disambiguation suggestions.
prettyResolutionFailures :: forall v a. (Annotated a, Var v, Ord a) => String -> [ResolutionFailure v a] -> Pretty ColorText
prettyVar :: Var v => v -> Pretty ColorText
printNoteWithSource :: (Var v, Annotated a, Show a, Ord a) => Env -> String -> Note v a -> Pretty ColorText
renderCompilerBug :: (Var v, Annotated loc, Ord loc, Show loc) => Env -> String -> CompilerBug v loc -> Pretty ColorText
renderNoteAsANSI :: (Var v, Annotated a, Show a, Ord a) => Width -> Env -> String -> Note v a -> String
renderParseErrorAsANSI :: Var v => Width -> String -> Err v -> String
renderParseErrors :: forall v. Var v => String -> Err v -> [(Pretty ColorText, [Range])]

module Unison.Codebase.Runtime
type Error = Pretty ColorText
type Term v = Term v ()
data Runtime v
Runtime :: IO () -> (CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error ([Error], Term v))) -> (CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)) -> Type v Ann -> NESet (Type v Ann) -> Runtime v
[$sel:terminate:Runtime] :: Runtime v -> IO ()
[$sel:evaluate:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error ([Error], Term v))
[$sel:compileTo:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)
[$sel:mainType:Runtime] :: Runtime v -> Type v Ann
[$sel:ioTestTypes:Runtime] :: Runtime v -> NESet (Type v Ann)
type IsCacheHit = Bool
noCache :: Id -> IO (Maybe (Term v))
type WatchResults v a = (Either Error ([(v, Term v)], [Error], Map v (a, WatchKind, Id, Term v, Term v, IsCacheHit)))
evaluateWatches :: forall v a. Var v => CodeLookup v IO a -> PrettyPrintEnv -> (Id -> IO (Maybe (Term v))) -> Runtime v -> TypecheckedUnisonFile v a -> IO (WatchResults v a)
evaluateTerm' :: (Var v, Monoid a) => CodeLookup v IO a -> (Id -> IO (Maybe (Term v))) -> PrettyPrintEnv -> Runtime v -> Term v a -> IO (Either Error ([Error], Term v))
evaluateTerm :: (Var v, Monoid a) => CodeLookup v IO a -> PrettyPrintEnv -> Runtime v -> Term v a -> IO (Either Error ([Error], Term v))


-- | Find a computation of type '{IO} () in the codebase.
module Unison.Codebase.MainTerm
data MainTerm v
NotFound :: HashQualified Name -> MainTerm v
BadType :: HashQualified Name -> Maybe (Type v Ann) -> MainTerm v
Success :: HashQualified Name -> Term v Ann -> Type v Ann -> MainTerm v
getMainTerm :: (Monad m, Var v) => (Reference -> m (Maybe (Type v Ann))) -> Names -> HashQualified Name -> Type v Ann -> m (MainTerm v)
builtinMain :: Var v => a -> Type v a
builtinMainWithResultType :: Var v => a -> Type v a -> Type v a

-- | All possible IO'ish test types, e.g. '{IO, Exception} [Result] '{IO}
--   [Result]
builtinIOTestTypes :: forall v a. (Ord v, Var v) => a -> NESet (Type v a)

module Unison.Builtin.Terms
builtinTermsRef :: Map Symbol Id
builtinTermsSrc :: a -> [(Symbol, a, Term Symbol a, Type Symbol a)]

module Unison.Builtin
codeLookup :: Applicative m => CodeLookup Symbol m Ann
constructorType :: Reference -> Maybe ConstructorType
names :: Names
builtinDataDecls :: [(Symbol, (Id, DataDeclaration))]
builtinEffectDecls :: [(Symbol, (Id, EffectDeclaration))]
builtinConstructorType :: Map Reference ConstructorType
builtinTypeDependents :: Reference -> Set Reference
builtinTypeDependentsOfComponent :: Hash -> Set Reference
builtinTypes :: [(Name, Reference)]
builtinTermsByType :: Relation Reference Referent
builtinTermsByTypeMention :: Relation Reference Referent
intrinsicTermReferences :: Set Reference
intrinsicTypeReferences :: Set Reference
isBuiltinType :: Reference -> Bool
typeOf :: a -> (Type -> a) -> Reference -> a
typeLookup :: TypeLookup Symbol Ann
termRefTypes :: Map TermReference Type
termRefTypeReferences :: Map TermReference TypeReference
instance GHC.Show.Show Unison.Builtin.BuiltinDSL

module Unison.Parsers
unsafeGetRightFrom :: (Var v, Show v) => String -> Either (Err v) a -> a
parse :: (Monad m, Var v) => P v m a -> String -> ParsingEnv m -> m (Either (Err v) a)
parseTerm :: (Monad m, Var v) => String -> ParsingEnv m -> m (Either (Err v) (Term v Ann))
parseType :: (Monad m, Var v) => String -> ParsingEnv m -> m (Either (Err v) (Type v Ann))
parseFile :: (Monad m, Var v) => FilePath -> String -> ParsingEnv m -> m (Either (Err v) (UnisonFile v Ann))
readAndParseFile :: (MonadIO m, Var v) => ParsingEnv m -> FilePath -> m (Either (Err v) (UnisonFile v Ann))
unsafeParseTerm :: (Monad m, Var v) => String -> ParsingEnv m -> m (Term v Ann)
unsafeReadAndParseFile :: ParsingEnv IO -> FilePath -> IO (UnisonFile Symbol Ann)
unsafeParseFileBuiltinsOnly :: FilePath -> IO (UnisonFile Symbol Ann)
unsafeParseFile :: Monad m => String -> ParsingEnv m -> m (UnisonFile Symbol Ann)

module Unison.FileParsers

-- | Should we use type-directed name resolution?
data ShouldUseTndr m
ShouldUseTndr'No :: ShouldUseTndr m
ShouldUseTndr'Yes :: ParsingEnv m -> ShouldUseTndr m

-- | Compute a typechecking environment, given:
--   
--   <ul>
--   <li>Whether or not to use type-directed name resolution during type
--   checking.</li>
--   <li>The abilities that are considered to already have ambient
--   handlers.</li>
--   <li>A function to compute a <tt>TypeLookup</tt> for the given set of
--   type- or term-references.</li>
--   <li>The parsing environment that was used to parse the parsed Unison
--   file.</li>
--   <li>The parsed Unison file for which the typechecking environment is
--   applicable.</li>
--   </ul>
computeTypecheckingEnvironment :: (Var v, Monad m) => ShouldUseTndr m -> [Type v] -> (Set Reference -> m (TypeLookup v Ann)) -> UnisonFile v -> m (Env v Ann)
synthesizeFile :: forall m v. (Monad m, Var v) => Env v Ann -> UnisonFile v -> ResultT (Seq (Note v Ann)) m (TypecheckedUnisonFile v Ann)

module Unison.Runtime.IOSource
debug :: Bool
parsingEnv :: ParsingEnv Identity
typecheckingEnv :: Env Symbol Ann
parsedFile :: UnisonFile Symbol Ann
typecheckedFile :: TypecheckedUnisonFile Symbol Ann
typecheckedFile' :: TypecheckedUnisonFile Symbol Ann
typecheckedFileTerms :: Map Symbol Reference
termNamed :: String -> Reference
codeLookup :: CodeLookup Symbol Identity Ann
codeLookupM :: Applicative m => CodeLookup Symbol m Ann
typeNamedId :: String -> Id
typeNamed :: String -> Reference
abilityNamedId :: String -> Id
eitherReference :: Reference
optionReference :: Reference
isTestReference :: Reference
isPropagatedReference :: Reference
isTest :: (Reference, Reference)
isIOTest :: (Reference, Reference)
isPropagatedValue :: Reference
eitherLeftId :: ConstructorId
eitherRightId :: ConstructorId
someId :: ConstructorId
noneId :: ConstructorId
authorRef :: Reference
guidRef :: Reference
copyrightHolderRef :: Reference
doc2Ref :: Reference
doc2SpecialFormRef :: Reference
doc2TermRef :: Reference
prettyRef :: Reference
prettyAnnotatedRef :: Reference
ansiColorRef :: Reference
consoleTextRef :: Reference
pattern Doc2Ref :: Reference
doc2WordId :: ConstructorId
doc2CodeId :: ConstructorId
doc2CodeBlockId :: ConstructorId
doc2BoldId :: ConstructorId
doc2ItalicId :: ConstructorId
doc2StrikethroughId :: ConstructorId
doc2StyleId :: ConstructorId
doc2AnchorId :: ConstructorId
doc2BlockquoteId :: ConstructorId
doc2BlanklineId :: ConstructorId
doc2LinebreakId :: ConstructorId
doc2SectionBreakId :: ConstructorId
doc2TooltipId :: ConstructorId
doc2AsideId :: ConstructorId
doc2CalloutId :: ConstructorId
doc2TableId :: ConstructorId
doc2FoldedId :: ConstructorId
doc2ParagraphId :: ConstructorId
doc2BulletedListId :: ConstructorId
doc2NumberedListId :: ConstructorId
doc2SectionId :: ConstructorId
doc2NamedLinkId :: ConstructorId
doc2ImageId :: ConstructorId
doc2SpecialId :: ConstructorId
doc2JoinId :: ConstructorId
doc2UntitledSectionId :: ConstructorId
doc2ColumnId :: ConstructorId
doc2GroupId :: ConstructorId
doc2MediaSourceRef :: Reference
pattern Doc2MediaSourceRef :: Reference
doc2VideoRef :: Reference
pattern Doc2VideoRef :: Reference
doc2FrontMatterRef :: Reference
pattern Doc2FrontMatterRef :: Reference
doc2LaTeXInlineRef :: Reference
pattern Doc2LaTeXInlineRef :: Reference
doc2SvgRef :: Reference
pattern Doc2SvgRef :: Reference
pattern Doc2Word :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Code :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2CodeBlock :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Bold :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Italic :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Strikethrough :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Style :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Anchor :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Blockquote :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Blankline :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Linebreak :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SectionBreak :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Tooltip :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Aside :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Callout :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Table :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Folded :: Bool -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Paragraph :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2BulletedList :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2NumberedList :: Word64 -> [Term (F typeVar typeAnn patternAnn) v a] -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Section :: Term2 typeVar typeAnn patternAnn v a -> [Term (F typeVar typeAnn patternAnn) v a] -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2NamedLink :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Image :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Special :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Join :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2UntitledSection :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Column :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Group :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormRef :: Reference
doc2SpecialFormSourceId :: ConstructorId
doc2SpecialFormFoldedSourceId :: ConstructorId
doc2SpecialFormExampleId :: ConstructorId
doc2SpecialFormExampleBlockId :: ConstructorId
doc2SpecialFormLinkId :: ConstructorId
doc2SpecialFormSignatureId :: ConstructorId
doc2SpecialFormSignatureInlineId :: ConstructorId
doc2SpecialFormEvalId :: ConstructorId
doc2SpecialFormEvalInlineId :: ConstructorId
doc2SpecialFormEmbedId :: ConstructorId
doc2SpecialFormEmbedInlineId :: ConstructorId
pattern Doc2SpecialFormSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormFoldedSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormExample :: Word64 -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormExampleBlock :: Word64 -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormLink :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormSignature :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormSignatureInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEval :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEvalInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbed :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2MediaSource :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormEmbedVideo :: [Term (F typeVar typeAnn patternAnn) v a] -> [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedFrontMatter :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedLaTeXInline :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedSvg :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Example :: forall {vt} {at} {ap} {v} {a}. [v] -> Term2 vt at ap v a -> Term (F vt at ap) v a
pattern Doc2Term :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2TermRef :: Reference
pattern PrettyAnnotatedRef :: Reference
prettyEmptyId :: ConstructorId
prettyGroupId :: ConstructorId
prettyLitId :: ConstructorId
prettyWrapId :: ConstructorId
prettyOrElseId :: ConstructorId
prettyIndentId :: ConstructorId
prettyAppendId :: ConstructorId
prettyTableId :: ConstructorId
pattern PrettyEmpty :: Term (F typeVar typeAnn patternAnn) v a
pattern PrettyGroup :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyLit :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyWrap :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyIndent :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyOrElse :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyTable :: Term2 typeVar typeAnn patternAnn v a -> Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyAppend :: Term2 typeVar typeAnn patternAnn v a -> Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyRef :: Reference
prettyGetRef :: Reference
doc2FormatConsoleRef :: Reference
pattern AnsiColorRef :: Reference
ansiColorBlackId :: ConstructorId
pattern AnsiColorBlack :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorRed :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorGreen :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorYellow :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBlue :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorMagenta :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorCyan :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorWhite :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightBlack :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightRed :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightGreen :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightYellow :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightBlue :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightMagenta :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightCyan :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightWhite :: Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextRef :: Reference
consoleTextPlainId :: ConstructorId
consoleTextForegroundId :: ConstructorId
consoleTextBackgroundId :: ConstructorId
consoleTextBoldId :: ConstructorId
consoleTextUnderlineId :: ConstructorId
consoleTextInvertId :: ConstructorId
pattern ConsoleTextPlain :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextForeground :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern ConsoleTextBackground :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern ConsoleTextBold :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextUnderline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextInvert :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
iarrayFromListRef :: Reference
ibarrayFromBytesRef :: Reference
constructorNamed :: Reference -> Text -> ConstructorId
constructorName :: Reference -> ConstructorId -> Text
sourceString :: String
source :: Text
type Note = Note Symbol Ann
type TFile = TypecheckedUnisonFile Symbol Ann
type SynthResult = Result (Seq Note) (Either (UnisonFile Symbol Ann) TFile)
type EitherResult = Either String TFile
showNotes :: Foldable f => String -> Env -> f Note -> String
ppEnv :: PrettyPrintEnv

module Unison.Codebase.SqliteCodebase.Branch.Dependencies
type Branches m = [(CausalHash, m (Branch m))]
data Dependencies
Dependencies :: Set PatchHash -> Set Hash -> Set Hash -> Dependencies
[$sel:patches:Dependencies] :: Dependencies -> Set PatchHash
[$sel:terms:Dependencies] :: Dependencies -> Set Hash
[$sel:decls:Dependencies] :: Dependencies -> Set Hash
data Dependencies'
Dependencies' :: [PatchHash] -> [Hash] -> [Hash] -> Dependencies'
[$sel:patches':Dependencies'] :: Dependencies' -> [PatchHash]
[$sel:terms':Dependencies'] :: Dependencies' -> [Hash]
[$sel:decls':Dependencies'] :: Dependencies' -> [Hash]
to' :: Dependencies -> Dependencies'
fromBranch :: Applicative m => Branch m -> (Branches m, Dependencies)
fromBranch0 :: Applicative m => Branch0 m -> (Branches m, Dependencies)
instance GHC.Base.Monoid Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Base.Semigroup Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Base.Monoid Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Base.Semigroup Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'

module Unison.Codebase.RootBranchCache
data RootBranchCache
newEmptyRootBranchCache :: STM RootBranchCache
newEmptyRootBranchCacheIO :: MonadIO m => m RootBranchCache
fetchRootBranch :: forall m. MonadUnliftIO m => RootBranchCache -> m (Branch Transaction) -> m (Branch Transaction)

-- | Take a cache lock so that no other thread can read or write to the
--   cache, perform an action with the cached value, then restore the cache
--   to Empty or Full
withLock :: forall m r. MonadUnliftIO m => RootBranchCache -> ((forall x. m x -> m x) -> Maybe (Branch Transaction) -> m r) -> (r -> Maybe (Branch Transaction)) -> m r

module Unison.Codebase.Branch

-- | A node in the Unison namespace hierarchy along with its history.
newtype Branch m
Branch :: UnwrappedBranch m -> Branch m
[$sel:_history:Branch] :: Branch m -> UnwrappedBranch m
type UnwrappedBranch m = Causal m (Branch0 m)

-- | A node in the Unison namespace hierarchy.
--   
--   <a>$sel:_terms:Branch0</a> and <a>$sel:_types:Branch0</a> are the
--   declarations at this level. <a>$sel:_children:Branch0</a> are the
--   nodes one level below us. <a>$sel:_edits:Branch0</a> are the
--   <a>Patch</a>s stored at this node in the code.
--   
--   The remaining fields are derived from the four above. None of the
--   record fields are exported to avoid accidental tweaking without
--   updating the associated derived fields.
--   
--   Use either the lensy accessors or the field getters.
data Branch0 m
data Raw
type Star r n = Star r n

-- | A Hash for a namespace itself, it doesn't incorporate any history.
type NamespaceHash m = HashFor (Branch0 m)
branch0 :: forall m. Star Referent NameSegment -> Star TypeReference NameSegment -> Map NameSegment (Branch m) -> Map NameSegment (PatchHash, m Patch) -> Branch0 m
one :: Branch0 m -> Branch m
cons :: Applicative m => Branch0 m -> Branch m -> Branch m

-- | Construct a two-parent merge node.
mergeNode :: forall m. Applicative m => Branch0 m -> (CausalHash, m (Branch m)) -> (CausalHash, m (Branch m)) -> Branch m
uncons :: Applicative m => Branch m -> m (Maybe (Branch0 m, Branch m))
empty :: Branch m
empty0 :: Branch0 m

-- | Discards the history of a Branch and its children, recursively
discardHistory :: Applicative m => Branch m -> Branch m

-- | Discards the history of a Branch0's children, recursively
discardHistory0 :: Applicative m => Branch0 m -> Branch0 m
transform :: Functor m => (forall a. m a -> n a) -> Branch m -> Branch n
transform0 :: Functor m => (forall a. m a -> n a) -> Branch0 m -> Branch0 n

-- | Checks whether a branch is empty AND has no history.
isEmpty :: Branch m -> Bool
isEmpty0 :: Branch0 m -> Bool
isOne :: Branch m -> Bool
before :: Monad m => Branch m -> Branch m -> m Bool
lca :: Monad m => Branch m -> Branch m -> m (Maybe (Branch m))
history :: Iso' (Branch m) (UnwrappedBranch m)
head :: Branch m -> Branch0 m

-- | Update the head of the current causal. This re-hashes the current
--   causal head after modifications.
head_ :: Lens' (Branch m) (Branch0 m)
headHash :: Branch m -> CausalHash
children :: Lens' (Branch0 m) (Map NameSegment (Branch m))
nonEmptyChildren :: Branch0 m -> Map NameSegment (Branch m)

-- | a version of <a>deepEdits</a> that returns the `m Patch` as well.
deepEdits' :: Branch0 m -> Map Name (PatchHash, m Patch)

-- | what does this do? —AI
toList0 :: Branch0 m -> [(Path, Branch0 m)]
namespaceStats :: Branch0 m -> NamespaceStats

-- | Perform an update over the current branch and create a new causal
--   step.
step :: Applicative m => (Branch0 m -> Branch0 m) -> Branch m -> Branch m

-- | Run a series of updates at specific locations, aggregating all changes
--   into a single causal step. History is managed according to
--   <a>UpdateStrategy</a>.
stepManyAt :: forall m f. (Monad m, Foldable f) => f (Path, Branch0 m -> Branch0 m) -> Branch m -> Branch m

-- | Run a series of updates at specific locations. History is managed
--   according to the <a>UpdateStrategy</a>
stepManyAtM :: (Monad m, Monad n, Foldable f) => f (Path, Branch0 m -> n (Branch0 m)) -> Branch m -> n (Branch m)
stepEverywhere :: Applicative m => (Branch0 m -> Branch0 m) -> Branch0 m -> Branch0 m

-- | Perform updates over many locations within a branch by batching up
--   operations on sub-branches as much as possible without affecting
--   semantics. This operation does not create any causal conses, the
--   operations are performed directly on the current head of the provided
--   branch and child branches. It's the caller's responsibility to apply
--   updates in history however they choose.
batchUpdates :: forall f m. (Monad m, Foldable f) => f (Path, Branch0 m -> Branch0 m) -> Branch0 m -> Branch0 m

-- | Batch many updates. This allows us to apply the updates while
--   minimizing redundant traversals. Semantics of operations are preserved
--   by ensuring that all updates will always see changes by updates before
--   them in the list.
--   
--   This method does not <a>step</a> any branches on its own, all causal
--   changes must be performed in the updates themselves, or this batch
--   update must be provided to 'stepManyAt(M)'.
batchUpdatesM :: forall m n f. (Monad m, Monad n, Foldable f) => f (Path, Branch0 m -> n (Branch0 m)) -> Branch0 m -> n (Branch0 m)
data UpdateStrategy

-- | Compress all changes into a single causal cons. The resulting branch
--   will have at most one new causal cons at each branch.
--   
--   Note that this does NOT allow updates to add histories at children.
--   E.g. if the root.editme branch has history: A -&gt; B -&gt; C and you
--   use <tt>makeSetBranch</tt> to update it to a new branch with history X
--   -&gt; Y -&gt; Z, CompressHistory will result in a history for
--   root.editme of: A -&gt; B -&gt; C -&gt; Z. A <tt>snapshot</tt> of the
--   most recent state of the updated branch is appended to the existing
--   history, if the new state is equal to the existing state, no new
--   history nodes are appended.
CompressHistory :: UpdateStrategy

-- | Preserves any history changes made within the update.
--   
--   Note that this allows you to clobber the history child branches if you
--   want. E.g. if the root.editme branch has history: A -&gt; B -&gt; C
--   and you use <tt>makeSetBranch</tt> to update it to a new branch with
--   history X -&gt; Y -&gt; Z, AllowRewritingHistory will result in a
--   history for root.editme of: X -&gt; Y -&gt; Z. The history of the
--   updated branch is replaced entirely.
AllowRewritingHistory :: UpdateStrategy
addTermName :: Referent -> NameSegment -> Branch0 m -> Branch0 m
addTypeName :: TypeReference -> NameSegment -> Branch0 m -> Branch0 m
deleteTermName :: Referent -> NameSegment -> Branch0 m -> Branch0 m
annihilateTermName :: NameSegment -> Branch0 m -> Branch0 m
annihilateTypeName :: NameSegment -> Branch0 m -> Branch0 m
deleteTypeName :: TypeReference -> NameSegment -> Branch0 m -> Branch0 m
setChildBranch :: NameSegment -> Branch m -> Branch0 m -> Branch0 m
replacePatch :: Applicative m => NameSegment -> Patch -> Branch0 m -> Branch0 m
deletePatch :: NameSegment -> Branch0 m -> Branch0 m
getMaybePatch :: Applicative m => NameSegment -> Branch0 m -> m (Maybe Patch)
getPatch :: Applicative m => NameSegment -> Branch0 m -> m Patch
modifyPatches :: Monad m => NameSegment -> (Patch -> Patch) -> Branch0 m -> m (Branch0 m)
getAt :: Path -> Branch m -> Maybe (Branch m)
getAt' :: Path -> Branch m -> Branch m
getAt0 :: Path -> Branch0 m -> Branch0 m
modifyAt :: Applicative m => Path -> (Branch m -> Branch m) -> Branch m -> Branch m
modifyAtM :: forall n m. (Functor n, Applicative m) => Path -> (Branch m -> n (Branch m)) -> Branch m -> n (Branch m)

-- | Traverse the head branch of all direct children. The index of the
--   traversal is the name of that child branch according to the parent.
children0 :: IndexedTraversal' NameSegment (Branch0 m) (Branch0 m)

-- | Remove any lib subtrees reachable within the branch. Note: This DOES
--   affect the hash.
withoutLib :: Branch0 m -> Branch0 m

-- | Remove any transitive libs reachable within the branch. Note: This
--   DOES affect the hash.
withoutTransitiveLibs :: Branch0 m -> Branch0 m

-- | <tt>deleteLibdep name branch</tt> deletes the libdep named
--   <tt>name</tt> from <tt>branch</tt>, if it exists.
deleteLibdep :: NameSegment -> Branch0 m -> Branch0 m

-- | <tt>deleteLibdeps branch</tt> deletes all libdeps from
--   <tt>branch</tt>.
deleteLibdeps :: Branch0 m -> Branch0 m
terms :: Lens' (Branch0 m) (Star Referent NameSegment)
types :: Lens' (Branch0 m) (Star TypeReference NameSegment)
edits :: Lens' (Branch0 m) (Map NameSegment (PatchHash, m Patch))
deepTerms :: Branch0 m -> Relation Referent Name
deepTypes :: Branch0 m -> Relation TypeReference Name
deepEdits :: Branch0 m -> Map Name PatchHash
deepPaths :: Branch0 m -> Set Path
deepReferents :: Branch0 m -> Set Referent
deepTermReferences :: Branch0 m -> Set TermReference
deepTypeReferences :: Branch0 m -> Set TypeReference

-- | <tt>head <a>consBranchSnapshot</a> base</tt> Cons's the current state
--   of <tt>head</tt> onto <tt>base</tt> as-is. Consider whether you really
--   want this behaviour or the behaviour of <a>squashMerge</a> That is, it
--   does not perform any common ancestor detection, or change
--   reconciliation, it sets the current state of the base branch to the
--   new state as a new causal step (or returns the existing base if there
--   are no)
consBranchSnapshot :: forall m. Monad m => Branch m -> Branch m -> Branch m
instance GHC.Classes.Eq Unison.Codebase.Branch.ActionLocation
instance Control.Lens.Empty.AsEmpty (Unison.Codebase.Branch.Type.Branch m)
instance Unison.Hashing.ContentAddressable.ContentAddressable (Unison.Codebase.Branch.Type.Branch0 m)

module Unison.Codebase.Type

-- | Abstract interface to a user's codebase.
data Codebase m v a
Codebase :: (Id -> Transaction (Maybe (Term v a))) -> (Id -> Transaction (Maybe (Type v a))) -> (Id -> Transaction (Maybe (Decl v a))) -> (Reference -> Transaction ConstructorType) -> (Id -> Term v a -> Type v a -> Transaction ()) -> (Hash -> [(Term v a, Type v a)] -> Transaction ()) -> (Id -> Decl v a -> Transaction ()) -> (Hash -> [Decl v a] -> Transaction ()) -> (Hash -> Transaction (Maybe [(Term v a, Type v a)])) -> m (Branch m) -> (Text -> Branch m -> m ()) -> (CausalHash -> m (Maybe (Branch m))) -> (Branch m -> m ()) -> (CodebasePath -> Branch m -> m ()) -> (CodebasePath -> Branch m -> m ()) -> (WatchKind -> Id -> Transaction (Maybe (Term v a))) -> (Reference -> Transaction (Set Id)) -> (Reference -> Transaction (Set Id)) -> (TypeReference -> Set Id -> Transaction (Set Id)) -> (TypeReference -> Set Id -> Transaction (Set Id)) -> (ShortHash -> Transaction (Set Id)) -> (forall x. (Connection -> m x) -> m x) -> (forall x. (Connection -> IO x) -> IO x) -> Codebase m v a

-- | Get a user-defined term from the codebase.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>$sel:getTerm:Codebase</a>, and receive <tt>Nothing</tt>, per the
--   semantics of <a>$sel:putTerm:Codebase</a>.
[$sel:getTerm:Codebase] :: Codebase m v a -> Id -> Transaction (Maybe (Term v a))

-- | Get the type of a user-defined term.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>$sel:getTypeOfTermImpl:Codebase</a>, and receive <tt>Nothing</tt>,
--   per the semantics of <a>$sel:putTerm:Codebase</a>.
[$sel:getTypeOfTermImpl:Codebase] :: Codebase m v a -> Id -> Transaction (Maybe (Type v a))

-- | Get a type declaration.
--   
--   Note that it is possible to call
--   <a>$sel:putTypeDeclaration:Codebase</a>, then
--   <a>$sel:getTypeDeclaration:Codebase</a>, and receive <tt>Nothing</tt>,
--   per the semantics of <a>$sel:putTypeDeclaration:Codebase</a>.
[$sel:getTypeDeclaration:Codebase] :: Codebase m v a -> Id -> Transaction (Maybe (Decl v a))

-- | Get the type of a given decl.
[$sel:getDeclType:Codebase] :: Codebase m v a -> Reference -> Transaction ConstructorType

-- | Enqueue the put of a user-defined term (with its type) into the
--   codebase, if it doesn't already exist. The implementation may choose
--   to delay the put until all of the term's (and its type's) references
--   are stored as well.
[$sel:putTerm:Codebase] :: Codebase m v a -> Id -> Term v a -> Type v a -> Transaction ()
[$sel:putTermComponent:Codebase] :: Codebase m v a -> Hash -> [(Term v a, Type v a)] -> Transaction ()

-- | Enqueue the put of a type declaration into the codebase, if it doesn't
--   already exist. The implementation may choose to delay the put until
--   all of the type declaration's references are stored as well.
[$sel:putTypeDeclaration:Codebase] :: Codebase m v a -> Id -> Decl v a -> Transaction ()
[$sel:putTypeDeclarationComponent:Codebase] :: Codebase m v a -> Hash -> [Decl v a] -> Transaction ()
[$sel:getTermComponentWithTypes:Codebase] :: Codebase m v a -> Hash -> Transaction (Maybe [(Term v a, Type v a)])

-- | Get the root branch.
[$sel:getRootBranch:Codebase] :: Codebase m v a -> m (Branch m)

-- | Like <a>$sel:putBranch:Codebase</a>, but also adjusts the root branch
--   pointer afterwards.
[$sel:putRootBranch:Codebase] :: Codebase m v a -> Text -> Branch m -> m ()
[$sel:getBranchForHash:Codebase] :: Codebase m v a -> CausalHash -> m (Maybe (Branch m))

-- | Put a branch into the codebase, which includes its children, its
--   patches, and the branch itself, if they don't already exist.
--   
--   The terms and type declarations that a branch references must already
--   exist in the codebase.
[$sel:putBranch:Codebase] :: Codebase m v a -> Branch m -> m ()

-- | Copy a branch and all of its dependencies from the given codebase into
--   this one.
[$sel:syncFromDirectory:Codebase] :: Codebase m v a -> CodebasePath -> Branch m -> m ()

-- | Copy a branch and all of its dependencies from this codebase into the
--   given codebase.
[$sel:syncToDirectory:Codebase] :: Codebase m v a -> CodebasePath -> Branch m -> m ()

-- | <tt>getWatch k r</tt> returns watch result <tt>t</tt> that was
--   previously put by <tt>putWatch k r t</tt>.
[$sel:getWatch:Codebase] :: Codebase m v a -> WatchKind -> Id -> Transaction (Maybe (Term v a))

-- | Get the set of user-defined terms-or-constructors that have the given
--   type.
[$sel:termsOfTypeImpl:Codebase] :: Codebase m v a -> Reference -> Transaction (Set Id)

-- | Get the set of user-defined terms-or-constructors mention the given
--   type anywhere in their signature.
[$sel:termsMentioningTypeImpl:Codebase] :: Codebase m v a -> Reference -> Transaction (Set Id)

-- | Return the subset of the given set that has the given type.
[$sel:filterTermsByReferenceIdHavingTypeImpl:Codebase] :: Codebase m v a -> TypeReference -> Set Id -> Transaction (Set Id)

-- | Return the subset of the given set that has the given type.
[$sel:filterTermsByReferentIdHavingTypeImpl:Codebase] :: Codebase m v a -> TypeReference -> Set Id -> Transaction (Set Id)

-- | Get the set of user-defined terms-or-constructors whose hash matches
--   the given prefix.
[$sel:termReferentsByPrefix:Codebase] :: Codebase m v a -> ShortHash -> Transaction (Set Id)

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
[$sel:withConnection:Codebase] :: Codebase m v a -> forall x. (Connection -> m x) -> m x

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
[$sel:withConnectionIO:Codebase] :: Codebase m v a -> forall x. (Connection -> IO x) -> IO x

-- | A directory that contains a codebase.
type CodebasePath = FilePath

-- | Whether a codebase is local or remote.
data LocalOrRemote
Local :: LocalOrRemote
Remote :: LocalOrRemote
instance GHC.Classes.Ord Unison.Codebase.Type.LocalOrRemote
instance GHC.Classes.Eq Unison.Codebase.Type.LocalOrRemote
instance GHC.Show.Show Unison.Codebase.Type.LocalOrRemote

module Unison.Codebase.SqliteCodebase.Branch.Cache

-- | A cache of <a>Branch</a> by <a>CausalHash</a>es.
data BranchCache m
BranchCache :: (CausalHash -> m (Maybe (Branch m))) -> (CausalHash -> Branch m -> m ()) -> BranchCache m
[$sel:lookupCachedBranch:BranchCache] :: BranchCache m -> CausalHash -> m (Maybe (Branch m))
[$sel:insertCachedBranch:BranchCache] :: BranchCache m -> CausalHash -> Branch m -> m ()

-- | Creates a <a>BranchCache</a> which uses weak references to only keep
--   branches in the cache for as long as they're reachable by something
--   else in the app.
--   
--   This means you don't need to worry about a Branch not being GC'd
--   because it's in the cache.
newBranchCache :: forall m. MonadIO m => m (BranchCache Transaction)

module Unison.Codebase.SqliteCodebase.Conversions
sch1to2 :: ShortCausalHash -> ShortCausalHash
decltype2to1 :: DeclType -> ConstructorType
decltype1to2 :: ConstructorType -> DeclType
watchKind1to2 :: WatchKind -> WatchKind
watchKind2to1 :: WatchKind -> WatchKind
term1to2 :: Hash -> Term Symbol Ann -> Term Symbol
term2to1 :: forall m. Monad m => Hash -> (Reference -> m ConstructorType) -> Term Symbol -> m (Term Symbol Ann)
termComponent1to2 :: Hash -> [(Term Symbol Ann, Type Symbol a)] -> [(Term Symbol, TypeT Symbol)]
decl2to1 :: Hash -> Decl Symbol -> Decl Symbol Ann
decl1to2 :: Hash -> Decl Symbol a -> Decl Symbol
symbol2to1 :: Symbol -> Symbol
symbol1to2 :: Symbol -> Symbol
rreference2to1 :: Hash -> Reference' Text (Maybe Hash) -> Reference
rreference1to2 :: Hash -> Reference -> Reference' Text (Maybe Hash)
rreferenceid2to1 :: Hash -> Id' (Maybe Hash) -> Id
rreferenceid1to2 :: Hash -> Id -> Id' (Maybe Hash)
branchHash1to2 :: NamespaceHash m -> BranchHash
branchHash2to1 :: forall m. BranchHash -> NamespaceHash m
reference2to1 :: Reference -> Reference
reference1to2 :: Reference -> Reference
referenceid1to2 :: Id -> Id
referenceid2to1 :: Id -> Id
rreferent2to1 :: Applicative m => Hash -> (Reference -> m ConstructorType) -> ReferentH -> m Referent
rreferent1to2 :: Hash -> Referent -> ReferentH
referent2to1 :: Applicative m => (Reference -> m ConstructorType) -> Referent -> m Referent

-- | Like referent2to1, but uses the provided constructor type directly
referent2to1UsingCT :: ConstructorType -> Referent -> Referent
referent1to2 :: Referent -> Referent
referentid1to2 :: Id -> Id
referentid2to1 :: Applicative m => (Reference -> m ConstructorType) -> Id -> m Id
constructorType1to2 :: ConstructorType -> ConstructorType
constructorType2to1 :: ConstructorType -> ConstructorType
ttype2to1 :: Type Symbol -> Type Symbol Ann
dtype2to1 :: Hash -> Type Symbol -> Type Symbol Ann
type2to1' :: (r -> Reference) -> TypeR r Symbol -> Type Symbol Ann
dtype1to2 :: Hash -> Type Symbol a -> TypeD Symbol
ttype1to2 :: Type Symbol a -> TypeT Symbol
type1to2' :: (Reference -> r) -> Type Symbol a -> TypeR r Symbol

-- | forces loading v1 branches even if they may not exist
causalbranch2to1 :: Monad m => BranchCache m -> (Reference -> m ConstructorType) -> CausalBranch m -> m (Branch m)
causalbranch2to1' :: Monad m => BranchCache m -> (Reference -> m ConstructorType) -> CausalBranch m -> m (UnwrappedBranch m)
causalbranch1to2 :: forall m. Monad m => Branch m -> CausalBranch m
patch2to1 :: Patch -> Patch
patch1to2 :: Patch -> Patch
branch2to1 :: Monad m => BranchCache m -> (Reference -> m ConstructorType) -> Branch m -> m (Branch0 m)

-- | Generates a v1 short hash from a v2 referent. Also shortens the hash
--   to the provided length. If <a>Nothing</a>, it will include the full
--   length hash.
referent2toshorthash1 :: Maybe Int -> Referent -> ShortHash

-- | Generates a v1 short hash from a v2 reference. Also shortens the hash
--   to the provided length. If <a>Nothing</a>, it will include the full
--   length hash.
reference2toshorthash1 :: Maybe Int -> Reference -> ShortHash


-- | This module contains sqlite-specific operations on high-level
--   "parser-typechecker" types all in the Transaction monad.
--   
--   The Codebase record-of-functions wraps this functionality, and runs
--   each transaction to IO, so that the operations' are unified with
--   non-sqlite operations in the Codebase interface, like
--   <tt>appendReflog</tt>.
module Unison.Codebase.SqliteCodebase.Operations
data BufferEntry a
BufferEntry :: Maybe Word64 -> Map Pos a -> Set Hash -> Set Hash -> BufferEntry a
[$sel:beComponentTargetSize:BufferEntry] :: BufferEntry a -> Maybe Word64
[$sel:beComponent:BufferEntry] :: BufferEntry a -> Map Pos a
[$sel:beMissingDependencies:BufferEntry] :: BufferEntry a -> Set Hash
[$sel:beWaitingDependents:BufferEntry] :: BufferEntry a -> Set Hash
prettyBufferEntry :: Show a => Hash -> BufferEntry a -> String
type TermBufferEntry = BufferEntry (Term Symbol Ann, Type Symbol Ann)
type DeclBufferEntry = BufferEntry (Decl Symbol Ann)
getBuffer :: TVar (Map Hash (BufferEntry a)) -> Hash -> IO (BufferEntry a)
putBuffer :: TVar (Map Hash (BufferEntry a)) -> Hash -> BufferEntry a -> IO ()
removeBuffer :: TVar (Map Hash (BufferEntry a)) -> Hash -> IO ()
addBufferDependent :: Hash -> TVar (Map Hash (BufferEntry a)) -> Hash -> IO ()
tryFlushBuffer :: forall a. Show a => TVar (Map Hash (BufferEntry a)) -> (Hash -> [a] -> Transaction ()) -> (Hash -> Transaction ()) -> Hash -> Transaction ()
getTerm :: (Reference -> Transaction ConstructorType) -> Id -> Transaction (Maybe (Term Symbol Ann))
getDeclType :: Reference -> Transaction ConstructorType
expectDeclTypeById :: Id -> Transaction ConstructorType
getTypeOfTermImpl :: Id -> Transaction (Maybe (Type Symbol Ann))
getTermComponentWithTypes :: (Reference -> Transaction ConstructorType) -> Hash -> Transaction (Maybe [(Term Symbol Ann, Type Symbol Ann)])
getTypeDeclaration :: Id -> Transaction (Maybe (Decl Symbol Ann))
getDeclComponent :: Hash -> Transaction (Maybe [Decl Symbol Ann])

-- | Like <a>getDeclComponent</a>, for when the decl component is known to
--   exist in the codebase.
expectDeclComponent :: HasCallStack => Hash -> Transaction [Decl Symbol Ann]
putTermComponent :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Hash -> [(Term Symbol Ann, Type Symbol Ann)] -> Transaction ()
putTerm :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Id -> Term Symbol Ann -> Type Symbol Ann -> Transaction ()
putTerm_ :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Id -> Term Symbol Ann -> Type Symbol Ann -> Transaction ()
tryFlushTermBuffer :: TVar (Map Hash TermBufferEntry) -> Hash -> Transaction ()
addDeclComponentTypeIndex :: ObjectId -> [[Type Symbol Ann]] -> Transaction ()
putTypeDeclarationComponent :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Hash -> [Decl Symbol Ann] -> Transaction ()
putTypeDeclaration :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Id -> Decl Symbol Ann -> Transaction ()
putTypeDeclaration_ :: TVar (Map Hash DeclBufferEntry) -> Id -> Decl Symbol Ann -> Transaction ()
tryFlushDeclBuffer :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Hash -> Transaction ()
uncachedLoadRootBranch :: BranchCache Transaction -> (Reference -> Transaction ConstructorType) -> Transaction (Branch Transaction)

-- | Get whether the root branch exists.
getRootBranchExists :: Transaction Bool
putRootBranch :: Branch Transaction -> Transaction ()
getBranchForHash :: BranchCache Transaction -> (Reference -> Transaction ConstructorType) -> CausalHash -> Transaction (Maybe (Branch Transaction))
putBranch :: Branch Transaction -> Transaction ()

-- | Check whether the given branch exists in the codebase.
branchExists :: CausalHash -> Transaction Bool
getPatch :: PatchHash -> Transaction (Maybe Patch)

-- | Put a patch into the codebase.
--   
--   Note that <a>putBranch</a> may also put patches.
putPatch :: PatchHash -> Patch -> Transaction ()

-- | Check whether the given patch exists in the codebase.
patchExists :: PatchHash -> Transaction Bool
dependentsImpl :: DependentsSelector -> Reference -> Transaction (Set Id)
dependentsOfComponentImpl :: Hash -> Transaction (Set Id)

-- | <tt>watches k</tt> returns all of the references <tt>r</tt> that were
--   previously put by a <tt>putWatch k r t</tt>. <tt>t</tt> can be
--   retrieved by <tt>getWatch k r</tt>.
watches :: WatchKind -> Transaction [Id]
getWatch :: (Reference -> Transaction ConstructorType) -> WatchKind -> Id -> Transaction (Maybe (Term Symbol Ann))

-- | <tt>putWatch k r t</tt> puts a watch of kind <tt>k</tt>, with
--   hash-of-expression <tt>r</tt> and decompiled result <tt>t</tt> into
--   the codebase.
--   
--   For example, in the watch expression below, <tt>k</tt> is
--   <a>Regular</a>, <tt>r</tt> is the hash of <tt>x</tt>, and <tt>t</tt>
--   is <tt>7</tt>.
--   
--   <pre>
--   &gt; x = 3 + 4
--     ⧩
--     7
--   </pre>
putWatch :: WatchKind -> Id -> Term Symbol Ann -> Transaction ()
standardWatchKinds :: [WatchKind]
termsOfTypeImpl :: (Reference -> Transaction ConstructorType) -> Reference -> Transaction (Set Id)
termsMentioningTypeImpl :: (Reference -> Transaction ConstructorType) -> Reference -> Transaction (Set Id)
filterReferencesHavingTypeImpl :: Reference -> Set Id -> Transaction (Set Id)
filterReferentsHavingTypeImpl :: (Reference -> Transaction ConstructorType) -> Reference -> Set Id -> Transaction (Set Id)

-- | The number of base32 characters needed to distinguish any two
--   references in the codebase.
hashLength :: Transaction Int

-- | The number of base32 characters needed to distinguish any two branch
--   in the codebase.
branchHashLength :: Transaction Int
defnReferencesByPrefix :: ObjectType -> ShortHash -> Transaction (Set Id)
termReferencesByPrefix :: ShortHash -> Transaction (Set Id)

-- | Get the set of type declarations whose hash matches the given prefix.
typeReferencesByPrefix :: ShortHash -> Transaction (Set Id)
referentsByPrefix :: (Reference -> Transaction ConstructorType) -> ShortHash -> Transaction (Set Id)

-- | Get the set of branches whose hash matches the given prefix.
causalHashesByPrefix :: ShortCausalHash -> Transaction (Set CausalHash)
termExists :: Hash -> Transaction Bool
declExists :: Hash -> Transaction Bool
before :: CausalHash -> CausalHash -> Transaction Bool

-- | Construct a <tt>ScopedNames</tt> which can produce names which are
--   relative to the provided Path.
--   
--   NOTE: this method requires an up-to-date name lookup index
namesAtPath :: BranchHash -> Path -> Transaction Names

-- | Add an index for the provided branch hash if one doesn't already
--   exist.
ensureNameLookupForBranchHash :: (Reference -> Transaction ConstructorType) -> Maybe BranchHash -> BranchHash -> Transaction ()

-- | Regenerate the name lookup index for the given branch hash from
--   scratch. This shouldn't be necessary in normal operation, but it's
--   useful to fix name lookups if they somehow get corrupt, or during
--   local testing and debugging.
regenerateNameLookup :: (Reference -> Transaction ConstructorType) -> BranchHash -> Transaction ()

-- | Given a transaction, return a transaction that first checks a
--   semispace cache of the given size.
--   
--   The transaction should probably be read-only, as we (of course) don't
--   hit SQLite on a cache hit.
makeCachedTransaction :: (Ord a, MonadIO m) => Word -> (a -> Transaction b) -> m (a -> Transaction b)

-- | Like <a>makeCachedTransaction</a>, but for when the transaction
--   returns a Maybe; only cache the Justs.
makeMaybeCachedTransaction :: (Ord a, MonadIO m) => Word -> (a -> Transaction (Maybe b)) -> m (a -> Transaction (Maybe b))
insertProjectAndBranch :: ProjectId -> ProjectName -> ProjectBranchId -> ProjectBranchName -> Transaction ()
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.SqliteCodebase.Operations.BufferEntry a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.SqliteCodebase.Operations.BufferEntry a)

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2
migrateSchema1To2 :: (Reference -> Transaction ConstructorType) -> TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Transaction ()
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.Entity
instance GHC.Classes.Ord Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.Entity
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.Entity
instance Data.Traversable.Traversable Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference
instance Data.Foldable.Foldable Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference
instance GHC.Show.Show ref => GHC.Show.Show (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Classes.Ord ref => GHC.Classes.Ord (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Generics.Generic (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Base.Functor Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference
instance GHC.Classes.Eq ref => GHC.Classes.Eq (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.MigrationState

module Unison.Codebase.BranchUtil

-- | Creates a branch containing all of the given names, with a single
--   history node.
fromNames :: Monad m => Names -> Branch m
getBranch :: Split -> Branch0 m -> Maybe (Branch m)
getTerm :: HQSplit -> Branch0 m -> Set Referent
getType :: HQSplit -> Branch0 m -> Set TypeReference
makeSetBranch :: Split -> Branch m -> (Path, Branch0 m -> Branch0 m)
makeAddTypeName :: Split -> Reference -> (Path, Branch0 m -> Branch0 m)
makeDeleteTypeName :: Split -> Reference -> (Path, Branch0 m -> Branch0 m)
makeAnnihilateTypeName :: Split -> (Path, Branch0 m -> Branch0 m)
makeAddTermName :: Split -> Referent -> (Path, Branch0 m -> Branch0 m)
makeDeleteTermName :: Split -> Referent -> (Path, Branch0 m -> Branch0 m)
makeAnnihilateTermName :: Split -> (Path, Branch0 m -> Branch0 m)

module Unison.Codebase.BranchDiff
data DiffType a
Create :: a -> DiffType a
Delete :: a -> DiffType a
Modify :: a -> DiffType a
data DiffSlice r
DiffSlice :: Map Name (Set r, Set r) -> Relation r Name -> Relation r Name -> Map r (Set Name, Set Name) -> DiffSlice r
[$sel:tallnamespaceUpdates:DiffSlice] :: DiffSlice r -> Map Name (Set r, Set r)
[$sel:talladds:DiffSlice] :: DiffSlice r -> Relation r Name
[$sel:tallremoves:DiffSlice] :: DiffSlice r -> Relation r Name
[$sel:trenames:DiffSlice] :: DiffSlice r -> Map r (Set Name, Set Name)
data BranchDiff
BranchDiff :: DiffSlice Referent -> DiffSlice Reference -> Map Name (DiffType PatchDiff) -> BranchDiff
[$sel:termsDiff:BranchDiff] :: BranchDiff -> DiffSlice Referent
[$sel:typesDiff:BranchDiff] :: BranchDiff -> DiffSlice Reference
[$sel:patchesDiff:BranchDiff] :: BranchDiff -> Map Name (DiffType PatchDiff)
diff0 :: forall m. Monad m => Branch0 m -> Branch0 m -> m BranchDiff
patchDiff :: forall m. Monad m => Branch0 m -> Branch0 m -> m (Map Name (DiffType PatchDiff))
computeSlices :: Relation Referent Name -> Relation Referent Name -> Relation Reference Name -> Relation Reference Name -> (DiffSlice Referent, DiffSlice Reference)
namespaceUpdates :: Ord r => DiffSlice r -> Map Name (Set r, Set r)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.BranchDiff.DiffType a)
instance GHC.Show.Show r => GHC.Show.Show (Unison.Codebase.BranchDiff.DiffSlice r)
instance GHC.Generics.Generic (Unison.Codebase.BranchDiff.DiffSlice r)
instance GHC.Show.Show Unison.Codebase.BranchDiff.BranchDiff
instance GHC.Generics.Generic Unison.Codebase.BranchDiff.BranchDiff

module Unison.Codebase.Branch.Names
namesDiff :: Branch m -> Branch m -> Diff

-- | Get the names in the provided branch.
toNames :: Branch0 m -> Names

-- | Get the pretty-printing environment for names in the provided branch.
toPrettyPrintEnvDecl :: Int -> Branch0 m -> PrettyPrintEnvDecl

module Unison.Codebase.Branch.BranchDiff
type Star r n = Star r n
data BranchDiff
BranchDiff :: Star Referent NameSegment -> Star Referent NameSegment -> Star Reference NameSegment -> Star Reference NameSegment -> Map NameSegment PatchDiff -> BranchDiff
[$sel:addedTerms:BranchDiff] :: BranchDiff -> Star Referent NameSegment
[$sel:removedTerms:BranchDiff] :: BranchDiff -> Star Referent NameSegment
[$sel:addedTypes:BranchDiff] :: BranchDiff -> Star Reference NameSegment
[$sel:removedTypes:BranchDiff] :: BranchDiff -> Star Reference NameSegment
[$sel:changedPatches:BranchDiff] :: BranchDiff -> Map NameSegment PatchDiff
diff0 :: Monad m => Branch0 m -> Branch0 m -> m BranchDiff
instance GHC.Show.Show Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Classes.Ord Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Classes.Eq Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Base.Semigroup Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Base.Monoid Unison.Codebase.Branch.BranchDiff.BranchDiff

module Unison.Codebase.Branch.Merge
data MergeMode
RegularMerge :: MergeMode
SquashMerge :: MergeMode
merge'' :: forall m. Monad m => (Branch m -> Branch m -> m (Maybe (Branch m))) -> MergeMode -> Branch m -> Branch m -> m (Branch m)
instance GHC.Show.Show Unison.Codebase.Branch.Merge.MergeMode
instance GHC.Classes.Ord Unison.Codebase.Branch.Merge.MergeMode
instance GHC.Classes.Eq Unison.Codebase.Branch.Merge.MergeMode

module Unison.Codebase

-- | Abstract interface to a user's codebase.
data Codebase m v a

-- | Get a user-defined term from the codebase.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>$sel:getTerm:Codebase</a>, and receive <tt>Nothing</tt>, per the
--   semantics of <a>$sel:putTerm:Codebase</a>.
($sel:getTerm:Codebase) :: Codebase m v a -> Id -> Transaction (Maybe (Term v a))

-- | Like <a>$sel:getTerm:Codebase</a>, for when the term is known to exist
--   in the codebase.
unsafeGetTerm :: HasCallStack => Codebase m v a -> Id -> Transaction (Term v a)

-- | Like <a>unsafeGetTerm</a>, but returns the type of the term, too.
unsafeGetTermWithType :: HasCallStack => Codebase m v a -> Id -> Transaction (Term v a, Type v a)
($sel:getTermComponentWithTypes:Codebase) :: Codebase m v a -> Hash -> Transaction (Maybe [(Term v a, Type v a)])

-- | Like <a>$sel:getTermComponentWithTypes:Codebase</a>, for when the term
--   component is known to exist in the codebase.
unsafeGetTermComponent :: HasCallStack => Codebase m v a -> Hash -> Transaction [(Term v a, Type v a)]

-- | Get the type of a term.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>getTypeOfTerm</a>, and receive <tt>Nothing</tt>, per the semantics
--   of <a>$sel:putTerm:Codebase</a>.
getTypeOfTerm :: BuiltinAnnotation a => Codebase m Symbol a -> Reference -> Transaction (Maybe (Type Symbol a))

-- | Get the type of a given decl.
($sel:getDeclType:Codebase) :: Codebase m v a -> Reference -> Transaction ConstructorType

-- | Like <a>getTypeOfTerm</a>, but for when the term is known to exist in
--   the codebase.
unsafeGetTypeOfTermById :: HasCallStack => Codebase m v a -> Id -> Transaction (Type v a)

-- | Check whether a reference is a term.
isTerm :: BuiltinAnnotation a => Codebase m Symbol a -> Reference -> Transaction Bool

-- | Enqueue the put of a user-defined term (with its type) into the
--   codebase, if it doesn't already exist. The implementation may choose
--   to delay the put until all of the term's (and its type's) references
--   are stored as well.
($sel:putTerm:Codebase) :: Codebase m v a -> Id -> Term v a -> Type v a -> Transaction ()
($sel:putTermComponent:Codebase) :: Codebase m v a -> Hash -> [(Term v a, Type v a)] -> Transaction ()

-- | Get the type of a referent.
getTypeOfReferent :: BuiltinAnnotation a => Codebase m Symbol a -> Referent -> Transaction (Maybe (Type Symbol a))

-- | Get the set of terms-or-constructors that have the given type.
termsOfType :: Var v => Codebase m v a -> Type v a -> Transaction (Set Referent)
filterTermsByReferenceIdHavingType :: Var v => Codebase m v a -> Type v a -> Set TermReferenceId -> Transaction (Set TermReferenceId)
filterTermsByReferentHavingType :: Var v => Codebase m v a -> Type v a -> Set Referent -> Transaction (Set Referent)

-- | Get the set of terms-or-constructors mention the given type anywhere
--   in their signature.
termsMentioningType :: Var v => Codebase m v a -> Type v a -> Transaction (Set Referent)
termReferencesByPrefix :: ShortHash -> Transaction (Set Id)

-- | Get the set of user-defined terms-or-constructors whose hash matches
--   the given prefix.
($sel:termReferentsByPrefix:Codebase) :: Codebase m v a -> ShortHash -> Transaction (Set Id)

-- | Get a type declaration.
--   
--   Note that it is possible to call
--   <a>$sel:putTypeDeclaration:Codebase</a>, then
--   <a>$sel:getTypeDeclaration:Codebase</a>, and receive <tt>Nothing</tt>,
--   per the semantics of <a>$sel:putTypeDeclaration:Codebase</a>.
($sel:getTypeDeclaration:Codebase) :: Codebase m v a -> Id -> Transaction (Maybe (Decl v a))

-- | Like <a>$sel:getTypeDeclaration:Codebase</a>, for when the type
--   declaration is known to exist in the codebase.
unsafeGetTypeDeclaration :: HasCallStack => Codebase m v a -> Id -> Transaction (Decl v a)
getDeclComponent :: Hash -> Transaction (Maybe [Decl Symbol Ann])

-- | Enqueue the put of a type declaration into the codebase, if it doesn't
--   already exist. The implementation may choose to delay the put until
--   all of the type declaration's references are stored as well.
($sel:putTypeDeclaration:Codebase) :: Codebase m v a -> Id -> Decl v a -> Transaction ()
($sel:putTypeDeclarationComponent:Codebase) :: Codebase m v a -> Hash -> [Decl v a] -> Transaction ()

-- | Get the set of type declarations whose hash matches the given prefix.
typeReferencesByPrefix :: ShortHash -> Transaction (Set Id)
isType :: Codebase m v a -> Reference -> Transaction Bool

-- | Check whether the given branch exists in the codebase.
branchExists :: CausalHash -> Transaction Bool
($sel:getBranchForHash:Codebase) :: Codebase m v a -> CausalHash -> m (Maybe (Branch m))

-- | Like <a>$sel:getBranchForHash:Codebase</a>, but for when the hash is
--   known to be in the codebase.
expectBranchForHash :: Monad m => Codebase m v a -> CausalHash -> m (Branch m)

-- | Put a branch into the codebase, which includes its children, its
--   patches, and the branch itself, if they don't already exist.
--   
--   The terms and type declarations that a branch references must already
--   exist in the codebase.
($sel:putBranch:Codebase) :: Codebase m v a -> Branch m -> m ()

-- | Get the set of branches whose hash matches the given prefix.
causalHashesByPrefix :: ShortCausalHash -> Transaction (Set CausalHash)

-- | Get the lowest common ancestor of two branches, i.e. the most recent
--   branch that is an ancestor of both branches.
lca :: MonadIO m => Codebase m v a -> Branch m -> Branch m -> m (Maybe (Branch m))
before :: CausalHash -> CausalHash -> Transaction Bool

-- | Recursively descend into causals following the given path, Use the
--   root causal if none is provided.
getShallowBranchAtPath :: Path -> Maybe (Branch Transaction) -> Transaction (Branch Transaction)

-- | Recursively descend into causals following the given path, Use the
--   root causal if none is provided.
getShallowCausalAtPath :: Path -> Maybe (CausalBranch Transaction) -> Transaction (CausalBranch Transaction)

-- | Get a v1 branch from the root following the given path.
getBranchAtPath :: MonadIO m => Codebase m v a -> Absolute -> m (Branch m)
expectCausalBranchByCausalHash :: CausalHash -> Transaction (CausalBranch Transaction)
getShallowCausalFromRoot :: Maybe CausalHash -> Path -> Transaction (CausalBranch Transaction)

-- | Get the shallow representation of the root branches without loading
--   the children or history.
getShallowRootBranch :: Transaction (Branch Transaction)

-- | Get the shallow representation of the root branches without loading
--   the children or history.
getShallowRootCausal :: Transaction (CausalBranch Transaction)

-- | Get the root branch.
($sel:getRootBranch:Codebase) :: Codebase m v a -> m (Branch m)

-- | Get whether the root branch exists.
getRootBranchExists :: Transaction Bool
expectRootCausalHash :: Transaction CausalHash

-- | Like <a>$sel:putBranch:Codebase</a>, but also adjusts the root branch
--   pointer afterwards.
($sel:putRootBranch:Codebase) :: Codebase m v a -> Text -> Branch m -> m ()

-- | Construct a <tt>ScopedNames</tt> which can produce names which are
--   relative to the provided Path.
--   
--   NOTE: this method requires an up-to-date name lookup index
namesAtPath :: BranchHash -> Path -> Transaction Names

-- | Check whether the given patch exists in the codebase.
patchExists :: PatchHash -> Transaction Bool
getPatch :: PatchHash -> Transaction (Maybe Patch)

-- | Put a patch into the codebase.
--   
--   Note that <a>putBranch</a> may also put patches.
putPatch :: PatchHash -> Patch -> Transaction ()

-- | <tt>getWatch k r</tt> returns watch result <tt>t</tt> that was
--   previously put by <tt>putWatch k r t</tt>.
($sel:getWatch:Codebase) :: Codebase m v a -> WatchKind -> Id -> Transaction (Maybe (Term v a))

-- | Like <a>$sel:getWatch:Codebase</a>, but first looks up the given
--   reference as a regular watch, then as a test watch.
--   
--   <pre>
--   lookupWatchCache codebase ref =
--     runMaybeT do
--       MaybeT (getWatch codebase RegularWatch ref)
--         <a>|</a> MaybeT (getWatch codebase TestWatch ref))
--   </pre>
lookupWatchCache :: Codebase m v a -> Id -> Transaction (Maybe (Term v a))

-- | <tt>watches k</tt> returns all of the references <tt>r</tt> that were
--   previously put by a <tt>putWatch k r t</tt>. <tt>t</tt> can be
--   retrieved by <tt>getWatch k r</tt>.
watches :: WatchKind -> Transaction [Id]

-- | <tt>putWatch k r t</tt> puts a watch of kind <tt>k</tt>, with
--   hash-of-expression <tt>r</tt> and decompiled result <tt>t</tt> into
--   the codebase.
--   
--   For example, in the watch expression below, <tt>k</tt> is
--   <a>Regular</a>, <tt>r</tt> is the hash of <tt>x</tt>, and <tt>t</tt>
--   is <tt>7</tt>.
--   
--   <pre>
--   &gt; x = 3 + 4
--     ⧩
--     7
--   </pre>
putWatch :: WatchKind -> Id -> Term Symbol Ann -> Transaction ()

-- | Delete all watches that were put by <tt>putWatch</tt>.
clearWatches :: Transaction ()

-- | Gets the specified number of reflog entries in chronological order,
--   most recent first.
getReflog :: Int -> Transaction [Entry CausalHash Text]

-- | The number of base32 characters needed to distinguish any two
--   references in the codebase.
hashLength :: Transaction Int

-- | The number of base32 characters needed to distinguish any two branch
--   in the codebase.
branchHashLength :: Transaction Int

-- | Get the set of terms, type declarations, and builtin types that depend
--   on the given term, type declaration, or builtin type.
dependents :: DependentsSelector -> Reference -> Transaction (Set Reference)
dependentsOfComponent :: Hash -> Transaction (Set Reference)

-- | Copy a branch and all of its dependencies from the given codebase into
--   this one.
($sel:syncFromDirectory:Codebase) :: Codebase m v a -> CodebasePath -> Branch m -> m ()

-- | Copy a branch and all of its dependencies from this codebase into the
--   given codebase.
($sel:syncToDirectory:Codebase) :: Codebase m v a -> CodebasePath -> Branch m -> m ()
getCodebaseDir :: MonadIO m => Maybe CodebasePath -> m CodebasePath

-- | A directory that contains a codebase.
type CodebasePath = FilePath

-- | Run a transaction on a codebase.
runTransaction :: MonadIO m => Codebase m v a -> Transaction b -> m b
runTransactionWithRollback :: MonadIO m => Codebase m v a -> ((forall void. b -> Transaction void) -> Transaction b) -> m b

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
($sel:withConnection:Codebase) :: Codebase m v a -> forall x. (Connection -> m x) -> m x

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
($sel:withConnectionIO:Codebase) :: Codebase m v a -> forall x. (Connection -> IO x) -> IO x
addDefsToCodebase :: forall m v a. (Var v, Show a) => Codebase m v a -> TypecheckedUnisonFile v a -> Transaction ()
componentReferencesForReference :: Reference -> Transaction (Set Reference)

-- | Write all of UCM's dependencies (builtins types and an empty
--   namespace) into the codebase
installUcmDependencies :: Codebase m Symbol Ann -> Transaction ()
toCodeLookup :: MonadIO m => Codebase m Symbol Ann -> CodeLookup Symbol m Ann

-- | Make a <tt>TypeLookup</tt> that is suitable for looking up information
--   about all of the given type-or-term references, and all of their type
--   dependencies, including builtins.
typeLookupForDependencies :: Codebase IO Symbol Ann -> Set Reference -> Transaction (TypeLookup Symbol Ann)
unsafeGetComponentLength :: HasCallStack => Hash -> Transaction CycleSize

module Unison.PrettyPrintEnvDecl.Sqlite

-- | Given a set of references, return a PPE which contains names for only
--   those references. Names are limited to those within the provided
--   perspective
ppedForReferences :: NamesPerspective -> Set LabeledDependency -> Transaction PrettyPrintEnvDecl

module Unison.Codebase.SqliteCodebase.Paths

-- | Prefer makeCodebasePath or makeCodebaseDirPath when possible.
codebasePath :: FilePath

-- | Makes a path to a sqlite database from a codebase path.
makeCodebasePath :: CodebasePath -> FilePath

-- | Makes a path to the location where sqlite files are stored within a
--   codebase path.
makeCodebaseDirPath :: CodebasePath -> FilePath

-- | Makes a path to store a backup of a sqlite database given the current
--   time.
backupCodebasePath :: SchemaVersion -> NominalDiffTime -> FilePath
lockfilePath :: CodebasePath -> FilePath

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema5To6

-- | The 5 to 6 migration adds the reflog as a table in the DB
migrateSchema5To6 :: CodebasePath -> Transaction ()

module Unison.Codebase.Init.Type
data Init m v a
Init :: (DebugName -> CodebasePath -> m (Either Pretty (m (), Codebase m v a))) -> (DebugName -> CodebasePath -> m (Either CreateCodebaseError (m (), Codebase m v a))) -> (CodebasePath -> CodebasePath) -> Init m v a

-- | open an existing codebase
[$sel:openCodebase:Init] :: Init m v a -> DebugName -> CodebasePath -> m (Either Pretty (m (), Codebase m v a))

-- | create a new codebase
[$sel:createCodebase':Init] :: Init m v a -> DebugName -> CodebasePath -> m (Either CreateCodebaseError (m (), Codebase m v a))

-- | given a codebase root, and given that the codebase root may have other
--   junk in it, give the path to the "actual" files; e.g. what a forked
--   transcript should clone.
[$sel:codebasePath:Init] :: Init m v a -> CodebasePath -> CodebasePath

module Unison.Codebase.FileCodebase
codebaseExists :: MonadIO m => CodebasePath -> m Bool

module Unison.Codebase.Init
data Init m v a
Init :: (forall r. DebugName -> CodebasePath -> CodebaseLockOption -> MigrationStrategy -> (Codebase m v a -> m r) -> m (Either OpenCodebaseError r)) -> (forall r. DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m v a -> m r) -> m (Either CreateCodebaseError r)) -> (CodebasePath -> CodebasePath) -> Init m v a

-- | open an existing codebase
[$sel:withOpenCodebase:Init] :: Init m v a -> forall r. DebugName -> CodebasePath -> CodebaseLockOption -> MigrationStrategy -> (Codebase m v a -> m r) -> m (Either OpenCodebaseError r)

-- | create a new codebase
[$sel:withCreatedCodebase:Init] :: Init m v a -> forall r. DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m v a -> m r) -> m (Either CreateCodebaseError r)

-- | given a codebase root, and given that the codebase root may have other
--   junk in it, give the path to the "actual" files; e.g. what a forked
--   transcript should clone.
[$sel:codebasePath:Init] :: Init m v a -> CodebasePath -> CodebasePath
type DebugName = String

-- | An error that occurred while initializing a codebase.
data InitError
FoundV1Codebase :: InitError
InitErrorOpen :: OpenCodebaseError -> InitError
CouldntCreateCodebase :: Pretty -> InitError
data CodebaseInitOptions
Home :: CodebasePath -> CodebaseInitOptions
Specified :: SpecifiedCodebase -> CodebaseInitOptions
data CodebaseLockOption
DoLock :: CodebaseLockOption
DontLock :: CodebaseLockOption
data InitResult
OpenedCodebase :: InitResult
CreatedCodebase :: InitResult
data SpecifiedCodebase
CreateWhenMissing :: CodebasePath -> SpecifiedCodebase
DontCreateWhenMissing :: CodebasePath -> SpecifiedCodebase
data MigrationStrategy

-- | Perform a migration immediately if one is required.
MigrateAutomatically :: BackupStrategy -> VacuumStrategy -> MigrationStrategy

-- | Prompt the user that a migration is about to occur, continue after
--   acknownledgment
MigrateAfterPrompt :: BackupStrategy -> VacuumStrategy -> MigrationStrategy

-- | Triggers an <a>OpenCodebaseRequiresMigration</a> error instead of
--   migrating
DontMigrate :: MigrationStrategy
data BackupStrategy
Backup :: BackupStrategy
NoBackup :: BackupStrategy
data VacuumStrategy
Vacuum :: VacuumStrategy
NoVacuum :: VacuumStrategy
type Pretty = Pretty ColorText
createCodebase :: MonadIO m => Init m v a -> DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m v a -> m r) -> m (Either Pretty r)

-- | try to init a codebase where none exists and then exit regardless
--   (i.e. `ucm --codebase dir init`)
initCodebaseAndExit :: MonadIO m => Init m Symbol Ann -> Verbosity -> DebugName -> Maybe CodebasePath -> CodebaseLockOption -> m ()
withOpenOrCreateCodebase :: MonadIO m => Init m v a -> DebugName -> CodebaseInitOptions -> CodebaseLockOption -> MigrationStrategy -> ((InitResult, CodebasePath, Codebase m v a) -> m r) -> m (Either (CodebasePath, InitError) r)
withNewUcmCodebaseOrExit :: MonadIO m => Init m Symbol Ann -> Verbosity -> DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m Symbol Ann -> m r) -> m r
withTemporaryUcmCodebase :: MonadUnliftIO m => Init m Symbol Ann -> Verbosity -> DebugName -> CodebaseLockOption -> ((CodebasePath, Codebase m Symbol Ann) -> m r) -> m r
instance GHC.Classes.Ord Unison.Codebase.Init.BackupStrategy
instance GHC.Classes.Eq Unison.Codebase.Init.BackupStrategy
instance GHC.Show.Show Unison.Codebase.Init.BackupStrategy
instance GHC.Classes.Ord Unison.Codebase.Init.VacuumStrategy
instance GHC.Classes.Eq Unison.Codebase.Init.VacuumStrategy
instance GHC.Show.Show Unison.Codebase.Init.VacuumStrategy
instance GHC.Classes.Ord Unison.Codebase.Init.MigrationStrategy
instance GHC.Classes.Eq Unison.Codebase.Init.MigrationStrategy
instance GHC.Show.Show Unison.Codebase.Init.MigrationStrategy
instance GHC.Classes.Eq Unison.Codebase.Init.InitError
instance GHC.Show.Show Unison.Codebase.Init.InitError
instance GHC.Classes.Eq Unison.Codebase.Init.InitResult
instance GHC.Show.Show Unison.Codebase.Init.InitResult

module Unison.Codebase.SqliteCodebase.Migrations

-- | Mapping from schema version to the migration required to get there.
--   E.g. The migration at index 2 must be run on a codebase at version 1.
migrations :: (Reference -> Transaction ConstructorType) -> TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> CodebasePath -> Map SchemaVersion (Transaction ())
data CodebaseVersionStatus
CodebaseUpToDate :: CodebaseVersionStatus
CodebaseUnknownSchemaVersion :: SchemaVersion -> CodebaseVersionStatus
CodebaseRequiresMigration :: SchemaVersion -> SchemaVersion -> CodebaseVersionStatus
checkCodebaseIsUpToDate :: Transaction CodebaseVersionStatus

-- | Migrates a codebase up to the most recent version known to ucm. This
--   is a No-op if it's up to date Returns an error if the schema version
--   is newer than this ucm knows about.
ensureCodebaseIsUpToDate :: MonadIO m => LocalOrRemote -> CodebasePath -> (Reference -> Transaction ConstructorType) -> TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Bool -> BackupStrategy -> VacuumStrategy -> Connection -> m (Either OpenCodebaseError ())

-- | If we need to make a backup, then copy the sqlite database to a new
--   file with a unique name based on current time.
backupCodebaseIfNecessary :: BackupStrategy -> LocalOrRemote -> Connection -> SchemaVersion -> SchemaVersion -> CodebasePath -> IO ()
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Migrations.CodebaseVersionStatus
instance GHC.Classes.Ord Unison.Codebase.SqliteCodebase.Migrations.CodebaseVersionStatus
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.Migrations.CodebaseVersionStatus

module Unison.Codebase.SqliteCodebase
init :: (HasCallStack, MonadUnliftIO m) => Init m Symbol Ann

-- | Like <a>init</a>, but allows passing in an action to be perform when a
--   new codebase is created.
initWithSetup :: (HasCallStack, MonadUnliftIO m) => Transaction () -> Init m Symbol Ann
data MigrationStrategy

-- | Perform a migration immediately if one is required.
MigrateAutomatically :: BackupStrategy -> VacuumStrategy -> MigrationStrategy

-- | Prompt the user that a migration is about to occur, continue after
--   acknownledgment
MigrateAfterPrompt :: BackupStrategy -> VacuumStrategy -> MigrationStrategy

-- | Triggers an <a>OpenCodebaseRequiresMigration</a> error instead of
--   migrating
DontMigrate :: MigrationStrategy
data BackupStrategy
Backup :: BackupStrategy
NoBackup :: BackupStrategy
data VacuumStrategy
Vacuum :: VacuumStrategy
NoVacuum :: VacuumStrategy
data CodebaseLockOption
DoLock :: CodebaseLockOption
DontLock :: CodebaseLockOption

-- | Given two codebase roots (e.g. "./mycodebase"), safely copy the
--   codebase at the source to the destination. Note: this does not copy
--   the .unisonConfig file.
copyCodebase :: MonadIO m => CodebasePath -> CodebasePath -> m ()
instance GHC.Show.Show (Unison.Codebase.SqliteCodebase.Entity m)


-- | Execute a computation of type '{IO} () that has been previously added
--   to the codebase, without setting up an interactive environment.
--   
--   This allows one to run standalone applications implemented in the
--   Unison language.
module Unison.Codebase.Execute
execute :: Codebase IO Symbol Ann -> Runtime Symbol -> HashQualified Name -> IO (Either Error ())

module Unison.Util.TQueue
data TQueue a
TQueue :: TVar (Seq a) -> TVar Word64 -> TQueue a
newIO :: forall a m. MonadIO m => m (TQueue a)
size :: TQueue a -> STM Int
awaitSize :: Int -> TQueue a -> STM ()
peek :: TQueue a -> STM a
dequeue :: TQueue a -> STM a
undequeue :: TQueue a -> a -> STM ()
tryDequeue :: TQueue a -> STM (Maybe a)
dequeueN :: TQueue a -> Int -> STM [a]
enqueueCount :: TQueue a -> STM Word64
flush :: TQueue a -> STM [a]
enqueue :: TQueue a -> a -> STM ()
raceIO :: MonadIO m => STM a -> STM b -> m (Either a b)
tryPeekWhile :: (a -> Bool) -> TQueue a -> STM [a]
takeWhile :: (a -> Bool) -> TQueue a -> STM [a]
peekWhile :: (a -> Bool) -> TQueue a -> STM [a]

module Unison.Util.Text
newtype Text
Text :: Rope Chunk -> Text
data Chunk
Chunk :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Text -> Chunk
empty :: Text
one :: Char -> Text
singleton :: Char -> Text
appendUnbalanced :: Text -> Text -> Text
threshold :: Int
replicate :: Int -> Text -> Text
toLazyText :: Text -> Text
chunkToText :: Chunk -> Text
chunk :: Text -> Chunk
take :: Int -> Text -> Text
drop :: Int -> Text -> Text
uncons :: Text -> Maybe (Char, Text)
unsnoc :: Text -> Maybe (Text, Char)
unconsChunk :: Text -> Maybe (Chunk, Text)
unsnocChunk :: Text -> Maybe (Text, Chunk)
at :: Int -> Text -> Maybe Char
size :: Text -> Int
reverse :: Text -> Text
toUppercase :: Text -> Text
toLowercase :: Text -> Text
fromUtf8 :: Bytes -> Either String Text
toUtf8 :: Text -> Bytes
fromText :: Text -> Text
pack :: String -> Text
toString :: Text -> String
unpack :: Text -> String
toText :: Text -> Text
indexOf :: Text -> Text -> Maybe Word64
dropTextWhileMax :: (Char -> Bool) -> Int -> Text -> (Int, Text)
dropWhileMax :: (Char -> Bool) -> Int -> Text -> (Int, Text)
instance GHC.Base.Monoid Unison.Util.Text.Text
instance GHC.Base.Semigroup Unison.Util.Text.Text
instance GHC.Classes.Ord Unison.Util.Text.Text
instance GHC.Classes.Eq Unison.Util.Text.Text
instance Unison.Util.Rope.Sized Unison.Util.Text.Text
instance GHC.Show.Show Unison.Util.Text.Text
instance Data.String.IsString Unison.Util.Text.Text
instance GHC.Classes.Eq Unison.Util.Text.Chunk
instance GHC.Classes.Ord Unison.Util.Text.Chunk
instance GHC.Base.Semigroup Unison.Util.Text.Chunk
instance GHC.Base.Monoid Unison.Util.Text.Chunk
instance Unison.Util.Rope.Sized Unison.Util.Text.Chunk
instance Unison.Util.Rope.Drop Unison.Util.Text.Chunk
instance Unison.Util.Rope.Take Unison.Util.Text.Chunk
instance Unison.Util.Rope.Index Unison.Util.Text.Chunk GHC.Types.Char
instance Unison.Util.Rope.Reverse Unison.Util.Text.Chunk

module Unison.Runtime.Crypto.Rsa

-- | Parse a RSA public key from a ByteString The input bytestring is a
--   hex-encoded string of the DER file for the public key. It can be
--   generated with those commands: # generate a RSA key of a given size
--   openssl genrsa -out private_key.pem <a>size</a> # output the DER
--   format as a hex string openssl rsa -in private_key.pem -outform DER
--   -pubout | xxd -p
parseRsaPublicKey :: ByteString -> Either Text PublicKey

-- | Parse a RSA private key from a ByteString The input bytestring is a
--   hex-encoded string of the DER file for the private key. It can be
--   generated with those commands: # generate a RSA key of a given size
--   openssl genrsa -out private_key.pem <a>size</a> # output the DER
--   format as a hex string openssl rsa -in private_key.pem -outform DER |
--   xxd -p
parseRsaPrivateKey :: ByteString -> Either Text PrivateKey

-- | Display a RSA Error
rsaErrorToText :: Error -> Text

module Unison.Runtime.ANF
minimizeCyclesOrCrash :: Var v => Term v a -> Term v a
pattern TVar :: Var v => v -> Term ANormalF v
pattern TLit :: Var v => Lit -> Term ANormalF v
pattern TBLit :: Var v => Lit -> Term ANormalF v
pattern TApp :: Var v => Func v -> [v] -> Term ANormalF v
pattern TApv :: Var v => v -> [v] -> Term ANormalF v
pattern TCom :: Var v => Reference -> [v] -> Term ANormalF v
pattern TCon :: Var v => Reference -> CTag -> [v] -> Term ANormalF v
pattern TKon :: Var v => v -> [v] -> Term ANormalF v
pattern TReq :: Var v => Reference -> CTag -> [v] -> Term ANormalF v
pattern TPrm :: Var v => POp -> [v] -> Term ANormalF v
pattern TFOp :: Var v => FOp -> [v] -> Term ANormalF v
pattern THnd :: Var v => [Reference] -> v -> Term ANormalF v -> Term ANormalF v
pattern TLet :: Var v => Direction Word16 -> v -> Mem -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TLetD :: Var v => v -> Mem -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TFrc :: Var v => v -> Term ANormalF v
pattern TLets :: Var v => Direction Word16 -> [v] -> [Mem] -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TName :: Var v => v -> Either Reference v -> [v] -> Term ANormalF v -> Term ANormalF v
pattern TBind :: Var v => Cte v -> ANormal v -> ANormal v
pattern TBinds :: Var v => [Cte v] -> ANormal v -> ANormal v
pattern TShift :: Var v => Reference -> v -> Term ANormalF v -> Term ANormalF v
pattern TMatch :: Var v => v -> Branched (Term ANormalF v) -> Term ANormalF v
data CompileExn
CE :: CallStack -> Pretty ColorText -> CompileExn
internalBug :: HasCallStack => String -> a
data Mem
UN :: Mem
BX :: Mem
data Lit
I :: Int64 -> Lit
N :: Word64 -> Lit
F :: Double -> Lit
T :: Text -> Lit
C :: Char -> Lit
LM :: Referent -> Lit
LY :: Reference -> Lit
data Direction a
Indirect :: a -> Direction a
Direct :: Direction a
data SuperNormal v
Lambda :: [Mem] -> ANormal v -> SuperNormal v
[$sel:conventions:Lambda] :: SuperNormal v -> [Mem]
[$sel:bound:Lambda] :: SuperNormal v -> ANormal v
data SuperGroup v
Rec :: [(v, SuperNormal v)] -> SuperNormal v -> SuperGroup v
[$sel:group:Rec] :: SuperGroup v -> [(v, SuperNormal v)]
[$sel:entry:Rec] :: SuperGroup v -> SuperNormal v
data POp
ADDI :: POp
SUBI :: POp
MULI :: POp
DIVI :: POp
SGNI :: POp
NEGI :: POp
MODI :: POp
POWI :: POp
SHLI :: POp
SHRI :: POp
INCI :: POp
DECI :: POp
LEQI :: POp
EQLI :: POp
ADDN :: POp
SUBN :: POp
MULN :: POp
DIVN :: POp
MODN :: POp
TZRO :: POp
LZRO :: POp
POPC :: POp
POWN :: POp
SHLN :: POp
SHRN :: POp
ANDN :: POp
IORN :: POp
XORN :: POp
COMN :: POp
INCN :: POp
DECN :: POp
LEQN :: POp
EQLN :: POp
ADDF :: POp
SUBF :: POp
MULF :: POp
DIVF :: POp
MINF :: POp
MAXF :: POp
LEQF :: POp
EQLF :: POp
POWF :: POp
EXPF :: POp
SQRT :: POp
LOGF :: POp
LOGB :: POp
ABSF :: POp
CEIL :: POp
FLOR :: POp
TRNF :: POp
RNDF :: POp
COSF :: POp
ACOS :: POp
COSH :: POp
ACSH :: POp
SINF :: POp
ASIN :: POp
SINH :: POp
ASNH :: POp
TANF :: POp
ATAN :: POp
TANH :: POp
ATNH :: POp
ATN2 :: POp
CATT :: POp
TAKT :: POp
DRPT :: POp
SIZT :: POp
IXOT :: POp
UCNS :: POp
USNC :: POp
EQLT :: POp
LEQT :: POp
PAKT :: POp
UPKT :: POp
CATS :: POp
TAKS :: POp
DRPS :: POp
SIZS :: POp
CONS :: POp
SNOC :: POp
IDXS :: POp
BLDS :: POp
VWLS :: POp
VWRS :: POp
SPLL :: POp
SPLR :: POp
PAKB :: POp
UPKB :: POp
TAKB :: POp
DRPB :: POp
IXOB :: POp
IDXB :: POp
SIZB :: POp
FLTB :: POp
CATB :: POp
ITOF :: POp
NTOF :: POp
ITOT :: POp
NTOT :: POp
TTOI :: POp
TTON :: POp
TTOF :: POp
FTOT :: POp
FORK :: POp
EQLU :: POp
CMPU :: POp
EROR :: POp
MISS :: POp
CACH :: POp
LKUP :: POp
LOAD :: POp
CVLD :: POp
SDBX :: POp
VALU :: POp
TLTT :: POp
PRNT :: POp
INFO :: POp
TRCE :: POp
DBTX :: POp
ATOM :: POp
TFRC :: POp
SDBL :: POp
SDBV :: POp
type FOp = Word64
close :: (Var v, Monoid a) => Set v -> Term v a -> Term v a
saturate :: (Var v, Monoid a) => Map ConstructorReference Int -> Term v a -> Term v a
float :: Var v => Monoid a => Map v Reference -> Term v a -> (Term v a, Map Reference Reference, [(Reference, Term v a)], [(Reference, Term v a)])
floatGroup :: Var v => Monoid a => Map v Reference -> [(v, Term v a)] -> ([(v, Id)], [(Reference, Term v a)], [(Reference, Term v a)])
lamLift :: Var v => Monoid a => Map v Reference -> Term v a -> (Term v a, Map Reference Reference, [(Reference, Term v a)], [(Reference, Term v a)])
lamLiftGroup :: Var v => Monoid a => Map v Reference -> [(v, Term v a)] -> ([(v, Id)], [(Reference, Term v a)], [(Reference, Term v a)])
litRef :: Lit -> Reference
inlineAlias :: Var v => Monoid a => Term v a -> Term v a
addDefaultCases :: Var v => Monoid a => Text -> Term v a -> Term v a
data ANormalF v e
ALet :: Direction Word16 -> [Mem] -> e -> e -> ANormalF v e
AName :: Either Reference v -> [v] -> e -> ANormalF v e
ALit :: Lit -> ANormalF v e
ABLit :: Lit -> ANormalF v e
AMatch :: v -> Branched e -> ANormalF v e
AShift :: Reference -> e -> ANormalF v e
AHnd :: [Reference] -> v -> e -> ANormalF v e
AApp :: Func v -> [v] -> ANormalF v e
AFrc :: v -> ANormalF v e
AVar :: v -> ANormalF v e
pattern AApv :: v -> [v] -> ANormalF v e
pattern ACom :: Reference -> [v] -> ANormalF v e
pattern ACon :: Reference -> CTag -> [v] -> ANormalF v e
pattern AKon :: v -> [v] -> ANormalF v e
pattern AReq :: Reference -> CTag -> [v] -> ANormalF v e
pattern APrm :: POp -> [v] -> ANormalF v e
pattern AFOp :: FOp -> [v] -> ANormalF v e
type ANormal = Term ANormalF
data RTag
data CTag
class Tag t
rawTag :: Tag t => t -> Word64
data GroupRef
GR :: Reference -> Word64 -> GroupRef
data Value
Partial :: GroupRef -> [Word64] -> [Value] -> Value
Data :: Reference -> Word64 -> [Word64] -> [Value] -> Value
Cont :: [Word64] -> [Value] -> Cont -> Value
BLit :: BLit -> Value
data Cont
KE :: Cont
Mark :: Word64 -> Word64 -> [Reference] -> Map Reference Value -> Cont -> Cont
Push :: Word64 -> Word64 -> Word64 -> Word64 -> GroupRef -> Cont -> Cont
data BLit
Text :: Text -> BLit
List :: Seq Value -> BLit
TmLink :: Referent -> BLit
TyLink :: Reference -> BLit
Bytes :: Bytes -> BLit
Quote :: Value -> BLit
Code :: SuperGroup Symbol -> BLit
BArr :: ByteArray -> BLit
Pos :: Word64 -> BLit
Neg :: Word64 -> BLit
Char :: Char -> BLit
Float :: Double -> BLit
Arr :: Array Value -> BLit
packTags :: RTag -> CTag -> Word64
unpackTags :: Word64 -> (RTag, CTag)
maskTags :: Word64 -> Word64
type ANFM v = ReaderT (Set v) (State (Word64, Word16, [(v, SuperNormal v)]))
data Branched e
MatchIntegral :: EnumMap Word64 e -> Maybe e -> Branched e
MatchText :: Map Text e -> Maybe e -> Branched e
MatchRequest :: Map Reference (EnumMap CTag ([Mem], e)) -> e -> Branched e
MatchEmpty :: Branched e
MatchData :: Reference -> EnumMap CTag ([Mem], e) -> Maybe e -> Branched e
MatchSum :: EnumMap Word64 ([Mem], e) -> Branched e
MatchNumeric :: Reference -> EnumMap Word64 e -> Maybe e -> Branched e
pattern MatchDataCover :: Reference -> EnumMap CTag ([Mem], e) -> Branched e
data Func v
FVar :: v -> Func v
FComb :: !Reference -> Func v
FCont :: v -> Func v
FCon :: !Reference -> !CTag -> Func v
FReq :: !Reference -> !CTag -> Func v
FPrim :: Either POp FOp -> Func v
data SGEqv v
NumDefns :: SuperGroup v -> SuperGroup v -> SGEqv v
DefnConventions :: SuperNormal v -> SuperNormal v -> SGEqv v
Subterms :: ANormal v -> ANormal v -> SGEqv v
equivocate :: Var v => SuperGroup v -> SuperGroup v -> Either (SGEqv v) ()
superNormalize :: Var v => Term v a -> SuperGroup v
anfTerm :: Var v => Term v a -> ANFM v (DNormal v)
valueTermLinks :: Value -> [Reference]
valueLinks :: Monoid a => (Bool -> Reference -> a) -> Value -> a
groupTermLinks :: Var v => SuperGroup v -> [Reference]
foldGroupLinks :: (Monoid r, Var v) => (Bool -> Reference -> r) -> SuperGroup v -> r
overGroupLinks :: Var v => (Bool -> Reference -> Reference) -> SuperGroup v -> SuperGroup v
traverseGroupLinks :: (Applicative f, Var v) => (Bool -> Reference -> f Reference) -> SuperGroup v -> f (SuperGroup v)
normalLinks :: (Applicative f, Var v) => (Bool -> Reference -> f Reference) -> SuperNormal v -> f (SuperNormal v)
prettyGroup :: Var v => String -> SuperGroup v -> ShowS
prettySuperNormal :: Var v => Int -> SuperNormal v -> ShowS
prettyANF :: Var v => Bool -> Int -> ANormal v -> ShowS
instance GHC.Show.Show Unison.Runtime.ANF.CompileExn
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.Prefix v x)
instance GHC.Enum.Enum Unison.Runtime.ANF.Mem
instance GHC.Show.Show Unison.Runtime.ANF.Mem
instance GHC.Classes.Ord Unison.Runtime.ANF.Mem
instance GHC.Classes.Eq Unison.Runtime.ANF.Mem
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.ANF.RTag
instance GHC.Read.Read Unison.Runtime.ANF.RTag
instance GHC.Show.Show Unison.Runtime.ANF.RTag
instance GHC.Classes.Ord Unison.Runtime.ANF.RTag
instance GHC.Classes.Eq Unison.Runtime.ANF.RTag
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.ANF.CTag
instance GHC.Read.Read Unison.Runtime.ANF.CTag
instance GHC.Show.Show Unison.Runtime.ANF.CTag
instance GHC.Classes.Ord Unison.Runtime.ANF.CTag
instance GHC.Classes.Eq Unison.Runtime.ANF.CTag
instance GHC.Show.Show Unison.Runtime.ANF.SeqEnd
instance GHC.Enum.Enum Unison.Runtime.ANF.SeqEnd
instance GHC.Classes.Ord Unison.Runtime.ANF.SeqEnd
instance GHC.Classes.Eq Unison.Runtime.ANF.SeqEnd
instance Data.Traversable.Traversable Unison.Runtime.ANF.Branched
instance Data.Foldable.Foldable Unison.Runtime.ANF.Branched
instance GHC.Base.Functor Unison.Runtime.ANF.Branched
instance GHC.Classes.Eq e => GHC.Classes.Eq (Unison.Runtime.ANF.Branched e)
instance GHC.Show.Show e => GHC.Show.Show (Unison.Runtime.ANF.Branched e)
instance GHC.Classes.Eq Unison.Runtime.ANF.Lit
instance GHC.Show.Show Unison.Runtime.ANF.Lit
instance GHC.Enum.Bounded Unison.Runtime.ANF.POp
instance GHC.Enum.Enum Unison.Runtime.ANF.POp
instance GHC.Classes.Ord Unison.Runtime.ANF.POp
instance GHC.Classes.Eq Unison.Runtime.ANF.POp
instance GHC.Show.Show Unison.Runtime.ANF.POp
instance Data.Traversable.Traversable Unison.Runtime.ANF.Func
instance Data.Foldable.Foldable Unison.Runtime.ANF.Func
instance GHC.Base.Functor Unison.Runtime.ANF.Func
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Runtime.ANF.Func v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.Func v)
instance Data.Traversable.Traversable Unison.Runtime.ANF.Direction
instance Data.Foldable.Foldable Unison.Runtime.ANF.Direction
instance GHC.Base.Functor Unison.Runtime.ANF.Direction
instance GHC.Show.Show a => GHC.Show.Show (Unison.Runtime.ANF.Direction a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Runtime.ANF.Direction a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Runtime.ANF.Direction a)
instance (GHC.Classes.Eq e, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.Runtime.ANF.ANormalF v e)
instance (GHC.Show.Show e, GHC.Show.Show v) => GHC.Show.Show (Unison.Runtime.ANF.ANormalF v e)
instance (GHC.Show.Show v, GHC.Show.Show s) => GHC.Show.Show (Unison.Runtime.ANF.CTE v s)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Runtime.ANF.SuperNormal v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.SuperNormal v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.SuperGroup v)
instance GHC.Show.Show Unison.Runtime.ANF.GroupRef
instance GHC.Show.Show Unison.Runtime.ANF.Cont
instance GHC.Show.Show Unison.Runtime.ANF.Value
instance GHC.Show.Show Unison.Runtime.ANF.BLit
instance Unison.Var.Var v => GHC.Classes.Eq (Unison.Runtime.ANF.SuperGroup v)
instance GHC.Base.Semigroup (Unison.Runtime.ANF.BranchAccum v)
instance GHC.Base.Monoid (Unison.Runtime.ANF.BranchAccum e)
instance GHC.Base.Functor (Unison.Runtime.ANF.ANormalF v)
instance Data.Bifunctor.Bifunctor Unison.Runtime.ANF.ANormalF
instance Data.Bifoldable.Bifoldable Unison.Runtime.ANF.ANormalF
instance Unison.ABT.Normalized.Align Unison.Runtime.ANF.ANormalF
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Runtime.ANF.Direction a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Unison.Runtime.ANF.Direction a)
instance Unison.Runtime.ANF.Tag Unison.Runtime.ANF.RTag
instance Unison.Runtime.ANF.Tag Unison.Runtime.ANF.CTag
instance GHC.Enum.Enum Unison.Runtime.ANF.CTag
instance GHC.Num.Num Unison.Runtime.ANF.CTag
instance GHC.Enum.Enum Unison.Runtime.ANF.RTag
instance GHC.Num.Num Unison.Runtime.ANF.RTag
instance GHC.Base.Functor (Unison.Runtime.ANF.Prefix v)
instance GHC.Classes.Ord v => GHC.Base.Applicative (Unison.Runtime.ANF.Prefix v)
instance GHC.Exception.Type.Exception Unison.Runtime.ANF.CompileExn

module Unison.Runtime.Pattern
type DataSpec = Map Reference (Either Cons Cons)
splitPatterns :: Var v => DataSpec -> Term v -> Term v
builtinDataSpec :: DataSpec
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.Pattern.PatternRow v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.Pattern.PatternMatrix v)
instance GHC.Show.Show Unison.Runtime.Pattern.SeqMatch
instance GHC.Classes.Ord Unison.Runtime.Pattern.SeqMatch
instance GHC.Classes.Eq Unison.Runtime.Pattern.SeqMatch
instance GHC.Base.Semigroup Unison.Runtime.Pattern.PType
instance GHC.Base.Monoid Unison.Runtime.Pattern.PType

module Unison.Runtime.MCode
data Args'
Arg1 :: !Int -> Args'
Arg2 :: !Int -> !Int -> Args'
ArgN :: {-# UNPACK #-} !PrimArray Int -> Args'
ArgR :: !Int -> !Int -> Args'
data Args
ZArgs :: Args
UArg1 :: !Int -> Args
UArg2 :: !Int -> !Int -> Args
BArg1 :: !Int -> Args
BArg2 :: !Int -> !Int -> Args
DArg2 :: !Int -> !Int -> Args
UArgR :: !Int -> !Int -> Args
BArgR :: !Int -> !Int -> Args
DArgR :: !Int -> !Int -> !Int -> !Int -> Args
BArgN :: !PrimArray Int -> Args
UArgN :: !PrimArray Int -> Args
DArgN :: !PrimArray Int -> !PrimArray Int -> Args
DArgV :: !Int -> !Int -> Args
data RefNums
RN :: (Reference -> Word64) -> (Reference -> Word64) -> RefNums
[$sel:dnum:RN] :: RefNums -> Reference -> Word64
[$sel:cnum:RN] :: RefNums -> Reference -> Word64
data MLit
MI :: !Int -> MLit
MD :: !Double -> MLit
MT :: !Text -> MLit
MM :: !Referent -> MLit
MY :: !Reference -> MLit
data Instr
UPrim1 :: !UPrim1 -> !Int -> Instr
UPrim2 :: !UPrim2 -> !Int -> !Int -> Instr
BPrim1 :: !BPrim1 -> !Int -> Instr
BPrim2 :: !BPrim2 -> !Int -> !Int -> Instr
ForeignCall :: !Bool -> !Word64 -> !Args -> Instr
SetDyn :: !Word64 -> !Int -> Instr
Capture :: !Word64 -> Instr
Name :: !Ref -> !Args -> Instr
Info :: !String -> Instr
Pack :: !Reference -> !Word64 -> !Args -> Instr
Unpack :: !Maybe Reference -> !Int -> Instr
Lit :: !MLit -> Instr
BLit :: !Reference -> !MLit -> Instr
Print :: !Int -> Instr
Reset :: !EnumSet Word64 -> Instr
Fork :: !Int -> Instr
Atomically :: !Int -> Instr
Seq :: !Args -> Instr
TryForce :: !Int -> Instr
data Section
App :: !Bool -> !Ref -> !Args -> Section
Call :: !Bool -> !Word64 -> !Args -> Section
Jump :: !Int -> !Args -> Section
Match :: !Int -> !Branch -> Section
Yield :: !Args -> Section
Ins :: !Instr -> !Section -> Section
Let :: !Section -> !CombIx -> Section
Die :: String -> Section
Exit :: Section
DMatch :: !Maybe Reference -> !Int -> !Branch -> Section
NMatch :: !Maybe Reference -> !Int -> !Branch -> Section
RMatch :: !Int -> !Section -> !EnumMap Word64 Branch -> Section
pattern MatchT :: Int -> Section -> Map Text Section -> Section
pattern MatchW :: Int -> Section -> EnumMap Word64 Section -> Section
data Comb
Lam :: !Int -> !Int -> !Int -> !Int -> !Section -> Comb
type Combs = EnumMap Word64 Comb
data CombIx
CIx :: !Reference -> !Word64 -> !Word64 -> CombIx
data Ref
Stk :: !Int -> Ref
Env :: !Word64 -> !Word64 -> Ref
Dyn :: !Word64 -> Ref
data UPrim1
DECI :: UPrim1
INCI :: UPrim1
NEGI :: UPrim1
SGNI :: UPrim1
LZRO :: UPrim1
TZRO :: UPrim1
COMN :: UPrim1
POPC :: UPrim1
ABSF :: UPrim1
EXPF :: UPrim1
LOGF :: UPrim1
SQRT :: UPrim1
COSF :: UPrim1
ACOS :: UPrim1
COSH :: UPrim1
ACSH :: UPrim1
SINF :: UPrim1
ASIN :: UPrim1
SINH :: UPrim1
ASNH :: UPrim1
TANF :: UPrim1
ATAN :: UPrim1
TANH :: UPrim1
ATNH :: UPrim1
ITOF :: UPrim1
NTOF :: UPrim1
CEIL :: UPrim1
FLOR :: UPrim1
TRNF :: UPrim1
RNDF :: UPrim1
data UPrim2
ADDI :: UPrim2
SUBI :: UPrim2
MULI :: UPrim2
DIVI :: UPrim2
MODI :: UPrim2
DIVN :: UPrim2
MODN :: UPrim2
SHLI :: UPrim2
SHRI :: UPrim2
SHRN :: UPrim2
POWI :: UPrim2
EQLI :: UPrim2
LEQI :: UPrim2
LEQN :: UPrim2
ANDN :: UPrim2
IORN :: UPrim2
XORN :: UPrim2
EQLF :: UPrim2
LEQF :: UPrim2
ADDF :: UPrim2
SUBF :: UPrim2
MULF :: UPrim2
DIVF :: UPrim2
ATN2 :: UPrim2
POWF :: UPrim2
LOGB :: UPrim2
MAXF :: UPrim2
MINF :: UPrim2
data BPrim1
SIZT :: BPrim1
USNC :: BPrim1
UCNS :: BPrim1
ITOT :: BPrim1
NTOT :: BPrim1
FTOT :: BPrim1
TTOI :: BPrim1
TTON :: BPrim1
TTOF :: BPrim1
PAKT :: BPrim1
UPKT :: BPrim1
VWLS :: BPrim1
VWRS :: BPrim1
SIZS :: BPrim1
PAKB :: BPrim1
UPKB :: BPrim1
SIZB :: BPrim1
FLTB :: BPrim1
MISS :: BPrim1
CACH :: BPrim1
LKUP :: BPrim1
LOAD :: BPrim1
CVLD :: BPrim1
VALU :: BPrim1
TLTT :: BPrim1
DBTX :: BPrim1
SDBL :: BPrim1
data BPrim2
EQLU :: BPrim2
CMPU :: BPrim2
DRPT :: BPrim2
CATT :: BPrim2
TAKT :: BPrim2
IXOT :: BPrim2
EQLT :: BPrim2
LEQT :: BPrim2
LEST :: BPrim2
DRPS :: BPrim2
CATS :: BPrim2
TAKS :: BPrim2
CONS :: BPrim2
SNOC :: BPrim2
IDXS :: BPrim2
SPLL :: BPrim2
SPLR :: BPrim2
TAKB :: BPrim2
DRPB :: BPrim2
IDXB :: BPrim2
CATB :: BPrim2
IXOB :: BPrim2
THRO :: BPrim2
TRCE :: BPrim2
SDBX :: BPrim2
SDBV :: BPrim2
data Branch
Test1 :: !Word64 -> !Section -> !Section -> Branch
Test2 :: !Word64 -> !Section -> !Word64 -> !Section -> !Section -> Branch
TestW :: !Section -> !EnumMap Word64 Section -> Branch
TestT :: !Section -> !Map Text Section -> Branch
bcount :: Args -> Int
ucount :: Args -> Int
emitCombs :: Var v => RefNums -> Reference -> Word64 -> SuperGroup v -> EnumMap Word64 Comb
emitComb :: Var v => RefNums -> Reference -> Word64 -> RCtx v -> (Word64, SuperNormal v) -> EnumMap Word64 Comb
emptyRNs :: RefNums
argsToLists :: Args -> ([Int], [Int])
combRef :: CombIx -> Reference
combDeps :: Comb -> [Word64]
combTypes :: Comb -> [Word64]
prettyCombs :: Word64 -> EnumMap Word64 Comb -> ShowS
prettyComb :: Word64 -> Word64 -> Comb -> ShowS
instance GHC.Show.Show Unison.Runtime.MCode.Args'
instance GHC.Classes.Ord Unison.Runtime.MCode.Args
instance GHC.Classes.Eq Unison.Runtime.MCode.Args
instance GHC.Show.Show Unison.Runtime.MCode.Args
instance GHC.Classes.Ord Unison.Runtime.MCode.UPrim1
instance GHC.Classes.Eq Unison.Runtime.MCode.UPrim1
instance GHC.Show.Show Unison.Runtime.MCode.UPrim1
instance GHC.Classes.Ord Unison.Runtime.MCode.UPrim2
instance GHC.Classes.Eq Unison.Runtime.MCode.UPrim2
instance GHC.Show.Show Unison.Runtime.MCode.UPrim2
instance GHC.Classes.Ord Unison.Runtime.MCode.BPrim1
instance GHC.Classes.Eq Unison.Runtime.MCode.BPrim1
instance GHC.Show.Show Unison.Runtime.MCode.BPrim1
instance GHC.Classes.Ord Unison.Runtime.MCode.BPrim2
instance GHC.Classes.Eq Unison.Runtime.MCode.BPrim2
instance GHC.Show.Show Unison.Runtime.MCode.BPrim2
instance GHC.Classes.Ord Unison.Runtime.MCode.MLit
instance GHC.Classes.Eq Unison.Runtime.MCode.MLit
instance GHC.Show.Show Unison.Runtime.MCode.MLit
instance GHC.Show.Show Unison.Runtime.MCode.CombIx
instance GHC.Classes.Ord Unison.Runtime.MCode.CombIx
instance GHC.Classes.Eq Unison.Runtime.MCode.CombIx
instance GHC.Classes.Ord Unison.Runtime.MCode.Ref
instance GHC.Classes.Eq Unison.Runtime.MCode.Ref
instance GHC.Show.Show Unison.Runtime.MCode.Ref
instance GHC.Classes.Ord Unison.Runtime.MCode.Instr
instance GHC.Classes.Eq Unison.Runtime.MCode.Instr
instance GHC.Show.Show Unison.Runtime.MCode.Instr
instance GHC.Classes.Ord Unison.Runtime.MCode.Section
instance GHC.Classes.Eq Unison.Runtime.MCode.Section
instance GHC.Show.Show Unison.Runtime.MCode.Section
instance GHC.Classes.Ord Unison.Runtime.MCode.Branch
instance GHC.Classes.Eq Unison.Runtime.MCode.Branch
instance GHC.Show.Show Unison.Runtime.MCode.Branch
instance GHC.Classes.Ord Unison.Runtime.MCode.Comb
instance GHC.Classes.Eq Unison.Runtime.MCode.Comb
instance GHC.Show.Show Unison.Runtime.MCode.Comb
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.MCode.Ctx v)
instance GHC.Base.Functor Unison.Runtime.MCode.Counted
instance GHC.Base.Functor Unison.Runtime.MCode.Emit
instance GHC.Base.Applicative Unison.Runtime.MCode.Emit
instance GHC.Base.Applicative Unison.Runtime.MCode.Counted

module Unison.Runtime.Debug
traceComb :: Bool -> Word64 -> Comb -> Bool
traceCombs :: Word64 -> Bool -> EnumMap Word64 Comb -> EnumMap Word64 Comb
tracePretty :: Var v => PrettyPrintEnv -> Bool -> Term v -> Term v
tracePrettyGroup :: Var v => Word64 -> Bool -> SuperGroup v -> SuperGroup v

module Unison.Util.Text.Pattern
data Pattern
Join :: [Pattern] -> Pattern
Or :: Pattern -> Pattern -> Pattern
Capture :: Pattern -> Pattern
CaptureAs :: Text -> Pattern -> Pattern
Many :: Bool -> Pattern -> Pattern
Replicate :: Int -> Int -> Pattern -> Pattern
Eof :: Pattern
Literal :: Text -> Pattern
Char :: CharPattern -> Pattern
data CharPattern
Any :: CharPattern
Not :: CharPattern -> CharPattern
Union :: CharPattern -> CharPattern -> CharPattern
Intersect :: CharPattern -> CharPattern -> CharPattern
CharRange :: Char -> Char -> CharPattern
CharSet :: [Char] -> CharPattern
CharClass :: CharClass -> CharPattern
data CharClass
AlphaNum :: CharClass
Upper :: CharClass
Lower :: CharClass
Whitespace :: CharClass
Control :: CharClass
Printable :: CharClass
MarkChar :: CharClass
Number :: CharClass
Punctuation :: CharClass
Symbol :: CharClass
Separator :: CharClass
Letter :: CharClass
data CPattern
CP :: Pattern -> (Text -> Maybe ([Text], Text)) -> CPattern
cpattern :: Pattern -> CPattern
run :: Pattern -> Text -> Maybe ([Text], Text)
data Stack
Empty :: !Captures -> Stack
Mark :: !Captures -> !Text -> !Stack -> Stack
type Captures = [Text] -> [Text]
stackCaptures :: Stack -> Captures
pushCaptures :: Captures -> Stack -> Stack
pushCapture :: Text -> Stack -> Stack
appendCaptures :: Captures -> Captures -> Captures
emptyCaptures :: Captures
capturesToList :: Captures -> [Text]
type Compiled r = (Stack -> Text -> r) -> (Stack -> Text -> r) -> Stack -> Text -> r
compile :: Pattern -> Compiled r
charInPred :: [Char] -> Char -> Bool
charNotInPred :: [Char] -> Char -> Bool
charPatternPred :: CharPattern -> Char -> Bool
charClassPred :: CharClass -> Char -> Bool
try :: String -> Compiled r -> Compiled r
instance GHC.Classes.Ord Unison.Util.Text.Pattern.CharClass
instance GHC.Classes.Eq Unison.Util.Text.Pattern.CharClass
instance GHC.Show.Show Unison.Util.Text.Pattern.CharClass
instance GHC.Classes.Ord Unison.Util.Text.Pattern.CharPattern
instance GHC.Classes.Eq Unison.Util.Text.Pattern.CharPattern
instance GHC.Show.Show Unison.Util.Text.Pattern.CharPattern
instance GHC.Classes.Ord Unison.Util.Text.Pattern.Pattern
instance GHC.Classes.Eq Unison.Util.Text.Pattern.Pattern
instance GHC.Show.Show Unison.Util.Text.Pattern.Pattern
instance GHC.Classes.Eq Unison.Util.Text.Pattern.CPattern
instance GHC.Classes.Ord Unison.Util.Text.Pattern.CPattern

module Unison.Runtime.Foreign
data Foreign
[Wrap] :: Reference -> !e -> Foreign
data HashAlgorithm
[HashAlgorithm] :: HashAlgorithm a => Reference -> a -> HashAlgorithm
unwrapForeign :: Foreign -> a
maybeUnwrapForeign :: Reference -> Foreign -> Maybe a
wrapBuiltin :: forall f. BuiltinForeign f => f -> Foreign
maybeUnwrapBuiltin :: forall f. BuiltinForeign f => Foreign -> Maybe f
unwrapBuiltin :: BuiltinForeign f => Foreign -> f
class BuiltinForeign f
foreignRef :: BuiltinForeign f => Tagged f Reference
newtype Tls
Tls :: Context -> Tls
data Failure a
Failure :: Reference -> Text -> a -> Failure a
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.Foreign.HashAlgorithm
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Text
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Bytes.Bytes
instance Unison.Runtime.Foreign.BuiltinForeign GHC.IO.Handle.Types.Handle
instance Unison.Runtime.Foreign.BuiltinForeign System.Process.Common.ProcessHandle
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Referent.Referent
instance Unison.Runtime.Foreign.BuiltinForeign Network.Socket.Types.Socket
instance Unison.Runtime.Foreign.BuiltinForeign Network.UDP.ListenSocket
instance Unison.Runtime.Foreign.BuiltinForeign Network.UDP.ClientSockAddr
instance Unison.Runtime.Foreign.BuiltinForeign Network.UDP.UDPSocket
instance Unison.Runtime.Foreign.BuiltinForeign GHC.Conc.Sync.ThreadId
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Parameters.ClientParams
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Parameters.ServerParams
instance Unison.Runtime.Foreign.BuiltinForeign Data.X509.SignedCertificate
instance Unison.Runtime.Foreign.BuiltinForeign Data.X509.PrivateKey.PrivKey
instance Unison.Runtime.Foreign.BuiltinForeign GHC.IO.FilePath
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Context.Internal.Context
instance Unison.Runtime.Foreign.BuiltinForeign (Unison.Runtime.ANF.SuperGroup Unison.Symbol.Symbol)
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.ANF.Value
instance Unison.Runtime.Foreign.BuiltinForeign System.Clock.TimeSpec
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Pattern.CPattern
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Pattern.CharPattern
instance GHC.Classes.Eq Unison.Runtime.Foreign.Foreign
instance GHC.Classes.Ord Unison.Runtime.Foreign.Foreign
instance GHC.Show.Show Unison.Runtime.Foreign.Foreign

module Unison.Runtime.Stack
data K
KE :: K
CB :: Callback -> K
Mark :: !Int -> !Int -> !EnumSet Word64 -> !EnumMap Word64 Closure -> !K -> K
Push :: !Int -> !Int -> !Int -> !Int -> !CombIx -> !K -> K
data Closure
PAp :: {-# UNPACK #-} !CombIx -> {-# UNPACK #-} !Seg 'UN -> !Seg 'BX -> Closure
Enum :: !Reference -> !Word64 -> Closure
DataU1 :: !Reference -> !Word64 -> !Int -> Closure
DataU2 :: !Reference -> !Word64 -> !Int -> !Int -> Closure
DataB1 :: !Reference -> !Word64 -> !Closure -> Closure
DataB2 :: !Reference -> !Word64 -> !Closure -> !Closure -> Closure
DataUB :: !Reference -> !Word64 -> !Int -> !Closure -> Closure
DataG :: !Reference -> !Word64 -> !Seg 'UN -> !Seg 'BX -> Closure
Captured :: !K -> !Int -> !Int -> {-# UNPACK #-} !Seg 'UN -> !Seg 'BX -> Closure
Foreign :: !Foreign -> Closure
BlackHole :: Closure
pattern DataC :: Reference -> Word64 -> [Int] -> [Closure] -> Closure
pattern PApV :: CombIx -> [Int] -> [Closure] -> Closure
pattern CapV :: K -> Int -> Int -> [Int] -> [Closure] -> Closure
newtype Callback
Hook :: (Stack 'UN -> Stack 'BX -> IO ()) -> Callback
data Augment
I :: Augment
K :: Augment
C :: Augment
data Dump
A :: Dump
F :: Int -> Int -> Dump
S :: Dump
class MEM (b :: Mem) where {
    data Stack b :: Type;
    type Elem b :: Type;
    type Seg b :: Type;
}
alloc :: MEM b => IO (Stack b)
peek :: MEM b => Stack b -> IO (Elem b)
peekOff :: MEM b => Stack b -> Off -> IO (Elem b)
poke :: MEM b => Stack b -> Elem b -> IO ()
pokeOff :: MEM b => Stack b -> Off -> Elem b -> IO ()
grab :: MEM b => Stack b -> SZ -> IO (Seg b, Stack b)
ensure :: MEM b => Stack b -> SZ -> IO (Stack b)
bump :: MEM b => Stack b -> IO (Stack b)
bumpn :: MEM b => Stack b -> SZ -> IO (Stack b)
duplicate :: MEM b => Stack b -> IO (Stack b)
discardFrame :: MEM b => Stack b -> IO (Stack b)
saveFrame :: MEM b => Stack b -> IO (Stack b, SZ, SZ)
saveArgs :: MEM b => Stack b -> IO (Stack b, SZ)
restoreFrame :: MEM b => Stack b -> SZ -> SZ -> IO (Stack b)
prepareArgs :: MEM b => Stack b -> Args' -> IO (Stack b)
acceptArgs :: MEM b => Stack b -> Int -> IO (Stack b)
frameArgs :: MEM b => Stack b -> IO (Stack b)
augSeg :: MEM b => Augment -> Stack b -> Seg b -> Maybe Args' -> IO (Seg b)
dumpSeg :: MEM b => Stack b -> Seg b -> Dump -> IO (Stack b)
adjustArgs :: MEM b => Stack b -> SZ -> IO (Stack b)
fsize :: MEM b => Stack b -> SZ
asize :: MEM b => Stack b -> SZ
type Off = Int
type SZ = Int
type FP = Int
traceK :: Reference -> K -> [(Reference, Int)]
frameDataSize :: K -> (Int, Int)
marshalToForeign :: HasCallStack => Closure -> Foreign
unull :: Seg 'UN
bnull :: Seg 'BX
peekD :: Stack 'UN -> IO Double
peekOffD :: Stack 'UN -> Int -> IO Double
pokeD :: Stack 'UN -> Double -> IO ()
pokeOffD :: Stack 'UN -> Int -> Double -> IO ()
peekN :: Stack 'UN -> IO Word64
peekOffN :: Stack 'UN -> Int -> IO Word64
pokeN :: Stack 'UN -> Word64 -> IO ()
pokeOffN :: Stack 'UN -> Int -> Word64 -> IO ()
peekBi :: BuiltinForeign b => Stack 'BX -> IO b
peekOffBi :: BuiltinForeign b => Stack 'BX -> Int -> IO b
pokeBi :: BuiltinForeign b => Stack 'BX -> b -> IO ()
pokeOffBi :: BuiltinForeign b => Stack 'BX -> Int -> b -> IO ()
peekOffS :: Stack 'BX -> Int -> IO (Seq Closure)
pokeS :: Stack 'BX -> Seq Closure -> IO ()
pokeOffS :: Stack 'BX -> Int -> Seq Closure -> IO ()
frameView :: MEM b => Show (Elem b) => Stack b -> IO ()
uscount :: Seg 'UN -> Int
bscount :: Seg 'BX -> Int
closureTermRefs :: Monoid m => (Reference -> m) -> Closure -> m
instance GHC.Classes.Ord Unison.Runtime.Stack.Closure
instance GHC.Classes.Eq Unison.Runtime.Stack.Closure
instance GHC.Show.Show Unison.Runtime.Stack.Closure
instance GHC.Classes.Ord Unison.Runtime.Stack.K
instance GHC.Classes.Eq Unison.Runtime.Stack.K
instance GHC.Show.Show Unison.Runtime.Stack.K
instance Unison.Runtime.Stack.MEM 'Unison.Runtime.ANF.BX
instance GHC.Classes.Eq Unison.Runtime.Stack.Callback
instance GHC.Classes.Ord Unison.Runtime.Stack.Callback
instance Unison.Runtime.Stack.MEM 'Unison.Runtime.ANF.UN
instance GHC.Show.Show (Unison.Runtime.Stack.Stack 'Unison.Runtime.ANF.BX)
instance GHC.Show.Show (Unison.Runtime.Stack.Stack 'Unison.Runtime.ANF.UN)

module Unison.Runtime.Exception
data RuntimeExn
PE :: CallStack -> Pretty ColorText -> RuntimeExn
BU :: [(Reference, Int)] -> Text -> Closure -> RuntimeExn
die :: HasCallStack => String -> IO a
dieP :: HasCallStack => Pretty ColorText -> IO a
exn :: HasCallStack => String -> a
instance GHC.Show.Show Unison.Runtime.Exception.RuntimeExn
instance GHC.Exception.Type.Exception Unison.Runtime.Exception.RuntimeExn

module Unison.Runtime.Serialize
unknownTag :: MonadGet m => String -> Word8 -> m a
class Tag t
tag2word :: Tag t => t -> Word8
word2tag :: (Tag t, MonadGet m) => Word8 -> m t
putTag :: MonadPut m => Tag t => t -> m ()
getTag :: MonadGet m => Tag t => m t
putChar :: MonadPut m => Char -> m ()
getChar :: MonadGet m => m Char
putFloat :: MonadPut m => Double -> m ()
getFloat :: MonadGet m => m Double
putBool :: MonadPut m => Bool -> m ()
getBool :: MonadGet m => m Bool
putNat :: MonadPut m => Word64 -> m ()
getNat :: MonadGet m => m Word64
putInt :: MonadPut m => Int64 -> m ()
getInt :: MonadGet m => m Int64
putLength :: (MonadPut m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => n -> m ()
getLength :: (MonadGet m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => m n
putPositive :: MonadPut m => Bits n => Bits (Unsigned n) => Integral n => Integral (Unsigned n) => n -> m ()
getPositive :: forall m n. Bounded n => Integral n => MonadGet m => m n
putFoldable :: (Foldable f, MonadPut m) => (a -> m ()) -> f a -> m ()
putMap :: MonadPut m => (a -> m ()) -> (b -> m ()) -> Map a b -> m ()
getList :: MonadGet m => m a -> m [a]
getMap :: (MonadGet m, Ord a) => m a -> m b -> m (Map a b)
putEnumMap :: MonadPut m => EnumKey k => (k -> m ()) -> (v -> m ()) -> EnumMap k v -> m ()
getEnumMap :: MonadGet m => EnumKey k => m k -> m v -> m (EnumMap k v)
putEnumSet :: MonadPut m => EnumKey k => (k -> m ()) -> EnumSet k -> m ()
getEnumSet :: MonadGet m => EnumKey k => m k -> m (EnumSet k)
putMaybe :: MonadPut m => Maybe a -> (a -> m ()) -> m ()
getMaybe :: MonadGet m => m a -> m (Maybe a)
putPair :: MonadPut m => (a -> m ()) -> (b -> m ()) -> (a, b) -> m ()
getPair :: MonadGet m => m a -> m b -> m (a, b)
getBytes :: MonadGet m => m Bytes
putBytes :: MonadPut m => Bytes -> m ()
getByteArray :: MonadGet m => m ByteArray
putByteArray :: MonadPut m => ByteArray -> m ()
getBlock :: MonadGet m => m Chunk
putBlock :: MonadPut m => Chunk -> m ()
putHash :: MonadPut m => Hash -> m ()
getHash :: MonadGet m => m Hash
putReferent :: MonadPut m => Referent -> m ()
getReferent :: MonadGet m => m Referent
getConstructorType :: MonadGet m => m ConstructorType
putConstructorType :: MonadPut m => ConstructorType -> m ()
putText :: MonadPut m => Text -> m ()
getText :: MonadGet m => m Text
putReference :: MonadPut m => Reference -> m ()
getReference :: MonadGet m => m Reference
putConstructorReference :: MonadPut m => ConstructorReference -> m ()
getConstructorReference :: MonadGet m => m ConstructorReference
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.UPrim1
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.UPrim2
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.BPrim1
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.BPrim2

module Unison.Runtime.MCode.Serialize
putComb :: MonadPut m => Comb -> m ()
getComb :: MonadGet m => m Comb
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.BranchT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.MLitT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.RefT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.ArgsT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.InstrT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.SectionT

module Unison.Runtime.ANF.Serialize
type Version = Word32
data TmTag
VarT :: TmTag
ForceT :: TmTag
AppT :: TmTag
HandleT :: TmTag
ShiftT :: TmTag
MatchT :: TmTag
LitT :: TmTag
NameRefT :: TmTag
NameVarT :: TmTag
LetDirT :: TmTag
LetIndT :: TmTag
BxLitT :: TmTag
data FnTag
FVarT :: FnTag
FCombT :: FnTag
FContT :: FnTag
FConT :: FnTag
FReqT :: FnTag
FPrimT :: FnTag
FForeignT :: FnTag
data MtTag
MIntT :: MtTag
MTextT :: MtTag
MReqT :: MtTag
MEmptyT :: MtTag
MDataT :: MtTag
MSumT :: MtTag
MNumT :: MtTag
data LtTag
IT :: LtTag
NT :: LtTag
FT :: LtTag
TT :: LtTag
CT :: LtTag
LMT :: LtTag
LYT :: LtTag
data BLTag
TextT :: BLTag
ListT :: BLTag
TmLinkT :: BLTag
TyLinkT :: BLTag
BytesT :: BLTag
QuoteT :: BLTag
CodeT :: BLTag
BArrT :: BLTag
PosT :: BLTag
NegT :: BLTag
CharT :: BLTag
FloatT :: BLTag
ArrT :: BLTag
data VaTag
PartialT :: VaTag
DataT :: VaTag
ContT :: VaTag
BLitT :: VaTag
data CoTag
KET :: CoTag
MarkT :: CoTag
PushT :: CoTag
index :: Eq v => [v] -> v -> Maybe Word64
deindex :: HasCallStack => [v] -> Word64 -> v
pushCtx :: [v] -> [v] -> [v]
putIndex :: MonadPut m => Word64 -> m ()
getIndex :: MonadGet m => m Word64
putVar :: MonadPut m => Eq v => [v] -> v -> m ()
getVar :: MonadGet m => [v] -> m v
putArgs :: MonadPut m => Eq v => [v] -> [v] -> m ()
getArgs :: MonadGet m => [v] -> m [v]
putCCs :: MonadPut m => [Mem] -> m ()
getCCs :: MonadGet m => m [Mem]
putGroup :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> SuperGroup v -> m ()
getGroup :: MonadGet m => Var v => m (SuperGroup v)
putComb :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> [v] -> SuperNormal v -> m ()
getFresh :: Var v => Word64 -> v
getComb :: MonadGet m => Var v => [v] -> Word64 -> m (SuperNormal v)
putNormal :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> [v] -> ANormal v -> m ()
getNormal :: MonadGet m => Var v => [v] -> Word64 -> m (ANormal v)
putFunc :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> [v] -> Func v -> m ()
getFunc :: MonadGet m => Var v => [v] -> m (Func v)
putPOp :: MonadPut m => POp -> m ()
getPOp :: MonadGet m => m POp
pOpCode :: POp -> Word16
pOpAssoc :: [(POp, Word16)]
pop2word :: Map POp Word16
word2pop :: Map Word16 POp
putLit :: MonadPut m => Lit -> m ()
getLit :: MonadGet m => m Lit
putBLit :: MonadPut m => BLit -> m ()
getBLit :: MonadGet m => Version -> m BLit
putRefs :: MonadPut m => [Reference] -> m ()
getRefs :: MonadGet m => m [Reference]
putBranches :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> [v] -> Branched (ANormal v) -> m ()
getBranches :: MonadGet m => Var v => [v] -> Word64 -> m (Branched (ANormal v))
putCase :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> [v] -> ([Mem], ANormal v) -> m ()
getCase :: MonadGet m => Var v => [v] -> Word64 -> m ([Mem], ANormal v)
putCTag :: MonadPut m => CTag -> m ()
getCTag :: MonadGet m => m CTag
putGroupRef :: MonadPut m => GroupRef -> m ()
getGroupRef :: MonadGet m => m GroupRef
putValue :: MonadPut m => Value -> m ()
getValue :: MonadGet m => Version -> m Value
putCont :: MonadPut m => Cont -> m ()
getCont :: MonadGet m => Version -> m Cont
deserializeGroup :: Var v => ByteString -> Either String (SuperGroup v)
serializeGroup :: Var v => EnumMap FOp Text -> SuperGroup v -> ByteString

-- | Serializes a <a>SuperGroup</a> for rehashing.
--   
--   Expected as arguments are some code, and the <a>Reference</a> that
--   refers to it. In particular, if the code refers to itself by
--   reference, or if the code is part of a mututally-recursive set of
--   definitions (which have a common hash), the reference used as part of
--   that (mutual) recursion must be supplied.
--   
--   Using that reference, we find all references in the code to that
--   connected component. In the resulting byte string, those references
--   are instead replaced by positions in a listing of the connected
--   component. This means that the byte string is independent of the hash
--   used for the self reference. Only the order matters (which is
--   determined by the <a>Reference</a>). Then the bytes can be re-hashed
--   to establish a new hash for the connected component. This operation
--   should be idempotent as long as the indexing is preserved.
--   
--   Supplying a <a>Builtin</a> reference is not supported. Such code
--   shouldn't be subject to rehashing.
serializeGroupForRehash :: Var v => EnumMap FOp Text -> Reference -> SuperGroup v -> ByteString
getVersionedValue :: MonadGet m => m Value
deserializeValue :: ByteString -> Either String Value
serializeValue :: Value -> ByteString
serializeValueLazy :: Value -> ByteString
valueVersion :: Word32
codeVersion :: Word32
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.CoTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.VaTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.BLTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.LtTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.MtTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.FnTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.TmTag

module Unison.Runtime.ANF.Rehash
checkGroupHashes :: Var v => [(Referent, SuperGroup v)] -> Either (Text, [Referent]) (Either [Referent] [Referent])
rehashGroups :: Var v => Map Reference (SuperGroup v) -> Either (Text, [Referent]) (Map Reference Reference, Map Reference (SuperGroup v))
checkMissing :: Var v => [(Referent, SuperGroup v)] -> Either (Text, [Referent]) [Reference]
rehashSCC :: Var v => SCC (Reference, SuperGroup v) -> (Map Reference Reference, Map Reference (SuperGroup v))
checkSCC :: SCC (Reference, SuperGroup v) -> Bool

module Unison.Runtime.Foreign.Function
data ForeignFunc
[FF] :: (Stack 'UN -> Stack 'BX -> Args -> IO a) -> (Stack 'UN -> Stack 'BX -> r -> IO (Stack 'UN, Stack 'BX)) -> (a -> IO r) -> ForeignFunc
class ForeignConvention a
readForeign :: ForeignConvention a => [Int] -> [Int] -> Stack 'UN -> Stack 'BX -> IO ([Int], [Int], a)
writeForeign :: ForeignConvention a => Stack 'UN -> Stack 'BX -> a -> IO (Stack 'UN, Stack 'BX)
mkForeign :: (ForeignConvention a, ForeignConvention r) => (a -> IO r) -> ForeignFunc
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Int
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word64
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word8
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word16
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word32
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Char
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Stack.Closure
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Util.Text.Text
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Util.Bytes.Bytes
instance Unison.Runtime.Foreign.Function.ForeignConvention Network.Socket.Types.Socket
instance Unison.Runtime.Foreign.Function.ForeignConvention Network.UDP.UDPSocket
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Conc.Sync.ThreadId
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Handle.Types.Handle
instance Unison.Runtime.Foreign.Function.ForeignConvention Data.Time.Clock.Internal.POSIXTime.POSIXTime
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention (GHC.Maybe.Maybe a)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (Data.Either.Either a b)
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Exception.IOException
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Double
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Bool
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Base.String
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Device.SeekMode
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.IOMode.IOMode
instance Unison.Runtime.Foreign.Function.ForeignConvention ()
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b)
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Runtime.Foreign.Failure a)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c, Unison.Runtime.Foreign.Function.ForeignConvention d) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c, d)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c, Unison.Runtime.Foreign.Function.ForeignConvention d, Unison.Runtime.Foreign.Function.ForeignConvention e) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c, d, e)
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Handle.Types.BufferMode
instance Unison.Runtime.Foreign.Function.ForeignConvention [Unison.Runtime.Stack.Closure]
instance Unison.Runtime.Foreign.Function.ForeignConvention [Unison.Runtime.Foreign.Foreign]
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.MVar.MVar Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.Conc.Sync.TVar Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.IORef.IORef Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Atomics.Internal.Ticket Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Util.RefPromise.Promise Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Runtime.ANF.SuperGroup Unison.Symbol.Symbol)
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.ANF.Value
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Foreign.Foreign
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Primitive.Array.MutableArray s Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Primitive.ByteArray.MutableByteArray s)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Primitive.Array.Array Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention Data.Primitive.ByteArray.ByteArray
instance Unison.Runtime.Foreign.BuiltinForeign b => Unison.Runtime.Foreign.Function.ForeignConvention b
instance (Unison.Runtime.Foreign.BuiltinForeign a, Unison.Runtime.Foreign.BuiltinForeign b) => Unison.Runtime.Foreign.Function.ForeignConvention [(a, b)]
instance Unison.Runtime.Foreign.BuiltinForeign b => Unison.Runtime.Foreign.Function.ForeignConvention [b]
instance GHC.Show.Show Unison.Runtime.Foreign.Function.ForeignFunc
instance GHC.Classes.Eq Unison.Runtime.Foreign.Function.ForeignFunc
instance GHC.Classes.Ord Unison.Runtime.Foreign.Function.ForeignFunc

module Unison.Runtime.Decompile
decompile :: Var v => (Reference -> Maybe Reference) -> (Word64 -> Word64 -> Maybe (Term v ())) -> Closure -> DecompResult v
type DecompResult v = (Set DecompError, Term v ())
data DecompError
BadBool :: !Word64 -> DecompError
BadUnboxed :: !Reference -> DecompError
BadForeign :: !Reference -> DecompError
BadData :: !Reference -> DecompError
BadPAp :: !Reference -> DecompError
UnkComb :: !Reference -> DecompError
UnkLocal :: !Reference -> !Word64 -> DecompError
Cont :: DecompError
Exn :: DecompError
renderDecompError :: DecompError -> Error
instance GHC.Classes.Ord Unison.Runtime.Decompile.DecompError
instance GHC.Classes.Eq Unison.Runtime.Decompile.DecompError

module Unison.Runtime.Builtin
builtinLookup :: Map Reference (Sandbox, SuperNormal Symbol)
builtinTermNumbering :: Map Reference Word64
builtinTypeNumbering :: Map Reference Word64
builtinTermBackref :: EnumMap Word64 Reference
builtinTypeBackref :: EnumMap Word64 Reference
builtinForeigns :: EnumMap Word64 ForeignFunc
sandboxedForeigns :: EnumMap Word64 ForeignFunc
numberedTermLookup :: EnumMap Word64 (SuperNormal Symbol)
data Sandbox
Tracked :: Sandbox
Untracked :: Sandbox
baseSandboxInfo :: Map Reference (Set Reference)
instance GHC.Enum.Bounded Unison.Runtime.Builtin.Sandbox
instance GHC.Enum.Enum Unison.Runtime.Builtin.Sandbox
instance GHC.Read.Read Unison.Runtime.Builtin.Sandbox
instance GHC.Show.Show Unison.Runtime.Builtin.Sandbox
instance GHC.Classes.Ord Unison.Runtime.Builtin.Sandbox
instance GHC.Classes.Eq Unison.Runtime.Builtin.Sandbox
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v, v, v, v)

module Unison.Runtime.Machine

-- | A ref storing every currently active thread. This is helpful for
--   cleaning up orphaned threads when the main process completes. We track
--   threads when running in a host process like UCM, otherwise we don't
--   bother since forked threads are cleaned up automatically on
--   termination.
type ActiveThreads = Maybe (IORef (Set ThreadId))
type Tag = Word64
type DEnv = EnumMap Word64 Closure
data Tracer
NoTrace :: Tracer
MsgTrace :: String -> String -> String -> Tracer
SimpleTrace :: String -> Tracer
data CCache
CCache :: EnumMap Word64 ForeignFunc -> Bool -> (Bool -> Closure -> Tracer) -> TVar (EnumMap Word64 Combs) -> TVar (EnumMap Word64 Reference) -> TVar (EnumMap Word64 Reference) -> TVar Word64 -> TVar Word64 -> TVar (Map Reference (SuperGroup Symbol)) -> TVar (Map Reference Word64) -> TVar (Map Reference Word64) -> TVar (Map Reference (Set Reference)) -> CCache
[$sel:foreignFuncs:CCache] :: CCache -> EnumMap Word64 ForeignFunc
[$sel:sandboxed:CCache] :: CCache -> Bool
[$sel:tracer:CCache] :: CCache -> Bool -> Closure -> Tracer
[$sel:combs:CCache] :: CCache -> TVar (EnumMap Word64 Combs)
[$sel:combRefs:CCache] :: CCache -> TVar (EnumMap Word64 Reference)
[$sel:tagRefs:CCache] :: CCache -> TVar (EnumMap Word64 Reference)
[$sel:freshTm:CCache] :: CCache -> TVar Word64
[$sel:freshTy:CCache] :: CCache -> TVar Word64
[$sel:intermed:CCache] :: CCache -> TVar (Map Reference (SuperGroup Symbol))
[$sel:refTm:CCache] :: CCache -> TVar (Map Reference Word64)
[$sel:refTy:CCache] :: CCache -> TVar (Map Reference Word64)
[$sel:sandbox:CCache] :: CCache -> TVar (Map Reference (Set Reference))
refNumsTm :: CCache -> IO (Map Reference Word64)
refNumsTy :: CCache -> IO (Map Reference Word64)
refNumTm :: CCache -> Reference -> IO Word64
refNumTy :: CCache -> Reference -> IO Word64
refNumTy' :: CCache -> Reference -> IO (Maybe Word64)
baseCCache :: Bool -> IO CCache
info :: Show a => String -> a -> IO ()
infos :: String -> String -> IO ()
stk'info :: Stack 'BX -> IO ()
eval0 :: CCache -> ActiveThreads -> Section -> IO ()
topDEnv :: Map Reference Word64 -> Map Reference Word64 -> (DEnv, K -> K)
apply0 :: Maybe (Stack 'UN -> Stack 'BX -> IO ()) -> CCache -> ActiveThreads -> Word64 -> IO ()
apply1 :: (Stack 'UN -> Stack 'BX -> IO ()) -> CCache -> ActiveThreads -> Closure -> IO ()
jump0 :: (Stack 'UN -> Stack 'BX -> IO ()) -> CCache -> ActiveThreads -> Closure -> IO ()
unitValue :: Closure
lookupDenv :: Word64 -> DEnv -> Closure
buildLit :: Reference -> MLit -> Closure
exec :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Reference -> Instr -> IO (DEnv, Stack 'UN, Stack 'BX, K)
encodeExn :: Stack 'UN -> Stack 'BX -> Either SomeException () -> IO (Stack 'BX)
numValue :: Maybe Reference -> Closure -> IO Word64
eval :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Reference -> Section -> IO ()
forkEval :: CCache -> ActiveThreads -> Closure -> IO ThreadId
nestEval :: CCache -> ActiveThreads -> (Closure -> IO ()) -> Closure -> IO ()
atomicEval :: CCache -> ActiveThreads -> (Closure -> IO ()) -> Closure -> IO ()
enter :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Bool -> Args -> Comb -> IO ()
name :: Stack 'UN -> Stack 'BX -> Args -> Closure -> IO (Stack 'BX)
apply :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Bool -> Args -> Closure -> IO ()
jump :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Args -> Closure -> IO ()
repush :: CCache -> ActiveThreads -> Stack 'UN -> Stack 'BX -> DEnv -> K -> K -> IO ()
moveArgs :: Stack 'UN -> Stack 'BX -> Args -> IO (Stack 'UN, Stack 'BX)
closureArgs :: Stack 'BX -> Args -> IO [Closure]
buildData :: Stack 'UN -> Stack 'BX -> Reference -> Tag -> Args -> IO Closure
dumpDataNoTag :: Maybe Reference -> Stack 'UN -> Stack 'BX -> Closure -> IO (Word64, Stack 'UN, Stack 'BX)
dumpData :: Maybe Reference -> Stack 'UN -> Stack 'BX -> Closure -> IO (Stack 'UN, Stack 'BX)
closeArgs :: Augment -> Stack 'UN -> Stack 'BX -> Seg 'UN -> Seg 'BX -> Args -> IO (Seg 'UN, Seg 'BX)
peekForeign :: Stack 'BX -> Int -> IO a
uprim1 :: Stack 'UN -> UPrim1 -> Int -> IO (Stack 'UN)
uprim2 :: Stack 'UN -> UPrim2 -> Int -> Int -> IO (Stack 'UN)
bprim1 :: Stack 'UN -> Stack 'BX -> BPrim1 -> Int -> IO (Stack 'UN, Stack 'BX)
bprim2 :: Stack 'UN -> Stack 'BX -> BPrim2 -> Int -> Int -> IO (Stack 'UN, Stack 'BX)
yield :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> IO ()
selectTextBranch :: Text -> Section -> Map Text Section -> Section
selectBranch :: Tag -> Branch -> Section
splitCont :: DEnv -> Stack 'UN -> Stack 'BX -> K -> Word64 -> IO (Closure, DEnv, Stack 'UN, Stack 'BX, K)
discardCont :: DEnv -> Stack 'UN -> Stack 'BX -> K -> Word64 -> IO (DEnv, Stack 'UN, Stack 'BX, K)
resolve :: CCache -> DEnv -> Stack 'BX -> Ref -> IO Closure
unhandledErr :: String -> CCache -> Word64 -> IO a
combSection :: HasCallStack => CCache -> CombIx -> IO Comb
dummyRef :: Reference
reserveIds :: Word64 -> TVar Word64 -> IO Word64
updateMap :: Semigroup s => s -> TVar s -> STM s
refLookup :: String -> Map Reference Word64 -> Reference -> Word64
decodeCacheArgument :: Seq Closure -> IO [(Reference, SuperGroup Symbol)]
decodeSandboxArgument :: Seq Closure -> IO [Reference]
encodeSandboxListResult :: [Reference] -> Seq Closure
encodeSandboxResult :: Either [Reference] [Reference] -> Closure
encodeLeft :: Closure -> Closure
encodeRight :: Closure -> Closure
addRefs :: TVar Word64 -> TVar (Map Reference Word64) -> TVar (EnumMap Word64 Reference) -> Set Reference -> STM (Map Reference Word64)
codeValidate :: [(Reference, SuperGroup Symbol)] -> CCache -> IO (Maybe (Failure Closure))
sandboxList :: CCache -> Referent -> IO [Reference]
checkSandboxing :: CCache -> [Reference] -> Closure -> IO Bool
checkValueSandboxing :: CCache -> [Reference] -> Value -> IO (Either [Reference] [Reference])
evaluateSTM :: a -> STM a
cacheAdd0 :: Set Reference -> [(Reference, SuperGroup Symbol)] -> [(Reference, Set Reference)] -> CCache -> IO ()
expandSandbox :: Map Reference (Set Reference) -> [(Reference, SuperGroup Symbol)] -> [(Reference, Set Reference)]
cacheAdd :: [(Reference, SuperGroup Symbol)] -> CCache -> IO [Reference]
reflectValue :: EnumMap Word64 Reference -> Closure -> IO Value
reifyValue :: CCache -> Value -> IO (Either [Reference] Closure)
reifyValue0 :: (Map Reference Word64, Map Reference Word64) -> Value -> IO Closure
doubleToInt :: Double -> Int
intToDouble :: Int -> Double
closureNum :: Closure -> Int
universalEq :: (Foreign -> Foreign -> Bool) -> Closure -> Closure -> Bool
arrayEq :: (Closure -> Closure -> Bool) -> Array Closure -> Array Closure -> Bool
compareAsFloat :: Int -> Int -> Ordering
compareAsNat :: Int -> Int -> Ordering
floatTag :: Word64
natTag :: Word64
intTag :: Word64
charTag :: Word64
unitTag :: Word64
leftTag :: Word64
rightTag :: Word64
universalCompare :: (Foreign -> Foreign -> Ordering) -> Closure -> Closure -> Ordering
arrayCmp :: (Closure -> Closure -> Ordering) -> Array Closure -> Array Closure -> Ordering

module Unison.Runtime.Interface
startRuntime :: Bool -> RuntimeHost -> Text -> IO (Runtime Symbol)
withRuntime :: MonadUnliftIO m => Bool -> RuntimeHost -> Text -> (Runtime Symbol -> m a) -> m a
startNativeRuntime :: Text -> FilePath -> IO (Runtime Symbol)
standalone :: CCache -> Word64 -> IO StoredCache
runStandalone :: StoredCache -> Word64 -> IO (Either (Pretty ColorText) ())
data StoredCache
decodeStandalone :: ByteString -> Either String (Text, Text, Word64, StoredCache)

-- | Whether the runtime is hosted within a persistent session or as a
--   one-off process. This affects the amount of clean-up and book-keeping
--   the runtime does.
data RuntimeHost
OneOff :: RuntimeHost
Persistent :: RuntimeHost
data Runtime v
Runtime :: IO () -> (CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error ([Error], Term v))) -> (CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)) -> Type v Ann -> NESet (Type v Ann) -> Runtime v
[$sel:terminate:Runtime] :: Runtime v -> IO ()
[$sel:evaluate:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error ([Error], Term v))
[$sel:compileTo:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)
[$sel:mainType:Runtime] :: Runtime v -> Type v Ann
[$sel:ioTestTypes:Runtime] :: Runtime v -> NESet (Type v Ann)
instance GHC.Show.Show Unison.Runtime.Interface.StoredCache
instance GHC.Base.Semigroup Unison.Runtime.Interface.Remapping
instance GHC.Base.Monoid Unison.Runtime.Interface.Remapping

module Unison.Util.TransitiveClosure
transitiveClosure :: forall m a. (Monad m, Ord a) => (a -> m (Set a)) -> Set a -> m (Set a)
transitiveClosure' :: Ord a => (a -> Set a) -> Set a -> Set a
transitiveClosure1 :: forall m a. (Monad m, Ord a) => (a -> m (Set a)) -> a -> m (Set a)
transitiveClosure1' :: Ord a => (a -> Set a) -> a -> Set a
