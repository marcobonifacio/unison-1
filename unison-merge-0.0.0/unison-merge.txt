-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-merge
@version 0.0.0

module Unison.Merge.Database
data MergeDatabase
MergeDatabase :: (CausalHash -> Transaction (CausalBranch Transaction)) -> (TypeReferenceId -> Transaction Int) -> (TypeReference -> Transaction ConstructorType) -> (TypeReferenceId -> Transaction (Decl Symbol Ann)) -> (Hash -> Transaction [Decl Symbol Ann]) -> (TermReferenceId -> Transaction (Term Symbol Ann)) -> (Hash -> Transaction [(Term Symbol Ann, Type Symbol Ann)]) -> MergeDatabase
[$sel:loadCausal:MergeDatabase] :: MergeDatabase -> CausalHash -> Transaction (CausalBranch Transaction)
[$sel:loadDeclNumConstructors:MergeDatabase] :: MergeDatabase -> TypeReferenceId -> Transaction Int
[$sel:loadDeclType:MergeDatabase] :: MergeDatabase -> TypeReference -> Transaction ConstructorType
[$sel:loadV1Decl:MergeDatabase] :: MergeDatabase -> TypeReferenceId -> Transaction (Decl Symbol Ann)
[$sel:loadV1DeclComponent:MergeDatabase] :: MergeDatabase -> Hash -> Transaction [Decl Symbol Ann]
[$sel:loadV1Term:MergeDatabase] :: MergeDatabase -> TermReferenceId -> Transaction (Term Symbol Ann)
[$sel:loadV1TermComponent:MergeDatabase] :: MergeDatabase -> Hash -> Transaction [(Term Symbol Ann, Type Symbol Ann)]
referent2to1 :: MergeDatabase -> Referent -> Transaction Referent
makeMergeDatabase :: MonadIO m => Codebase IO Symbol Ann -> m MergeDatabase

module Unison.Merge.DeclNameLookup

-- | A lookup from decl-to-constructor name and vice-versa.
--   
--   For example, a type decl like
--   
--   <pre>
--   unique type Foo
--     = Bar Int
--     | Baz.Qux Nat Nat
--   </pre>
--   
--   is represented as
--   
--   <pre>
--   DeclNameLookup
--     { constructorToDecl = Map.fromList [(<a>Foo.Bar</a>, <a>Foo</a>), (<a>Foo.Baz.Qux</a>, <a>Foo</a>)]
--     , declToConstructors = Map.fromList [(<a>Foo</a>, [<a>Foo.Bar</a>, <a>Foo.Baz.Qux</a>])]
--     }
--   </pre>
--   
--   Note that:
--   
--   <ul>
--   <li>Constructor names are given "in full", though they will all
--   necessarily begin with the decl's name.</li>
--   <li>In <tt>declToConstructors</tt>, the constructor names are given in
--   their canonical ordering.</li>
--   </ul>
data DeclNameLookup
DeclNameLookup :: !Map Name Name -> !Map Name [Name] -> DeclNameLookup
[$sel:constructorToDecl:DeclNameLookup] :: DeclNameLookup -> !Map Name Name
[$sel:declToConstructors:DeclNameLookup] :: DeclNameLookup -> !Map Name [Name]
expectDeclName :: HasCallStack => DeclNameLookup -> Name -> Name
expectConstructorNames :: HasCallStack => DeclNameLookup -> Name -> [Name]
instance GHC.Base.Semigroup Unison.Merge.DeclNameLookup.DeclNameLookup
instance GHC.Generics.Generic Unison.Merge.DeclNameLookup.DeclNameLookup


-- | The "decl coherency check": a type declaration in a namespace is
--   "coherent" if it satisfies both of the following criteria.
--   
--   <ol>
--   <li>For each naming of the type decl (say <a>Foo</a>#foohash), there
--   exists exactly one name for each of its constructors arbitrarily deep
--   in the corresponding namespace (<a>Foo</a> in this example).</li>
--   </ol>
--   
--   This allows us to render the decl naturally, as in
--   
--   structural type Foo = Bar Nat Int | internal.hello.Bonk Nat
--   
--   which corresponds to the three names
--   
--   <a>Foo</a> =&gt; #foohash <a>Foo.Bar</a> =&gt; 0
--   "Foo.internal.hello.Bonk" =&gt; 1
--   
--   We could not do if there was at least one constructor whose full name
--   does not contain the full name of the type decl itself as a prefix.
--   
--   A notable consequence of this requirement is that a second naming of a
--   decl (i.e. an alias) cannot be embedded within the first naming, as
--   in:
--   
--   type Foo = ... type Foo.some.inner.namespace = ... -- an alias of Foo
--   
--   <ol>
--   <li>No constructor has a "stray" name that does not have a prefix that
--   equals the type declaration's name. For example, in the
--   namespace<a>Foo</a> =&gt; #foohash <a>Foo.Bar</a> =&gt; 0
--   <a>Deep.What.SomeAlias</a> =&gt; 0</li>
--   </ol>
--   
--   the constructor <a>What.SomeAlias</a> is "stray", as the type decl
--   #foohash has no name that matches any prefix (i.e. <a>Deep.What</a>
--   nor <a>Deep</a>).
--   
--   On to the implementation. We are going to traverse the namespace
--   depth-first. As we go, we have a stateful mapping between decl
--   reference that we *have* seen a name for in one of our parent
--   namespace, and its corresponding set of constructors that we *haven't*
--   yet seen names for, but expect to, before fully searching the
--   corresponding sub-namespace (e.g. the child namespace named <a>Foo</a>
--   of the namepace that declares a decl <a>Foo</a>).
--   
--   When processing a namespace, we first process all terms. Each
--   constructor will fall into one of three cases:
--   
--   <pre>
--   +----------------------------------------------------------------------------------------------------------------+
--   | Case         | Mapping before       | Encountered constructor | Mapping after                                  |
--   +----------------------------------------------------------------------------------------------------------------+
--   | Happy path   | { #foo : {0, 1, 2} } | #foo#1                  | { #foo : {0, 2} }                              |
--   | Already seen | { #foo : {0, 1, 2} } | #foo#5                  | Error: duplicate naming for constructor #foo#5 |
--   | Never seen   | { #foo : {0, 1, 2} } | #bar#2                  | Error: stray constructor #bar#2                |
--   +----------------------------------------------------------------------------------------------------------------+
--   </pre>
--   
--   In "happy path", we see a naming of a constructor that we're
--   expecting, and check it off. In "already seen", we see a second naming
--   of a constructor that we're no longer expecting, and fail. In "never
--   seen", we see a naming of a constructor before any naming of its decl,
--   so we fail.
--   
--   Next, we process all type decls. Each will again fall into one of
--   three cases:
--   
--   <pre>
--   +-----------------------------------------------------------------------------------------------------+
--   | Case             | Mapping before       | Declaration | Num constructors | New mapping              |
--   +-----------------------------------------------------------------------------------------------------+
--   | Uninhabited decl |                      | #foo        | 0                |                          |
--   | Inhabited decl   |                      | #foo        | 1 or more        | { #foo : {0, ..., n-1} } |
--   | Already seen     | { foo : {0, 1, 2}  } | #foo        | Irrelevant       | Error: nested decl alias |
--   +-----------------------------------------------------------------------------------------------------+
--   </pre>
--   
--   In "uninhabited decl", we find a decl with no constructors, so we
--   don't expect anything new. In "already seen", we find a second naming
--   of a decl, whose constructors will necessarily violate coherency
--   condition (1) above.
--   
--   In "inhabited decl", we find a decl with N constructors, and handle it
--   by: 1. Adding to our state that we expect a name for each. 2.
--   Recursing into the child namespace whose name matches the decl. 3. (If
--   we return from the recursion without short-circuiting) remove the
--   mapping added in step (1) and assert that its value is the empty set
--   (meaning we encountered a name for every constructor).
--   
--   Note: This check could be moved into SQLite (with sufficient schema
--   support) some day, but for now, we just do this in memory.
--   
--   Note: once upon a time, decls could be "incoherent". Then, we decided
--   we want decls to be "coherent". Thus, this machinery was invented.
module Unison.Merge.DeclCoherencyCheck
data IncoherentDeclReason

-- | A second naming of a constructor was discovered underneath a decl's
--   name, e.g.
--   
--   Foo#Foo Foo.Bar0 Foo.Some.Other.Name.For.Bar0
IncoherentDeclReason'ConstructorAlias :: !Name -> !Name -> !Name -> IncoherentDeclReason
IncoherentDeclReason'MissingConstructorName :: !Name -> IncoherentDeclReason

-- | A second naming of a decl was discovered underneath its name, e.g.
--   
--   Foo#Foo Foo.Bar#Foo
IncoherentDeclReason'NestedDeclAlias :: !Name -> !Name -> IncoherentDeclReason
IncoherentDeclReason'StrayConstructor :: !Name -> IncoherentDeclReason
checkDeclCoherency :: forall m. Monad m => (TypeReferenceId -> m Int) -> Nametree (DefnsF (Map NameSegment) Referent TypeReference) -> m (Either IncoherentDeclReason DeclNameLookup)

-- | A lenient variant of <a>checkDeclCoherency</a> - so lenient it can't
--   even fail! It returns a mapping from decl name to constructor names,
--   where constructor names can be missing.
--   
--   This function exists merely to extract a best-effort
--   decl-name-to-constructor-name mapping for the LCA of a merge. We
--   require Alice and Bob to have coherent decls, but their LCA is out of
--   the user's control and may have incoherent decls, and whether or not
--   it does, we still need to compute *some* syntactic hash for its decls.
lenientCheckDeclCoherency :: forall m. Monad m => (TypeReferenceId -> m Int) -> Nametree (DefnsF (Map NameSegment) Referent TypeReference) -> m (Map Name [Maybe Name])
instance GHC.Generics.Generic Unison.Merge.DeclCoherencyCheck.LenientDeclCoherencyCheckState
instance GHC.Generics.Generic Unison.Merge.DeclCoherencyCheck.DeclCoherencyCheckState
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.DeclCoherencyCheck.WhatHappened a)
instance GHC.Base.Functor Unison.Merge.DeclCoherencyCheck.WhatHappened

module Unison.Merge.EitherWay

-- | Alice exclusive-or Bob?
data EitherWay a
Alice :: a -> EitherWay a
Bob :: a -> EitherWay a
swap :: EitherWay a -> EitherWay a
value :: EitherWay a -> a
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.EitherWay.EitherWay a)
instance GHC.Base.Functor Unison.Merge.EitherWay.EitherWay
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Merge.EitherWay.EitherWay a)

module Unison.Merge.EitherWayI

-- | Alice inclusive-or Bob?
data EitherWayI a
OnlyAlice :: a -> EitherWayI a
OnlyBob :: a -> EitherWayI a
AliceAndBob :: a -> EitherWayI a
includingAlice :: EitherWayI a -> Maybe a
excludingAlice :: EitherWayI a -> Maybe a
value :: EitherWayI a -> a
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.EitherWayI.EitherWayI a)
instance GHC.Base.Functor Unison.Merge.EitherWayI.EitherWayI


-- | Utilities for computing the "syntactic hash" of a decl or term, which
--   is a hash that is computed after substituting references to other
--   terms and decls with names from a pretty-print environment.
--   
--   Thus, syntactic hashes can be compared for equality to answer
--   questions like "would these definitions look the same when rendered
--   for a human (even if their underlying references are different)?".
--   
--   The merge algorithm currently uses syntactic hashes for determining
--   whether an update was performed by a human, or was the result of
--   auto-propagation. (Critically, this cannot handle renames very well).
--   For example, consider comparing two definitions on Alice's branch; one
--   old one from somewhere in its history, and one new:
--   
--   old namespace new namespace ---------------- --------------- foo =
--   #bar + 3 foo = #bar2 + 3
--   
--   Either Alice manually updated #bar to #bar2, or else a dependency of
--   #bar was updated, inducing an update to #bar2. Computing the syntactic
--   hash can help answer that question. Let's combine a pretty-print
--   environment for the old and new namespaces together, substitute
--   references with it, and look again at the terms:
--   
--   old namespace new namespace ---------------- ---------------- foo =
--   helper + 3 foo = helper + 3
--   
--   We see now that our pretty-print environment has mapped both #bar and
--   #bar2 to the name "helper", so each version of "foo" would have the
--   same syntactic hash. This indicates (to our merge algorithm) that this
--   was an auto-propagated update.
module Unison.Merge.Synhash

-- | Syntactically hash a type, using reference names rather than hashes.
--   Two types will have the same syntactic hash if they would print the
--   the same way under the given pretty-print env.
synhashType :: Var v => PrettyPrintEnv -> Type v a -> Hash

-- | Syntactically hash a term, using reference names rather than hashes.
--   Two terms will have the same syntactic hash if they would print the
--   the same way under the given pretty-print env.
synhashTerm :: forall m v a. (Monad m, Var v) => (TypeReferenceId -> m (Term v a)) -> PrettyPrintEnv -> Referent -> m Hash
synhashBuiltinDecl :: Text -> Hash

-- | Syntactically hash a decl, using reference names rather than hashes.
--   Two decls will have the same syntactic hash if they they are the same
--   sort of decl (both are data decls or both are effect decls), the
--   unique type guid is the same, the constructors appear in the same
--   order and have the same names, and the constructors' types have the
--   same syntactic hashes.
synhashDerivedDecl :: Var v => PrettyPrintEnv -> Name -> Decl v a -> Hash

module Unison.Merge.Synhashed

-- | A small utility type that represents a syntactic-hashed thing.
--   
--   The <a>Eq</a> and <a>Ord</a> instances only compares syntactic hashes.
data Synhashed a
Synhashed :: !Hash -> !a -> Synhashed a
[$sel:hash:Synhashed] :: Synhashed a -> !Hash
[$sel:value:Synhashed] :: Synhashed a -> !a
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.Synhashed.Synhashed a)
instance GHC.Generics.Generic (Unison.Merge.Synhashed.Synhashed a)
instance GHC.Base.Functor Unison.Merge.Synhashed.Synhashed
instance GHC.Classes.Eq (Unison.Merge.Synhashed.Synhashed a)
instance GHC.Classes.Ord (Unison.Merge.Synhashed.Synhashed a)

module Unison.Merge.TwoOrThreeWay
data TwoOrThreeWay a
TwoOrThreeWay :: Maybe a -> a -> a -> TwoOrThreeWay a
[$sel:lca:TwoOrThreeWay] :: TwoOrThreeWay a -> Maybe a
[$sel:alice:TwoOrThreeWay] :: TwoOrThreeWay a -> a
[$sel:bob:TwoOrThreeWay] :: TwoOrThreeWay a -> a
instance Data.Traversable.Traversable Unison.Merge.TwoOrThreeWay.TwoOrThreeWay
instance GHC.Generics.Generic (Unison.Merge.TwoOrThreeWay.TwoOrThreeWay a)
instance GHC.Base.Functor Unison.Merge.TwoOrThreeWay.TwoOrThreeWay
instance Data.Foldable.Foldable Unison.Merge.TwoOrThreeWay.TwoOrThreeWay

module Unison.Merge.TwoWay
data TwoWay a
TwoWay :: a -> a -> TwoWay a
[$sel:alice:TwoWay] :: TwoWay a -> a
[$sel:bob:TwoWay] :: TwoWay a -> a
bothWays :: a -> TwoWay a
justTheTerms :: TwoWay (Defns terms types) -> TwoWay terms
justTheTypes :: TwoWay (Defns terms types) -> TwoWay types
or :: TwoWay Bool -> Bool
sequenceDefns :: TwoWay (Defns terms types) -> DefnsF TwoWay terms types

-- | Swap who's considered Alice and who's considered Bob. Usually
--   nonsense, but sometimes what you need!
swap :: TwoWay a -> TwoWay a
twoWay :: (a -> a -> b) -> TwoWay a -> b

-- | Unzip a <tt>Map k (TwoWay v)</tt> into a <tt>TwoWay (Map k v)</tt>.
unzipMap :: Ord k => Map k (TwoWay v) -> TwoWay (Map k v)
who_ :: EitherWay x -> Lens' (TwoWay a) a
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Merge.TwoWay.TwoWay a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Unison.Merge.TwoWay.TwoWay a)
instance Data.Traversable.Traversable Unison.Merge.TwoWay.TwoWay
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.TwoWay.TwoWay a)
instance GHC.Generics.Generic (Unison.Merge.TwoWay.TwoWay a)
instance GHC.Base.Functor Unison.Merge.TwoWay.TwoWay
instance Data.Foldable.Foldable Unison.Merge.TwoWay.TwoWay
instance GHC.Base.Applicative Unison.Merge.TwoWay.TwoWay
instance Data.Semialign.Internal.Semialign Unison.Merge.TwoWay.TwoWay
instance Data.Semialign.Internal.Unzip Unison.Merge.TwoWay.TwoWay
instance Data.Semialign.Internal.Zip Unison.Merge.TwoWay.TwoWay

module Unison.Merge.ThreeWay
data ThreeWay a
ThreeWay :: !a -> !a -> !a -> ThreeWay a
[$sel:lca:ThreeWay] :: ThreeWay a -> !a
[$sel:alice:ThreeWay] :: ThreeWay a -> !a
[$sel:bob:ThreeWay] :: ThreeWay a -> !a
forgetLca :: ThreeWay a -> TwoWay a
instance Data.Traversable.Traversable Unison.Merge.ThreeWay.ThreeWay
instance GHC.Generics.Generic (Unison.Merge.ThreeWay.ThreeWay a)
instance GHC.Base.Functor Unison.Merge.ThreeWay.ThreeWay
instance Data.Foldable.Foldable Unison.Merge.ThreeWay.ThreeWay
instance GHC.Base.Applicative Unison.Merge.ThreeWay.ThreeWay
instance Data.Semialign.Internal.Semialign Unison.Merge.ThreeWay.ThreeWay
instance Data.Semialign.Internal.Unzip Unison.Merge.ThreeWay.ThreeWay
instance Data.Semialign.Internal.Zip Unison.Merge.ThreeWay.ThreeWay

module Unison.Merge.TwoWayI

-- | "Two-way inclusive".
data TwoWayI a
TwoWayI :: a -> a -> a -> TwoWayI a
[$sel:alice:TwoWayI] :: TwoWayI a -> a
[$sel:bob:TwoWayI] :: TwoWayI a -> a
[$sel:both:TwoWayI] :: TwoWayI a -> a
forgetBoth :: TwoWayI a -> TwoWay a
who_ :: EitherWayI x -> Lens' (TwoWayI a) a
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Merge.TwoWayI.TwoWayI a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Unison.Merge.TwoWayI.TwoWayI a)
instance GHC.Generics.Generic (Unison.Merge.TwoWayI.TwoWayI a)
instance GHC.Base.Functor Unison.Merge.TwoWayI.TwoWayI
instance Data.Foldable.Foldable Unison.Merge.TwoWayI.TwoWayI
instance GHC.Base.Applicative Unison.Merge.TwoWayI.TwoWayI
instance Data.Semialign.Internal.Semialign Unison.Merge.TwoWayI.TwoWayI
instance Data.Semialign.Internal.Zip Unison.Merge.TwoWayI.TwoWayI

module Unison.Merge.Unconflicts
data Unconflicts v
Unconflicts :: !TwoWayI (Map Name v) -> !TwoWayI (Map Name v) -> !TwoWayI (Map Name v) -> Unconflicts v
[$sel:adds:Unconflicts] :: Unconflicts v -> !TwoWayI (Map Name v)
[$sel:deletes:Unconflicts] :: Unconflicts v -> !TwoWayI (Map Name v)
[$sel:updates:Unconflicts] :: Unconflicts v -> !TwoWayI (Map Name v)
empty :: Unconflicts v

-- | Apply unconflicts to a namespace.
apply :: forall v. Unconflicts v -> Map Name v -> Map Name v
soloDeletedNames :: Unconflicts v -> TwoWay (Set Name)
soloUpdatedNames :: Unconflicts v -> TwoWay (Set Name)
instance GHC.Generics.Generic (Unison.Merge.Unconflicts.Unconflicts v)
instance GHC.Base.Functor Unison.Merge.Unconflicts.Unconflicts
instance Data.Foldable.Foldable Unison.Merge.Unconflicts.Unconflicts

module Unison.Merge.Updated

-- | An updated thing.
data Updated a
Updated :: a -> a -> Updated a
[$sel:old:Updated] :: Updated a -> a
[$sel:new:Updated] :: Updated a -> a
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.Updated.Updated a)
instance GHC.Generics.Generic (Unison.Merge.Updated.Updated a)
instance GHC.Base.Functor Unison.Merge.Updated.Updated

module Unison.Merge.DiffOp

-- | A diff operation is one of:
--   
--   <ul>
--   <li>An add (where nothing was)</li>
--   <li>A delete (of the thing that was)</li>
--   <li>An update (from old to new)</li>
--   </ul>
data DiffOp a
DiffOp'Add :: !a -> DiffOp a
DiffOp'Delete :: !a -> DiffOp a
DiffOp'Update :: !Updated a -> DiffOp a
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.DiffOp.DiffOp a)
instance GHC.Base.Functor Unison.Merge.DiffOp.DiffOp

module Unison.Merge.TwoDiffOps
data TwoDiffOps a
TwoDiffOps'Add :: !EitherWay a -> TwoDiffOps a
TwoDiffOps'Delete :: !EitherWay a -> TwoDiffOps a
TwoDiffOps'Update :: !EitherWay (Updated a) -> TwoDiffOps a
TwoDiffOps'AddAdd :: !TwoWay a -> TwoDiffOps a
TwoDiffOps'DeleteDelete :: !a -> TwoDiffOps a
TwoDiffOps'DeleteUpdate :: !Updated a -> TwoDiffOps a
TwoDiffOps'UpdateDelete :: !Updated a -> TwoDiffOps a
TwoDiffOps'UpdateUpdate :: !a -> !TwoWay a -> TwoDiffOps a

-- | Combine two aligned <tt>DiffOp</tt> into one <tt>TwoDiffOps</tt>.
make :: These (DiffOp a) (DiffOp a) -> TwoDiffOps a


-- | An API for merging together two collections of library dependencies.
module Unison.Merge.Libdeps

-- | Perform a three-way merge on two collections of library dependencies.
mergeLibdeps :: forall k v. (Ord k, Eq v) => (Set k -> k -> (k, k)) -> ThreeWay (Map k v) -> Map k v

module Unison.Merge.Diff

-- | <tt>nameBasedNamespaceDiff db declNameLookups defns</tt> returns
--   Alice's and Bob's name-based namespace diffs, each in the form:
--   
--   <pre>
--   terms :: Map Name (DiffOp (Synhashed Referent))
--   types :: Map Name (DiffOp (Synhashed TypeReference))
--   </pre>
--   
--   where each name is paired with its diff-op (added, deleted, or
--   updated), relative to the LCA between Alice and Bob's branches. If the
--   hash of a name did not change, it will not appear in the map.
nameBasedNamespaceDiff :: MergeDatabase -> TwoWay DeclNameLookup -> Map Name [Maybe Name] -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name)) -> Transaction (TwoWay (DefnsF3 (Map Name) DiffOp Synhashed Referent TypeReference))


-- | Combine two diffs together.
module Unison.Merge.CombineDiffs

-- | The combined result of two diffs on the same thing.
data CombinedDiffOp a
CombinedDiffOp'Add :: !EitherWayI a -> CombinedDiffOp a
CombinedDiffOp'Delete :: !EitherWayI a -> CombinedDiffOp a
CombinedDiffOp'Update :: !EitherWayI (Updated a) -> CombinedDiffOp a
CombinedDiffOp'Conflict :: !TwoWay a -> CombinedDiffOp a

-- | Combine LCA-&gt;Alice diff and LCA-&gt;Bob diff.
combineDiffs :: TwoWay (DefnsF3 (Map Name) DiffOp Synhashed Referent TypeReference) -> DefnsF2 (Map Name) CombinedDiffOp Referent TypeReference
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.CombineDiffs.CombinedDiffOp a)
instance GHC.Base.Functor Unison.Merge.CombineDiffs.CombinedDiffOp

module Unison.Merge.PartitionCombinedDiffs

-- | Combine LCA-&gt;Alice diff and LCA-&gt;Bob diff, then partition into
--   conflicted and unconflicted things.
partitionCombinedDiffs :: TwoWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name)) -> TwoWay DeclNameLookup -> DefnsF2 (Map Name) CombinedDiffOp Referent TypeReference -> Either Name (TwoWay (DefnsF (Map Name) TermReferenceId TypeReferenceId), DefnsF Unconflicts Referent TypeReference)
instance GHC.Generics.Generic Unison.Merge.PartitionCombinedDiffs.S
