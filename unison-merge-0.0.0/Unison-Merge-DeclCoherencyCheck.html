<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Unison.Merge.DeclCoherencyCheck</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">unison-merge-0.0.0</span><ul class="links" id="page-menu"><li><a href="src/Unison.Merge.DeclCoherencyCheck.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Unison.Merge.DeclCoherencyCheck</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The &quot;decl coherency check&quot;: a type declaration in a namespace is &quot;coherent&quot; if it satisfies both of the following
 criteria.</p><ol><li>For each naming of the type decl (say <a href="Foo.html">Foo</a>#foohash), there exists exactly one name for each of its constructors
      arbitrarily deep in the corresponding namespace (<a href="Foo.html">Foo</a> in this example).</li></ol><p>This allows us to render the decl naturally, as in</p><p>structural type Foo
          = Bar Nat Int
          | internal.hello.Bonk Nat</p><p>which corresponds to the three names</p><p><a href="Foo.html">Foo</a>                     =&gt; #foohash
        <a href="Foo-Bar.html">Foo.Bar</a>                 =&gt; <a id="foohash"></a>0
        &quot;Foo.internal.hello.Bonk&quot; =&gt; <a id="foohash"></a>1</p><p>We could not do if there was at least one constructor whose full name does not contain the full name of the type
      decl itself as a prefix.</p><p>A notable consequence of this requirement is that a second naming of a decl (i.e. an alias) cannot be embedded
      within the first naming, as in:</p><p>type Foo = ...
        type Foo.some.inner.namespace = ... -- an alias of Foo</p><ol><li><p>No constructor has a &quot;stray&quot; name that does not have a prefix that equals the type declaration's name. For
      example, in the namespace</p><p><a href="Foo.html">Foo</a>                 =&gt; #foohash
 <a href="Foo-Bar.html">Foo.Bar</a>             =&gt; <a id="foohash"></a>0
 <a href="Deep-What-SomeAlias.html">Deep.What.SomeAlias</a> =&gt; <a id="foohash"></a>0</p></li></ol><p>the constructor <a href="What-SomeAlias.html">What.SomeAlias</a> is &quot;stray&quot;, as the type decl #foohash has no name that matches any prefix
      (i.e. <a href="Deep-What.html">Deep.What</a> nor <a href="Deep.html">Deep</a>).</p><p>On to the implementation. We are going to traverse the namespace depth-first. As we go, we have a stateful mapping
 between decl reference that we *have* seen a name for in one of our parent namespace, and its corresponding set of
 constructors that we *haven't* yet seen names for, but expect to, before fully searching the corresponding
 sub-namespace (e.g. the child namespace named <a href="Foo.html">Foo</a> of the namepace that declares a decl <a href="Foo.html">Foo</a>).</p><p>When processing a namespace, we first process all terms. Each constructor will fall into one of three cases:</p><pre>+----------------------------------------------------------------------------------------------------------------+
| Case         | Mapping before       | Encountered constructor | Mapping after                                  |
+----------------------------------------------------------------------------------------------------------------+
| Happy path   | { #foo : {0, 1, 2} } | #foo#1                  | { #foo : {0, 2} }                              |
| Already seen | { #foo : {0, 1, 2} } | #foo#5                  | Error: duplicate naming for constructor #foo#5 |
| Never seen   | { #foo : {0, 1, 2} } | #bar#2                  | Error: stray constructor #bar#2                |
+----------------------------------------------------------------------------------------------------------------+</pre><p>In &quot;happy path&quot;, we see a naming of a constructor that we're expecting, and check it off.
 In &quot;already seen&quot;, we see a second naming of a constructor that we're no longer expecting, and fail.
 In &quot;never seen&quot;, we see a naming of a constructor before any naming of its decl, so we fail.</p><p>Next, we process all type decls. Each will again fall into one of three cases:</p><pre>+-----------------------------------------------------------------------------------------------------+
| Case             | Mapping before       | Declaration | Num constructors | New mapping              |
+-----------------------------------------------------------------------------------------------------+
| Uninhabited decl |                      | #foo        | 0                |                          |
| Inhabited decl   |                      | #foo        | 1 or more        | { #foo : {0, ..., n-1} } |
| Already seen     | { foo : {0, 1, 2}  } | #foo        | Irrelevant       | Error: nested decl alias |
+-----------------------------------------------------------------------------------------------------+</pre><p>In &quot;uninhabited decl&quot;, we find a decl with no constructors, so we don't expect anything new.
 In &quot;already seen&quot;, we find a second naming of a decl, whose constructors will necessarily violate coherency condition
   (1) above.</p><p>In &quot;inhabited decl&quot;, we find a decl with N constructors, and handle it by:
   1. Adding to our state that we expect a name for each.
   2. Recursing into the child namespace whose name matches the decl.
   3. (If we return from the recursion without short-circuiting) remove the mapping added in step (1) and assert that
      its value is the empty set (meaning we encountered a name for every constructor).</p><p>Note: This check could be moved into SQLite (with sufficient schema support) some day, but for now, we just do this
 in memory.</p><p>Note: once upon a time, decls could be &quot;incoherent&quot;. Then, we decided we want decls to be &quot;coherent&quot;. Thus, this
 machinery was invented.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:IncoherentDeclReason">IncoherentDeclReason</a><ul class="subs"><li>= <a href="#v:IncoherentDeclReason-39-ConstructorAlias">IncoherentDeclReason'ConstructorAlias</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a></li><li>| <a href="#v:IncoherentDeclReason-39-MissingConstructorName">IncoherentDeclReason'MissingConstructorName</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a></li><li>| <a href="#v:IncoherentDeclReason-39-NestedDeclAlias">IncoherentDeclReason'NestedDeclAlias</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a></li><li>| <a href="#v:IncoherentDeclReason-39-StrayConstructor">IncoherentDeclReason'StrayConstructor</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a></li></ul></li><li class="src short"><a href="#v:checkDeclCoherency">checkDeclCoherency</a> :: <span class="keyword">forall</span> m. <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (<a href="../unison-core-0.0.0/U-Codebase-Reference.html#t:TypeReferenceId" title="U.Codebase.Reference">TypeReferenceId</a> -&gt; m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; <a href="../unison-util-nametree-0.0.0/Unison-Util-Nametree.html#t:Nametree" title="Unison.Util.Nametree">Nametree</a> (<a href="../unison-util-nametree-0.0.0/Unison-Util-Defns.html#t:DefnsF" title="Unison.Util.Defns">DefnsF</a> (<a href="../containers-0.6.5.1/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="../unison-core-0.0.0/Unison-NameSegment-Internal.html#t:NameSegment" title="Unison.NameSegment.Internal">NameSegment</a>) <a href="../unison-core1-0.0.0/Unison-Referent.html#t:Referent" title="Unison.Referent">Referent</a> <a href="../unison-core-0.0.0/U-Codebase-Reference.html#t:TypeReference" title="U.Codebase.Reference">TypeReference</a>) -&gt; m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Unison-Merge-DeclCoherencyCheck.html#t:IncoherentDeclReason" title="Unison.Merge.DeclCoherencyCheck">IncoherentDeclReason</a> <a href="Unison-Merge-DeclNameLookup.html#t:DeclNameLookup" title="Unison.Merge.DeclNameLookup">DeclNameLookup</a>)</li><li class="src short"><a href="#v:lenientCheckDeclCoherency">lenientCheckDeclCoherency</a> :: <span class="keyword">forall</span> m. <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (<a href="../unison-core-0.0.0/U-Codebase-Reference.html#t:TypeReferenceId" title="U.Codebase.Reference">TypeReferenceId</a> -&gt; m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; <a href="../unison-util-nametree-0.0.0/Unison-Util-Nametree.html#t:Nametree" title="Unison.Util.Nametree">Nametree</a> (<a href="../unison-util-nametree-0.0.0/Unison-Util-Defns.html#t:DefnsF" title="Unison.Util.Defns">DefnsF</a> (<a href="../containers-0.6.5.1/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="../unison-core-0.0.0/Unison-NameSegment-Internal.html#t:NameSegment" title="Unison.NameSegment.Internal">NameSegment</a>) <a href="../unison-core1-0.0.0/Unison-Referent.html#t:Referent" title="Unison.Referent">Referent</a> <a href="../unison-core-0.0.0/U-Codebase-Reference.html#t:TypeReference" title="U.Codebase.Reference">TypeReference</a>) -&gt; m (<a href="../containers-0.6.5.1/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a> [<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a>])</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:IncoherentDeclReason" class="def">IncoherentDeclReason</a> <a href="src/Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason" class="link">Source</a> <a href="#t:IncoherentDeclReason" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:IncoherentDeclReason-39-ConstructorAlias" class="def">IncoherentDeclReason'ConstructorAlias</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a></td><td class="doc"><p>A second naming of a constructor was discovered underneath a decl's name, e.g.</p><p>Foo#Foo
   Foo.Bar<a id="Foo"></a>0
   Foo.Some.Other.Name.For.Bar<a id="Foo"></a>0</p></td></tr><tr><td class="src"><a id="v:IncoherentDeclReason-39-MissingConstructorName" class="def">IncoherentDeclReason'MissingConstructorName</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:IncoherentDeclReason-39-NestedDeclAlias" class="def">IncoherentDeclReason'NestedDeclAlias</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a></td><td class="doc"><p>A second naming of a decl was discovered underneath its name, e.g.</p><p>Foo#Foo
   Foo.Bar#Foo</p></td></tr><tr><td class="src"><a id="v:IncoherentDeclReason-39-StrayConstructor" class="def">IncoherentDeclReason'StrayConstructor</a> !<a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a id="v:checkDeclCoherency" class="def">checkDeclCoherency</a> :: <span class="keyword">forall</span> m. <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (<a href="../unison-core-0.0.0/U-Codebase-Reference.html#t:TypeReferenceId" title="U.Codebase.Reference">TypeReferenceId</a> -&gt; m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; <a href="../unison-util-nametree-0.0.0/Unison-Util-Nametree.html#t:Nametree" title="Unison.Util.Nametree">Nametree</a> (<a href="../unison-util-nametree-0.0.0/Unison-Util-Defns.html#t:DefnsF" title="Unison.Util.Defns">DefnsF</a> (<a href="../containers-0.6.5.1/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="../unison-core-0.0.0/Unison-NameSegment-Internal.html#t:NameSegment" title="Unison.NameSegment.Internal">NameSegment</a>) <a href="../unison-core1-0.0.0/Unison-Referent.html#t:Referent" title="Unison.Referent">Referent</a> <a href="../unison-core-0.0.0/U-Codebase-Reference.html#t:TypeReference" title="U.Codebase.Reference">TypeReference</a>) -&gt; m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Unison-Merge-DeclCoherencyCheck.html#t:IncoherentDeclReason" title="Unison.Merge.DeclCoherencyCheck">IncoherentDeclReason</a> <a href="Unison-Merge-DeclNameLookup.html#t:DeclNameLookup" title="Unison.Merge.DeclNameLookup">DeclNameLookup</a>) <a href="src/Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherency" class="link">Source</a> <a href="#v:checkDeclCoherency" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:lenientCheckDeclCoherency" class="def">lenientCheckDeclCoherency</a> :: <span class="keyword">forall</span> m. <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (<a href="../unison-core-0.0.0/U-Codebase-Reference.html#t:TypeReferenceId" title="U.Codebase.Reference">TypeReferenceId</a> -&gt; m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; <a href="../unison-util-nametree-0.0.0/Unison-Util-Nametree.html#t:Nametree" title="Unison.Util.Nametree">Nametree</a> (<a href="../unison-util-nametree-0.0.0/Unison-Util-Defns.html#t:DefnsF" title="Unison.Util.Defns">DefnsF</a> (<a href="../containers-0.6.5.1/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="../unison-core-0.0.0/Unison-NameSegment-Internal.html#t:NameSegment" title="Unison.NameSegment.Internal">NameSegment</a>) <a href="../unison-core1-0.0.0/Unison-Referent.html#t:Referent" title="Unison.Referent">Referent</a> <a href="../unison-core-0.0.0/U-Codebase-Reference.html#t:TypeReference" title="U.Codebase.Reference">TypeReference</a>) -&gt; m (<a href="../containers-0.6.5.1/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a> [<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../unison-core1-0.0.0/Unison-Name-Internal.html#t:Name" title="Unison.Name.Internal">Name</a>]) <a href="src/Unison.Merge.DeclCoherencyCheck.html#lenientCheckDeclCoherency" class="link">Source</a> <a href="#v:lenientCheckDeclCoherency" class="selflink">#</a></p><div class="doc"><p>A lenient variant of <code><a href="Unison-Merge-DeclCoherencyCheck.html#v:checkDeclCoherency" title="Unison.Merge.DeclCoherencyCheck">checkDeclCoherency</a></code> - so lenient it can't even fail! It returns a mapping from decl name to
 constructor names, where constructor names can be missing.</p><p>This function exists merely to extract a best-effort decl-name-to-constructor-name mapping for the LCA of a merge.
 We require Alice and Bob to have coherent decls, but their LCA is out of the user's control and may have incoherent
 decls, and whether or not it does, we still need to compute *some* syntactic hash for its decls.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>